Раздел 1:Get Started Here! 
1. How to Get Help

Hello and welcome.

We're going to get started with the course in just a moment but before we do I want to tell you how

you can get help if you get stuck at any point during this course.

So there's three great ways to reach out to me.

The first is to post on the course discussion boards.

I usually check the Course discussion about once a day on Monday through Friday so I'll do my best to

get back to you as soon as possible if anything comes up.

The next best way to reach out to me is to send me a direct message on you to me.

I'm usually very good about responding to these requests and usually better about that than with the

Course Q&A.

Finally you can reach out to me via Twitter.

And here's my handle listed right here.

Twitter is a great way to reach out to me with short questions but if it's anything technical related

I usually recommend either posting on the course discussion or send me a PM because obviously with Twitter

we've got that character limit that makes technical discussions a little bit more challenging.

All right.

So that's the three ways to get help if you ever get stuck during this course.

Let's pause right now and we'll start talking about our first technical topic in the next video so I'll

see you in just a minute.
----------------------------------------------------------------------------------------------------------

2. The All Important Coding Interview

Before we dive into any technical content we are going to discuss some important items regarding interviews

and white board questions.

I want to put you in a certain frame of mind of how you should approach interviews and interview questions

so let's get to it.

We'll start off by looking at a couple of different diagrams.

First I want to show you a quick timeline of the general job seeking process at any given company getting

an offer from a company is really split into two different phases the contact phase in the interview

phase contact phase is when you try to get in contact with a living breathing human at a company and

this might take the form of talking to a recruiter getting a referral from a friend or submitting your

resume through some online form.

Now this part at the top isn't too bad.

You know right now there's a pretty good amount of demand for software engineers.

And so after some amount of time of sending out your resume talking to recruiters.

Eventually you will get through this phase.

What comes after the contact phase is much more interesting.

So after you make this initial contact you move on to the interview phase the interview phase consists

of phone screens take home coding assignments and on site interviews.

This is the real make or break part the part that decides whether or not you're going to get an offer

with these two phases in mind.

I want to now ask you a question.

So during each of these two phases What is the average company looking to evaluate in you.

Well I've got a couple of thoughts about that.

I think that the average company is evaluating a couple different qualities in you during each of these

two phases.

So during the initial contact phase the company kind of wants to get a general idea of who you are.

So what work experience do you have.

Do you have any interesting side projects.

Are you friends with many people at the company during the second phase.

However during the interview phase there are some distinctly different qualities that a company really

wants to evaluate once you meet and interview in person they are going to try to decide whether or not

you're a good culture fit like whether your personality is going to mesh well with other people at that

company.

But much much more importantly than that it's during this interview phase that a company is going to

attempt to evaluate whether or not you are an effective coder or a good engineer.

So what's the point of this.

I'm sure you know you've already gotten a good idea of how companies hire people.

But the point here is I want to really make sure that it's clear that of all these different qualities

out of everything that a company is doing to evaluate you there is exactly one make or break quality

that you can improve.

Right now today.

And that is your ability to code your ability to answer a coding interview questions is the single most

important quality that you are going to be judged on during the interview process.

I personally have seen many people apply and get accepted to companies like Google Facebook Amazon and

many of them had little work experience no side projects no social contacts.

They might not be the nicest person in the world.

Maybe they didn't have the best culture fit but they could code and they could answer whiteboard questions

effectively.

And that is going to override every other quality during the interview process.

So the big takeaway here is that just by being here in this course watching this video right now you're

making a great move because you are are on the path to improving one of the most critical and easily

improvable areas for getting a great job.

And I hope that doesnt sound like too much of a marketing statement on my part but really I want you

to understand that there is nothing that gives you bang for your buck in the job seeking world.

Like being good at coding interviews.

So with all of this in mind let's continue in the next section and start to break down exactly how you

can get better at coding questions.
---------------------------------------------------------------------------------------------------------------------------

3. Getting Better at Coding
Questions

In an interview setting interviewers have three big tools to evaluate your coding ability.

First they can assign you a take home project which is something that you would usually do on your own

time and then submit to the company looking to hire you.

Second your interviewer can sit down next to you at a computer and the two of you can do a little bit

of pair programming.

Usually this peer programming focuses on a more practical use of skills rather than algorithms or theoretical

questions.

Third and what you will see most frequently at large companies like Google or Facebook is whiteboarding.

So the term whiteboarding is a reference to standing at a whiteboard or a chalkboard and writing out

some code to satisfy your interviewers questions whiteboard interviews have traditionally been seen

as kind of confrontational and certainly very nerve wracking as well.

Nonetheless it really is the tool of preference for many large companies.

And like we just mentioned the last video whiteboarding really is the easiest area for you to get better

at.

So the natural question to ask here is how do we get better at whiteboard questions.

If this is how we get hired if doing well Whiteford questions is how we get hired at a job.

How do we get better at doing them.

And the answer there might be a little bit disappointing is of course practice practice practice nonstop

practice.

There's no magic pill that you can take.

There's no secret.

One time exercise that is going to turn you into a pro at Whiteford interview questions all you can

do is practice.

Let me tell you a little bit about why practice is so important for interview questions by showing you

two extremely common interview questions.

So we're going to look at two very calm questions and we're going to kind of break them down a little

bit.

And I think you're going to find this a little bit interesting.

So the first one that we're going to look at is the classic fizz buzz problem.

If you've never seen it before this buzz is an extremely common interview question that requires you

to print out all the numbers between 1 and 100.

If a printed number is divisible by three divisible by three excuse me you should print out the string

fizz and if the number is divisible by 5 then you should print out the string buzz and then there's

one other case on here as well not super important.

This is considered to be one of the easiest interview questions around but people still fail this question

all the time in interviews.

So why is that.

Is it that lots of people are just really bad at programming.

Well in my opinion the reason that so many people fail at a supposedly easy question is that it's not

really an easy question at all.

My personal belief is that this is a moderately difficult one that has a little trick to it but once

you see that trick once you know what that trick is the problem becomes amazingly simple and amazingly

straightforward.

So I don't think that this is an inherently easy question.

It's that as soon as you know the trick it becomes incredibly simple.

And that is repeated with so many interview questions so many programming candidates who get interviewed

are not sitting there in a boat like a programming genius an interview because they get every question

right.

It's because they have done enough questions on their own time.

They've done enough practice to know the little trick that is required to solve each question.

The more problems you practice and the more problems you solve the better off you will be at knowing

these little tricks as they come up.

So see one other great example of this.

This kind of phenomenon.

So here is another amazingly common interview question.

This is a question that I've been asked myself so many times in interviews and I have seen it asked

at companies I've worked at as well.

One company I worked on particular asked every single candidate this question.

So I've seen this question asked many times and I've seen it answered many times as well.

So this is a question about the Fibonacci series and this question.

You're supposed to print out a specific number from the Fibonacci series.

Now it's not really important to understand what the Fibonacci series is just yet.

I kind of want to have just or commentary about what's going on around this question.

In most interviews an interviewer will ask the candidate to solve this problem with a recursive solution.

So here's the recursive solution down here.

Now I'm going to level with you.

And be really honest here.

I have seen amazingly few candidates over the years who have sat down and come up with this recursive

solution on the fly.

Like in other words nobody is really being asked this question.

For the first time in an interview and giving this as a solution I'm 100 percent convinced of that.

Instead every last one of these candidates who ever get this question right has always practiced this

exact question in the past.

They memorize this very short solution right here and then.

Hey soon as you get answer ask this question.

Great here's this like three line solution right here.

So the more you practice these problems the more likely it is that you'll be asked a problem that you

have already seen.

Of course if you have been in their interview and came up with a solution on the fly you know if that

has happened to you in the past that's great.

You know I'm not saying that it's impossible and doesn't happen for people to figure this out on the

fly.

I'm just saying that the bulk of my experience.

Most people who solve this question have seen it before and most people who have not seen it usually

fail the question which is certainly not good.

OK so hopefully at this point it's clear why solving problems nonstop really is the best way to get

better at technical interviews.

So let's continue with the next video where we're going to start to discuss how problems in this course

are laid out.

So quick break and I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------
=============================================================================================================



Раздел 2:A Touch of Setup

5. Environment Setup

Now that we have a good sense of why it is so important to practice coding problems will well now to

continue by doing a little bit of environment setup in this section we'll be cleaning a get help repot

that contains all the exercises and problems that we'll be working on throughout this course.

So let's get to it.

I mean the first change on over to my browser and I'm going to navigate to get hub dot com slash Stephen

Greider slash algo casse and I'll paste the link right here just to make sure it's nice and legible

for you.

I also put this link in the last lecture as text so you can always go back there and copy the link as

well.

OK so once I'm at this page I need to find the green button on the right hand side that says clone or

download a click it and then you can either download this entire repo as a zip file or clone it with

get.

In my case I can go ahead and clone it with get by copying the link right here.

So I copy the link.

I'm going to change back over to my terminal and then I will clone the repository by writing get clone

and then that link next will change into that directory that was just created.

And that's pretty much it.

Now there is one little dependency that we have to install here.

We're going to first install the dependency in this section and then we'll talk about what it does in

the next video.

So still at my command line I'm going to run the command sudo NPM install Dashti just now really important

if you're on Windows you don't need sudo right here.

So if you are on Windows go back over to the very left hand side and you'll delete that sudo only if

you're on Windows.

Otherwise go ahead and run the command.

You'll be prompted for your system password.

You can go ahead and give it and then run the command.

All right so this is going to take a couple of minutes to install.

So let's wait for it to finish and continue in the next section.
---------------------------------------------------------------------------------------------------------------


6. Repo Test Setup
In the last section we installed a get repo that contain all the exercises and programs they'll be working

through inside this course and then we install the just command line tool with NPM.

Let's now take a look at the contents of this repo.

And we'll also discuss what that geste program is for.

So I'm going to start up my code editor inside this directory that we just cloned and we'll take a look

at some of the files and folders inside of it.

OK.

So inside of here you'll notice two folders right here.

You might notice one or two more folders.

After I have gone through income and recension records all the content of this course.

But what you and I are really concerned with right now is this exercises directory.

So we open up the exercises folder you'll see a number of some folders inside of that.

Now for you you're probably going to see many more folders inside of here for me as I'm recording this

course.

I decided to just keep a minimal number of folders inside of you at any given one time.

So it's easier for you to understand where I'm working inside of the directory structure inside of each

of these folders you'll find both the index start ups and a test dot js file.

So the idea behind these different folders is that each one represents a specific problem that we're

going to work on.

All the code that you and I are going to write to solve the problem will go into the index not just

file of each respective problem and then some code to test our solution has been already written for

us inside of the test.

JS file.

So if I could open up test not genius you'll see some number of tests inside of here.

So that just command line tool that we just installed is a test runner that we're going to use to evaluate

all these different tests for each of these different exercises.

Let's now flip back over to the command line tool and just kind of see how it works.

So back in my command line I'm going to change into the exercises directory and then I'm going to run

the just command.

So I'll simply run just like so now when we run just it's going to automatically attempt to execute

every last test inside of this repository for us.

So we'll see something that says like hey here's some number of tests that might have passed in some

number that might have failed.

Now we are not going to want to really run all the tests for all the exercises every single time.

Instead we're going to usually be running one set of tests.

In other words just a set of tests for one specific problem that we're working on in order to run one

batch of tests.

We're going to modify how we run that just command slightly.

So here's what we're going to do.

Let's imagine that we want to run the tests for this fib exercise right here to run just the test for

this fib exercise.

We'll run the command just fed slash test drive J us and then slash slash or seen dash dash watch.

Like so.

So in other words you will write out the test file for just the exercise that we're trying to run.

Now in general throughout the course as we are working on each and every different one of these exercises

I will be showing you how to write the command.

So you don't need to necessarily memorize this command right here or be sure to show you over time how

we are going to run it again and again and again just to give you a good reminder.

So we now run this command.

You'll see that we are running only with tests related to that fib problem.

So I see now just six Tests being passed ran six Tests executed because there are six tests inside of

this test file for the fifth exercise.

Now just some other quick things to understand.

Whenever you change any of the code inside the project structure these tests will automatically rerun

for us.

But if for some reason you want to rerun them manually you can press the Enter key on your keyboard

and that will rerun all these tests once you're done running all the tests for a particular exercise.

And you're ready to run to move on to the next one.

You can always Press Control C on your keyboard and that will stop the test runner.

So if I press control C that will stop the test runner like so and then of course I can always start

them back up and then exit out again by pressing Control-C again.

OK.

So that's pretty much it.

This is our testing setup we're going to be using it throughout the course for each of the different

problems so we end up working on.

So the good thing about this test setup is that if you ever decide you want to deviate from the course

and just solve all these problems on your own or maybe come back later on and practice the problems

on your own then hey fantastic you've got a bunch of tests here to make sure you're doing the correct

work.

So now that we have our development setup all put together let's continue on the next section and get

started on our first practice problem.
--------------------------------------------------------------------------------------------------------
========================================================================================================




Раздел 3:String Reversal

8. First Question! Reverse String.
Now that we've set up our repo and we have a better idea how to run tests.

Let's get started with our first problem.

So the first question that we're going to tackle here is the one marked as reverse string is going to

open up that folder and then open up the index G-S file inside of it.

Now before we talk about this question too much I want to start up my tests for this particular question.

So back in my terminal I'm going to make sure that I'm inside of my exercises directory if I list out

all my files and folders inside of here I should see the reverse string problem listed.

Now to start my tests or run just reverse string slash test G-S then dash dash watch like so so a run

this and that will start up our tests and the first time they run I should see two test failing and

at least one test is passing which is great.

So you're going to work out this question and then as you start to solve it or whenever you think you

have a solution come back over to your terminal and make sure that all three tests are passing.

This is a nice kind of mild.

First question to start off with.

So hopefully we'll get kind of a knack around the pattern of writing a little code and then coming back

and checking out the tests.

All right now let's check out the question itself.

So inside of my reverse string index dot G-S file you'll see the directions list at the top.

Now essentially all we really want to do here is take a string that is provided as an argument as TR

short for string.

Reverse it and then return it from the function.

And the last part is really important.

Don't forget to return the string that gets reversed.

Very important.

So inside of this function body right here you're going to write in your solution.

Save the file and then whenever the file is saved you should see your tests rerun and repeat until you

see these things pass.

Now in this particular case I'm going to very purposely not give you a lot of direction on this question.

I want you to kind of dive in head first into this particular question but on future questions we will

talk a lot about pre-amble and different possibilities to solve it and all that kind of good stuff.

So just on the first one I want to just dive in headfirst.

Give it your best try.

One thing keep in mind is that if you ever start to get frustrated on the question please please please

just stop working on it and watch the solution especially when you're first getting started with practicing

interview questions.

It's really really important to make sure that you don't end up getting to know a little bit frustrated

when you're first getting started.

It's all about just seeing a lot of questions very quickly so you can start to get a handle on the types

of questions that you'll be asked.

So again if you are spending a lot of time on this question or any other one we work on just take a

break watch this solution and then give it another shot and I'll remind you this several times as we

go through the course.

OK.

So I'll leave this up to you.

Or catching the next section and we'll go and walk over the solution.
------------------------------------------------------------------------------------------------------------------

9. String Reversal, Solution #1
OK hopefully you had some success with this problem in this section we're going to walk through one

possible solution.

Now the first solution that we're gonna start off with is by far the easiest one.

However it's also not necessarily the most obvious one.

So this one requires a little bit of trivia knowledge of javascript in general.

So rather than going and writing out the solution right away I want to show you a little bit of documentation.

And as soon as you see this documentation you might have an auto type moment.

So let's take a look.

So inside my browser I'm going to open up the documentation for a re prototype reverse reverse is a

built in function that is included with all versions of javascript.

I should say most recent versions the reverse function right here will reverse all of the elements within

a given array and you can very easily see with the documentation right here.

We have one two three.

The reverse method is called on it and then a contains three to one instead.

Now this is very important to note here.

A method that belongs to all arrays.

But we were passed a string.

So in order to use this very easy very simple straightforward solution right here we need to make sure

that we are working with an array not a string.

Fortunately we can use a little method to convert our string into an array called the reverse method

on it and then turn it back into a string.

So if we put this into a kind of flow diagram Here's what we get.

So we're going to take in that SDR short for string arguments we're going to turn it into an array we'll

call reverse on it will join that array back into a string and then return the result.

So let's give this a shot.

Back inside my code editor I'm going to take this as TR short for String argument and we'll turn it

into an array.

So I'll say Konst A R R I like to abbreviate array as simply a r r.

By the way I will call string dot split and pass in an empty string.

So when we call split and pass in an empty string it takes the provided string and turns it into an

array with every element in that array consisting of a different character from the string.

So right here with a r r we're now working with a ray of characters we can call a r r dot reverse that

will flip or reverse all the elements within the array.

And then finally we can join it all back together again by calling a r r join in passing in an empty

string as well.

So this will join all those elements back into a string and then finally we'll make sure we return the

result.

So I can put my return keyword in here.

So let's save this.

Check our test and see how we're doing so save the file.

I'll check on my terminal.

It looks like all of our tests are successfully passing.

Cool.

So like I said this was a solution that kind of relied on a little bit of trivia.

Now it's entirely possible that you took a different solution.

So we're still going to cover two other possible solutions one that uses a for loop and another that

uses an array helper.

I do really recommend you check out these other two solutions that we're going to take a look at because

both them you might be required to give one of these other solutions your interviewer might say hey

don't cheat and use that reverse helper.

So we will look at two other solutions that take care of this process manually before we go however

I want to point out that we can do a little bit of code cleanup to make this function a little bit more

concise than it is.

Notice how right now we split our string into an array and assign it to this variable.

We then call reverse on it and then we join it back together.

So in fact we don't really need to make use of this temporary variable right here.

We could simply call reverse on the result of this expression and then call join on the results of that.

So let's look at that alternate solution that's just going to kind of clean up our code here a little

bit.

So I'm going to delete everything and I will return as TR dot split.

So that's going to give us our character or our array of characters we'll call reverse on that which

will reverse all the elements within that array and then we will join it all back together like so now

when I save the file.

I have a built in little code formatter so you'll notice that my formatter automatically splits it out

to a couple of lines here but it's all 100 percent equivalent to the code we just were looking at a

second ago.

So I'll save this file and if I go back over to my terminal again it looks like the tests are still

passing great.

So this is one possible solution.

Let's pause right now.

Continue in the next section and look at another possible solution.
-----------------------------------------------------------------------------------------------------------

10. String Reversal, Solution #2
In the last section we put together one very straightforward solution for reversing a string.

Now it's entirely possible that your interviewer might say hey don't use the reverse helper because

obviously if you know this thing exists it really makes the question quite easy and quite straightforward.

So in this section we're going to look at an alternative solution that's a little bit more manual work.

OK.

Now just to keep a record of all of my solutions as we go through I am going to copy this down to the

bottom of the file and comment out our first solution just to keep a record of all the different solutions

we come up with.

And I'm going to delete the contents of the reverse function.

OK.

So let's talk about the second solution.

The second solution is going to make use of a for loop.

So we're going to create an empty string and we'll call that thing maybe reversed.

I think that's a reasonable name for it then we're going to iterate through the string that was provided

and for each character in that string will take that character and add it to the start of the reversed

string.

After we iterate through the entire string we'll then return the variable reversed.

So essentially we're going to make an empty string.

We're going to take each character out of the original string and stick it into the new one.

One at a time.

And because we are adding the new characters because we're adding each character to the start of reversed

the reversed variable contain the reversed string.

So let's see what this solution looks like.

All right.

So back at our code editor We'll start off by declaring a temporary variable that we'll call reversed

and also sign it an empty string.

So this is the string that we're going to kind of assemble over time as we iterate through the string

variable right here.

OK so now we need a for loop.

One thing I want to mention about for loops in general and I'm going to tell you this many times throughout

this course wherever possible I really recommend you avoid writing for loops in the kind of very classic

syntax.

In other words the for loop syntax that looks like var i equal to zero.

I less than string length.

Plus plus.

So I really recommend you try to avoid for loops like this right here.

And the reason for that is that there are so many tiny little spots inside of here that you can very

easily make a mistake or make a typo for example maybe you accidentally flip the less then sign right

here.

Maybe you actually accidentally flip it the other way maybe rather than looking at string length maybe

you accidentally looked at reversed length maybe instead of semi colons you put in commas instead which

is honest to God something that I accidentally did on an interview one time.

So whenever you use you use this long form for loop you're just introducing many different locations

where you can accidentally make a little typo.

So for us throughout this course where ever possible we're not going to use this classic for loop.

Instead we're going to use a new syntax for four loops that was introduced with as 2015 called the four

of syntax.

So let's write the code for it and see what it looks like.

I'll say for lead character of S.

TR So that's the string that we got passed in as an argument.

Then in the body of the loop we'll say reversed equals character plus reversed.

Then at the bottom we will return reversed.

OK so let's talk about what's going on here.

So again this is a new syntax for for loops we say for a variable declaration.

So I'm creating a temporary variable that is redeclare.

Every single time through this loop of character than we say of.

And then the iterable object that we want to iterate through.

So in this case we are iterating through all of the characters of the string variable right here.

So we're going to iterate through each character of string one by one and set each character equal to

this temporary variable character.

We then take that character added on to the start of the string reversed and then after the entire four

loop we return the string reversed.

So again in general I really recommend you make use of this new and improved loops syntax rather than

attempting to write out the full for loop by herself.

Now there are several questions out there and I should say actually many questions out there where you

can use this syntax because maybe rather than iterating through every single element inside of a string

or an array or something maybe you want to iterate through every third element or iterate through every

fifth and there are Interview questions that require that type of logic.

And so if you are confronted with needing to loop through every so many elements within the array Well

then you do have to go back to using a for loop or even a while loop for that matter.

However as much as possible I do encourage you to try this new and improved syntax.

OK let's save this and see how we're doing a flip back over to our terminal and it looks like we're

still passing here as well.

So this has been a second solution.

This one's a little bit more manual and something that I would probably expect to be asked in a interview

question.

You know I would really kind of expect that any competent interviewer might say oh yeah don't use reverse.

That's just too easy.

All right.

So this one is a little bit more complicated.

Let's continue in the next section and we're going to look at one more possible solution.

So quick break and I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------

11. String Reversal, Solution #3
We have now put together two possible solutions to the string reversal problem.

Now I do want to look at one third solution you might be sitting there thinking Stephen do we really

need a third solution.

You know aren't the two we have good enough.

Well to be honest throughout this course I want to usually show you multiple solutions to the same problem

because inevitably first some people one type of solution is going to stick.

And another one will not.

In addition as we look at these solutions I'm going to usually be showing you some of the more complicated

ways of solving a problem.

Now sometimes you do want to use a slightly more complicated way just because it might show your interviewer

that you kind of know what you're talking about.

So this last solution is going to use a very complicated little array helper but it's also going to

make it very evident to your interviewer that you really know how to reverse a string.

So let's give this last solution a shot.

I'm going to start off by copying the second solution down to the bottom the file and commenting it

out and then I'll delete the function body for our solution right here.

So here's what we're going to do.

We're going to take our string.

We're going to turn it into an array by calling the Split function on it.

And then we're going to use the reduce helper.

So the reduce helper is a method helper that was included with.

Yes 5.1.

We'll take a look at how it's used in just a second.

So first turn this thing into an array by calling string split with an empty string like so and it will

set up the reduce helper function.

Reduce is used to take all the different values with an array and condense them all down to one singular

value which is essentially exactly what we're trying to do here.

We want to take all the values within this array that we just created and condensed them down to a single

string value.

Reduce takes two separate arguments.

The first one is going to be an arrow function that'll set up like so and then the second argument is

going to be a starting initial value for our function which I'm going to pass in an empty string like

so.

Now whenever reduce runs it's going to take this starting argument.

It's going to pass it into this arrow function has the first argument and then whatever gets returned

from that inner function will be then used as the starting argument for every successive run of the

function.

In total the function runs one time for every element within the array right here.

So in other words we can really picture that this first value for the first argument that has passed

introduce is are reversed string.

So I will receive it as an argument named reversed.

Then the second argument is the element or the character that we are currently operating on out of our

array.

And I'll receive that as an argument called character then the logic inside this function ends up being

the exact same thing that it was with our FOR loop solution.

So we're going to take our character that we're operating on right now.

We will add it to the total reverse string or the string that represents the reversed string that we

were past and then return the result.

So I will say return character plus reversed like so.

So this reduced call will yield a string that has the reversed form of the string that was passed down.

So the last thing we have to do is make sure that we return the results.

It's going to get my return key word in there like so.

All right.

So let's look at our tests.

Looks like everything is still passing.

Fantastic.

So this is definitely a solution that would work.

The last thing that would probably do here is to kind of simplify some of the syntax a little bit by

using some knowledge of iOS 6.

Again this is little improvement that is not necessary but something that might kind of impress your

interviewer just to show that yes you are familiar with.

Yes 2015 and understand the differences in syntax.

So one way that I could condense this function call write your down a little bit is to remove both the

return statement and the curly braces.

So I would remove the return statement.

I would remove the curly braces there's the other curly brace and then I also don't need the semi colon

here anymore.

Finally having the full word reversed in character is you know a little bit long here.

So I might choose to replace these variable names with simply Rev and char like so.

That's 100 percent you know up to you style preference but it's something that I think still conveys

their meaning but really condenses down the line.

All right.

So looking at this as a one line solution it's still not quite as brief as the reverse function call

with that first solution we did.

But I think it's certainly a little bit more condensed down than the second solution where we use the

for loop.

So again any three of these solutions works A-okay 100 percent just fine.

And of course there are other solutions out there that we didn't even cover many different ways to solve

this problem.

However if I want to really wow my interviewer or at least make them think that I understood some advanced

array helpers like say The reduce helper then this is likely a solution I would go with right here.

OK.

So this is our first problem.

We've gone through hopefully three different solutions.

Wasn't too tiring.

Like I said in general I want to show you multiple solutions just so you see different ways of solving

a problem.

So hopefully this first problem went along.

OK let's continue in the next section and start working on our next question.
---------------------------------------------------------------------------------------------------------------

12. Debugger Statements
We've now looked at three possible solutions to the reverse string function.

Now as you were working on your own solution here you might have noticed that it was kind of hard to

debug your work.

In other words the function that you put together you might have noticed that it's kind of tough to

figure out whether or not you're doing the right thing until all the tests are passing over here and

these tests aren't the most effective thing for helping you arrive at the solution or develop a solution.

They're really more about making sure you did the right thing.

So in the section I want to give you a quick little tool that you can use to very easily debug your

work and this tool.

I'm going to show you can be used not only on this reverse string function you can use it anywhere inside

the course so the tool that we're going to use is a regular debugger statement.

If you've never used debuggers before that's totally fine.

We'll take a look at exactly how they're put together.

So let's imagine for a second that maybe we want to pause execution of our code inside this function

so that we can inspect some variable inside of here to do so we can place a debugger statement like

so.

So now any time the javascript interpreter executes this line of code it will pause in execution and

we can take that opportunity to inspect some of the different variables that are floating around our

program.

This makes it extremely useful for debugging or essentially developing our solution to make sure that

we can actually catch this debugger right here whenever we place a debugger statement like this.

We do have to manually call the function.

So right now we are defining the function and then to merely export it.

If you want to use a debugger make sure that you call the function.

So I'll call it right after afterwards right after we define it.

I mean I'll call it with a string of SDF.

So now if we run this function in debugger mode or if we run this file we will pause an execution right

here and then we can inspect a couple different variables and just kind of see what's going on.

So let's figure out exactly how that works.

I'm going to flip on over to my terminal.

I'm going to kill my test by pressing Control-C and then going to change into my reverse string directory.

Reverse string and then I'm going to execute that file that function that we were just working on in

debugger mode and I can do that by writing Noad inspect index G-S like so now when I do so you're going

to see some information pop up.

It says that we have a debugger listening and it's attached to our running process.

You'll then see some little snippet of code right here and then we get kind of a prompt right.

You're asking us what we want to do.

So we just launched that file in debugger mode the instant it started up inside of our console right

here.

It paused in execution on the very first line of our file.

So right now nothing is running.

It's just saying hey I'm ready to start to inspect your code to tell this inspector to continue executing

our code.

We can write Khant short or continue or you can write just simply see and then hit enter.

So now the debugger started to or I should say the interpreter executed our file line by line until

it found a debugger statement.

Once it got to the debugger statement it paused in execution and it's now saying hey if you want to

you you can inspect some of the variables that are floating around inside this function.

Now let's imagine that we wanted to look at the argument right here of SDR or string.

You can't you cannot just put in TR right here to actually inspect a variable.

We have to enter a REPL mode REPL being short for read at it something something.

Whatever it is.

So will run the command Ruppel that'll kick us into an actual javascript console right here where we

can start to inspect variables that exist inside of our codebase.

So I could look at the variable string and it returns to me.

Ok here is what you're what that the value of that variable is.

And then if I wanted to I could always start to say copy over some code like I'll copy this expression

right here.

I can paste it right here.

And I see.

OK.

Looks like that did in fact reverse the string properly so you can use this entire REPL and debug all

D.C.M. debugger thing to very easily audit your code base and just kind of develop it on the fly and

get a sense of exactly how the data inside of your function is working.

So this is a tool that I highly recommend you give a shot with on some future solutions.

You know definitely give us a shot.

Obviously you can't always do this in an interview setting but as you're practicing these problems this

is extremely useful to use.

Just to give you a slightly better example of why this would be useful.

Let's look at a slightly different implementation of this.

So by the way to exit the REPL I can that's not the REPL I can hit Control C that kicks me back to debug

mode and then to you execution of my file I can hit C and enter again.

And in this case there was no other debugger statement inside my code base.

So it just quit.

And I can hit Control C again to completely exit the debugger.

So to get a better example of this I'm going to remove the debugger statement we had placed.

I'm going to take this last implementation of reverse that we had put together.

I'm going to cut it.

I'm going to move it to the bottom of the file and comments it out.

And I want to take that earlier solution we had put together with a for loop.

So I'm going to uncomment this thing.

I'm going to cut it and then I'll paste it above the reverse function call like so.

And then let's say that maybe something appears to be going wrong inside of our For loop right here.

So maybe after we start to concatenate the string together let's put a debugger statement right here

and this will allow us to inspect all the different variables inside the for loop and figure out exactly

what's going on there.

So again I can go over to my Turnell.

All right.

Node inspect index.

Yes.

Again I get kicked into debug mode.

We are poznań execution on the first line of the file all run.

See to continue execution of our code until we get to the debugger statement.

So here's the debugger statement and now I can enter the REPL and start to inspect some of the variables.

At this point in time.

So possible variables that I might want to look at would be a B character string or reversed.

You know anything in here.

So we could look at reversed.

OK there's what Reversed is when to look at character.

What character is and string like so.

Now notice how this is a for loop.

So the body of the for loop will be executed many times in a row.

So if I want to I could press control Control-C to leave the REPL.

I can continue execution again.

And now I just got paused again at the second iteration through the for loop and if I hit C again there's

the third time.

And then the fourth time.

So I can enter Ruppel again.

I can look at the reverse string.

And now it's the entire reverse string.

And of course I can look at characters well and now it's the last character that we were iterating over

which in this case is at so do be aware that if you place a debugger statement somewhere inside of a

for loop or a foreach or a map statement or whatever it will be called multiple times and you'll have

to use that C command to skip through it multiple times.

OK so I think that you've got a reasonable idea of the debugger here.

Again you can use it throughout the course on any problem we are working on.

To get a better idea of how your code is working I'll show you a diagram in just a second to remind

you of some of the steps you need to go through to set up the debugger.

Just keep in mind that when you are all done with the debugger you will want to remove the debugger

statement and then also remove the manual function call.

Down here we have to add that manual function call.

The one that we just had a second ago because if we don't call the function manually then when we start

to inspect this file there's nothing that actually invokes the reverse function inside of here.

So if we just if we ran the debugger on this file as is nothing actually invokes the reverse function.

So even if we had a debugger inside of here it would never get caught because we're never executing

the function.

So that's why we add it added in the manual function call right here.

OK.

So like I said one last thing I wish to you is the diagram of the steps to use to get the debugger to

show up if you want to you could take a screenshot of this right here.

Also remember that all the diagrams in this course are available inside of the Get hub repository.

So you could always go in take a screenshot or just manually download this diagram just to have the

steps of how to do this thing up for yourself.

All right.

So I'm glad that we now have some method to effectively debug our code.

We will use this method inside these videos several times throughout the rest of the course but again

feel free to use this debugger method as you are developing solutions throughout any problem.

You can use this on any problem you look at.

And I really encourage you to do so because it will give you a much better understanding of what's going

on behind the scenes.

All right.

So I think that's enough of that.

Let's take a break and continue with our next problem in the next section.
--------------------------------------------------------------------------------------------------------
=========================================================================================================





Раздел 4:Palindromes

13. Palindromes
Now that we know a couple of different ways of reversing a string we're going to immediately start to

look at another problem that requires you to reverse a string.

So inside of my exercises directory I'm going to find the question marked palindrome.

So here it is right here.

I'll open up the index dot J.S. file and then will also make sure that we immediately start up our tests

for this exercise as well.

So I'll flip back over to my terminal.

I'll end my running test runner by pressing control C and I'll start my test back up for that new exercise

by running just palindrome slash test J us slash dash dash excuse me watch like so.

So that will start up our tests and it looks like we have five passing and three failed right now.

Cool.

So let's look at the directions for this problem.

Back inside my code editor you'll find the directions listed at the top so the idea behind a palindrome

is that we should be able to reverse a string if the reverse string is equal to the original one then

that word is a palindrome.

Otherwise it is not.

So for example if we take the string A B B A and reverse it we end up with a string a BVA.

This is the reversed form of APBA the two strings right here are identical.

And so we would return true from our function to indicate that yes this is a palindrome.

However for the string ABC TFG if we reverse that we end up with G F E D CBA.

This is not equal to the original string.

And so we would say that this is not a palindrome.

One important thing to really keep in mind here is that you are not being asked to return a reverse

string you are asked to be.

You're being asked to return true or false to indicate whether or not this is a palindrome.

So you really want to make sure that after all your logic inside of your you ultimately end up returning

a boolean value something that says true yes this is a palindrome or false.

It is not.

So I'm going to leave you to put the solution together here.

Obviously there is an element of string reversal here.

So you'll probably want to remember how to reverse a string.

And then you'll probably want to think of some way to take that reverse string and compare it with the

original one.

So I'll leave it up to you on how to approach this.

Remember I can't say it enough.

If you get frustrated don't sweat it.

Just go to the solutions.

Take a glance and then give it another shot.

Don't get frustrated here right at the beginning.

If you get frustrated now it just means that you might end up getting too frustrated and end up quitting

and all we really care about at this point is seeing enough problems to get a really good sense of what

you will be frequently asked inside of an interview.

So give this a shot and I'll see you in the next section and we'll take a look at some solutions.
-------------------------------------------------------------------------------------------------------------

14. Palindromes, Solution #1
OK hopefully you had some success in checking to see if you're working with a palindrome here if you

were not able to get the test to pass.

One thing I want to remind you about right now is to recall that you're supposed to return a true or

false value from this function.

That's what the tests are looking for.

The tests want to see a truth or falsity value being returned.

All right.

So let's give this thing a shot with our first solution.

Now the first solution we're going to look at is the easiest or I should say kind of like the most direct

solution or the most compact one.

When I say easiest I don't necessarily mean the most obvious solution or the solution that you should

have gotten.

I really just mean to say this is probably the most direct solution.

So let's give this a shot.

The first thing to recognize is that we want to somehow reverse the string that is provided to us.

So we just learned how to reverse strings in three separate fashions.

So the first thing I'm going to do here is to reverse the string that is passed to us.

So I will say Konst reversed is string dot split.

That gives me an array that I will reverse.

And then I will join it back together.

And so in one line right here I now have the reversed string available to me.

Now remember if a string is a palindrome the reversed form should be equal to the original form.

And so there's not a lot of additional logic I need here.

I can just do a direct comparison between reversed in string and return the result to that if the two

are equal.

Fantastic.

They must be a palindrome.

Otherwise if they are not equal then it must not be a palindrome so right underneath.

I can simply say return String equal equal equal reversed.

So this is a Boolean statement right here.

Or I should say it produces a boolean value if string is equal to the value of reversed then we will

return true.

Otherwise if they are not equal to each other than we will return false.

So like I said this is the most straightforward solution.

Not necessarily the easiest one to come up with just the most straightforward one.

So I will save this file.

Let's check our tests and see how we're doing.

And so it looks like that solved it.

Not bad.

OK.

So if you didn't come with that solution of course don't sweat it might me personally.

When I first sit down to look at these I usually come up with a very round about solution one that's

not always the best.

So there's many different ways of solving this problem.

Many many different ways.

If you came up with another solution that is totally fine.

Let's take a quick break right now.

In the next section we're going to look at a second way of solving this problem.

So quick break and we'll take a look at that second solution in the next section.
-------------------------------------------------------------------------------------------------------


15. Palindromes, Alternate Solution
Let's take a look at another way of solving the palindrome problem.

Now remember there is no ONE way of solving all these problems.

So if you came with a solution that is different from my own totally fine for this alternative solution

we are not going to manually reverse any string at all.

Instead for this solution we're going to make use of another array helper just like the reduce helper

that we use just a moment ago.

So let's take a look at some documentation in this solution.

We're going to make use of the every array helper.

So we'll take our string will turn into an array and then we will use this every helper on it.

Now I'm at the Indiana documentation for every and if you want.

You can come here yourself and take a look at some of the documentation but I'll give you a quick description

of how every works right now the every function is used to do a boolean check on every element within

an array.

So for example if we had an array containing the values 0 10 and 14 and we wanted to ask the question

if every single value in there was greater than 5 we could write some code that looks like this right

here.

We would take the array we'd call the every function on it and then we would pass in a function to invoke

for every element within the array.

So the first time that this function was executed we would pass in the first element as Val.

We would check to see if 0 was greater than 5.

In this case zero is not greater than 5.

So we would return false from this statement right here when the every function runs it checks to see

the return value of every function run if every function or if any function I should say of any function

returns false then the over all expression will return false as well.

However if the inner function comparison right here returns true for every element then the entire function

expression will return true.

So every as very aptly named It's essentially executing a check or some type of comparison for every

element within the array.

So I bet you might be able to have some idea of how we can use this to check to see if we are working

in a palindrome.

Here's what we're going to do.

Let's imagine this is the array of characters that we're working with.

We're going to take the first element of the array which is a.

And we'll compare it with the element at the very end.

If that if the two are equal then we will return TRUE and say OK looks good so far this is a palindrome.

Then for the next element we'll take it and compare it to the second to last value.

We'll compare the two and say are the same.

OK.

And then we will repeat the process throughout the array.

So for C we will essentially compare C to itself because it's at the very center we'll then compare

B to the previous B and we'll compare the last element to the first one.

Now one thing that you might immediately lock on here is to notice that we are doing more comparisons

that are necessary.

And that is absolutely true.

Once we have checked every element up to that very center right here we don't really have to check all

the remaining elements because we already checked to see if a.

Or the first stone was equal to the last one.

So we technically don't have to iterate through the rest of the array and compare them back to the first

elements inside of here.

And so I'm going to say that this is not an ideal solution for this problem just because we are doing

essentially twice as much work as we really have to do.

However there is a reason I am showing you this solution and I'm showing the solution just so you can

explain to your interviewer what I just explained to you when you are working with an interviewer and

answering their questions.

In many cases they'll see you.

Hey like I think that your problem or your solution has a problem.

Here's what it is.

What are you going to do about it.

And so many times you need to be able to respond identify and somehow solve these issues that come up

with your own solutions.

The issue here of double comparison so comparing the first to the last and again the last two the first

is a really easy thing to bring up an interview and it's a really easy way to look good to your interviewer.

You can propose this solution with every helper and then say you know what I think this is a clear solution.

However it's comparer is comparing or it's doing about twice as much as it needs to do.

And so maybe you could then suggest some alternative solution.

So when you are in an interview setting Remember you don't have to be line.

The best solution right away if you can think of multiple solutions to a problem.

I highly recommend you give multiple solutions.

It just shows your interviewer that you are aware of multiple ways of solving a problem and also makes

them aware that you can compare and contrast between different ways of solving a problem.

So as I've said many times so far and I will say several times again throughout the course many ways

to solve a problem.

And it's really in your interest to be aware of all the different ways of doing it.

OK.

So with that in mind let's put this to the test.

So back inside my index file I'm going to make a backup of our initial solution and then I will delete

the function body here and we'll put together a solution with the every function.

So the first thing we have to do is turn our string into an array.

Remember strings do not have access to that.

Every helper.

It's only arrays.

So the call string got split.

Passing the empty string and then call every now the first element or first argument to every function.

Excuse me is a function that will be called for every element in the array we will receive the first

argument to this function which is each character from the array as an argument that we will call char

or short for character.

And then the other thing to keep in mind here is that because we want to compare each element to it's

essentially mere On the other side we also need to figure out some way of getting access to the element.

On the other side of the array.

So fortunately as a second argument to this function right here we are given the index of the element

that we are currently iterating over which the record is high.

So the first time this inner function is called I will be equal to zero because we are operating on

the first element in the array so now inside if you're inside the function we can return a comparison

between the current element and the mirrored element.

On the other side of the array now getting access to the other side is a little bit complicated but

it's really not that bad.

So the first time we run our function we are at index 0 right here.

So I would be equal to zero to get access to the element on the opposite side.

We could look at the entire string array and access the element at the length of the array minus one.

So remember all arrays and Javascript are zero indexed.

So right here we would start off as 0 1 2 3 4.

So over here would be four.

There are five elements in the array so we can't say.

Look at the element.

At length we have to say look at the element at array length minus 1 to give us 4.

So in other words long story short all we really do here is look at the string at string length.

Linus I so that we'll make sure we increment for every step through the loop or through the every function

minus one and the minus one right here is to make sure that we are taking into account the fact that

length is the overall length.

But we are zero indexed with javascript arrays cook.

So it's looking good.

Now last thing we have to do and this is a real gotcha.

Never forget it.

We need to make sure we return the result of the every function call.

So I will put my return statement in here.

I also forgot to comment out the palindrome function down here I'll make sure I do that.

And I think we're ready to test this.

So I'm going to save the file.

We'll check our terminal and it looks like all of our tests are still passing great.

So again this is not an ideal solution right here but it definitely gives you a little bit of you know

ammunition to work with with your interview or it gives you something to talk about and say here's a

solution.

It makes use of an advanced array helper which shows you know what you're talking about but it's also

not the best way of solving it which gives you something to talk about and you can then propose this

other solution down here.

So this has been a pretty good solution.

Let's continue the next section and look at our next problem.
-----------------------------------------------------------------------------------------------------------
===========================================================================================================




Раздел 5:Integer Reversal

16. Reversing an Int
Time to move on to our next problem I'm going to find the reverse in a folder inside my project you

know open up the folder and open up the index js file.

Now before we forget We'll also start the new test file for this project as well.

So back at my terminal I'll stop the running test runner by pressing control C and they'll start up

the new set of tests by running just reverse it.

Slash test dot J.S. dash dash watch like so look at.

So you should see about four tests or so running.

All right.

So back over to our code editor let's look at the description for this problem.

Now before we talk about the problem itself I want to say that this is going to be another very similar

reversing type problem but this one has a couple of extra challenges stacked on top of it.

This problem right here is a fantastic example of how understanding and really succeeding at interview

questions is all about practice and practicing more and different types of questions.

Cause at first glance this is kind of a tricky problem.

However if you understand the one or two little tricks behind it and there are distinct little tricks

here if you understand the tricks then this turns into an extraordinarily straightforward question.

So there is a very straightforward solution to this but it's all about understanding that little trick.

So if you want to get this problem a try on your own then go ahead and pause a video right now.

Read the directions and take a look at the examples and give it a shot.

Otherwise stick around.

We're going to look at the problem.

We're going to talk about some of the little tricks that you should understand to really effectively

solve this.

And personally I recommend you stick around and listen to these tricks.

Otherwise this problem is just kind of a nightmare to deal with.

All right.

So first let's look at the directions and the examples.

Again we are reversing some type of data entry here.

In this case it is an integer.

So if I pass an integer or 15 I should see the numbers in there get reversed.

2:51 981 would go to 1 8 9.

If the number ends with zeroes then when we flip it those zeros should disappear.

So 500 should not be 0 0 5.

It should be just 5 and the other interesting thing is handling negative numbers as well.

So negative 15 should become negative 51.

And if we kind of take this issue with the zeros together with the negatives negative 90 should turn

into simply negative nine.

Now what they want to make sure is really clear here even though we're in a section on this course where

I said we're all talking about strings and whatnot both the input and the output should be numbers.

So if we wanted to kind of apply the same kind of string reversal stuff that we've been doing that's

fine but the end result of what we're doing should produce a number not a string.

So make sure that's really clear.

OK.

So let's now talk about some of the little gotchas here are some of the things that make this problem

really easy.

So first off you and I know at this point how to reverse a string.

Very well.

We've seen two problems already.

Each of them with multiple solutions on how to reverse a string.

However we've been talking about reversing strings not numbers.

We can turn a number into a string.

However by using a function called to string.

So let's take a look at my little code editor here and I'll practice this out really quick.

Now on the left hand side going to write some code and we'll see the results of that code up here on

the right hand side.

So this is a quick example let me show you maybe Konst my number equals 200 if I want to turn this number

this integer right you're into a string.

I can call line number dot to string and returns a string 200.

So at that point I can then use familiar functions like say split and turn it into an array of strings.

I can join it back together to form another string and so on.

So by using this two string function right here we can turn our number into a string and then work on

it as though it was a string and take care of it.

With all the usual reversal techniques we've looked at so far.

So it's kind of a trick number one trick.

Number two I want you to be aware of is a little function built into the math library that is included

with Javascript.

So I've got the documentation for it in a new tab right here.

I'm out the Mozilla Developer Network.

Looking at the documentation for math dot sign.

So I'm not going to tell you exactly where to use this in this problem but it's going to punt this function

out with this math sine function.

We can pass in a number if that number number is positive mouth sign will return 1.

Otherwise if the number that we pass in is negative then it will return negative 1.

So for example math got sign of 5 or 4000 or turn 1 mapped out sign of negative 4000 returns negative

1.

So I just want you to be aware of this little helper function because I think that it might be really

helpful in solving the issue with maintaining this sign here on the actual number.

Now the last thing I want to tell you about the last little trick.

Remember how we were just talking about.

Well you can turn a number into a string by using a string.

So let's say we have 400 again just to make sure it's really clear once we called to string on this

thing if we then split it into an array and join it back together.

We're still dealing with a number.

I mean we're still dealing with a string in order to turn all this stuff back into an actual number

which is exactly what we're really trying to do here.

You can use the parse int function so parse it like so.

So parsing it takes a string and it returns a number or at least what it thinks is a number inside that

string.

And then once it's been turned back into a number we can then add an add something to it like you know

add 2000 or divide by 2000 or whatever we want to do.

So clearly after calling parce and we are now dealing with a number here.

OK so that's the three little tricks part sent to string and math sign between those.

I think that you've got the tools to kind of take the reversing of string technique that we've been

looking at and apply it to this new problem that we are working on.

So at this point I encourage you to pause the video take a shot at the solution and we will go over

the solution in the next section so I'll see you in just a minute.
----------------------------------------------------------------------------------------------------------


17. Reversing an Int Solution
All right hopefully you had some success with this problem in this section we're going to walk through

the solution now for this particular problem.

We're only going to go through one solution.

There are certainly multiple solutions to this.

When you consider the fact that actually reversing the set of numbers here can be done many different

ways.

However we already spoke about some of the different ways to reverse strings.

In one of the last problems we worked on.

So this time around we're just going to kind of B-line a very direct way of reversing the actual number

and we'll focus a lot more on how we kind of work with the number in general and how we maintain that

negative sign on there.

So let's give this a shot inside my function body.

The first thing I really want to do is give myself the ability to reverse the number.

That's why I really care about here.

I want to reverse the number.

So in order to reverse the number we're going to use the same methodology that we use in that previous

section.

We're going to take the number.

We're going to somehow treat it as a string.

We'll split that number into an array.

We'll use the reverse method on it and then we'll join it back together.

So let's at least do that much and see what happens.

So I'm going to take n that's the number that gets provided to us and I want to first turn this number

into a string.

So I'm going to call and dot to straight.

So now we're working with a string as opposed to a number.

And at this point we can now use all that split reverse enjoying methodology that we saw in the previous

problem.

So I can call split to turn this into an array.

I can reverse it because it is an array.

And then I can join it back together into a string like so.

Now at this point let's just kind of make sure we get our return statement in here and I want to run

our tests and see how far this gets us I want to see what this is really going to do for us.

So back in my command line I can run my test again by pressing the enter key and it looks like ha.

Interesting.

So here is one of the tests right here.

Rather than producing the expected negative 5 negative 5 Our code is currently producing 5 minus as

a string.

Notice the set of quotes right there.

So looks like we've got two big issues on the one hand.

We're not properly dealing with the negative sign.

And on the other hand we're still returning a string here as opposed to the number that we are expected

to return.

So let's take a look at this and see what we can do.

Well in order to make sure that we return a number out of this thing we can use the parse and function.

So rather than immediately returning the result of this reversal I'm going to assign this to a variable

they'll call reversed

and then right underneath Let's return parse.

Int of reversed like so.

So now we're trying to actually pull an integer out of this string that we just produced.

I'll say this.

And let's see what happens now.

So now if we look at our test again it looks like we're passing more tests than we were before.

We still have this one test down here failing specifically around handling a negative number.

So at this point we are expected to return negative 5 on this.

But our code has produced five.

So it appears that even though we were able to somehow pull an integer out of that reversal we did not

actually maintain the sign.

So we're not including the negative side and we somehow lost the negative sign during the parse and

process.

So now all we really have to do is figure out whether or not we should get this number to be negative

or positive.

Deciding that really comes down to that input number of N so if and is greater than zero then we want

to just leave everything as is if an is less than zero then we want to multiply the result of this by

negative 1 to turn it into a negative number.

So let's try writing out that logic we can say if an is less than zero then return parse end of reversed

and we will multiply this by negative 1 like so.

So if it's less than zero return early multiply by negative 1.

Otherwise just parse the number out and we're done.

So let's try this.

I'll save the file and now it looks like our tests are passing.

Cool.

So this is definitely a working solution right here.

But clearly having these two return statements that both call Parsons isn't super ideal.

So if you stuck around at the end of the last section when I spoke about some of the little tricks that

you can use to really solve this problem in a very direct fashion.

The other the last trick that I suggested was a function that is a part of the JavaScript standard library

called Math Daut sign.

So if we pass math taught sign a positive number it will return 1.

If we pass math that sign in negative number it will return negative 1.

So rather than putting this complicated statement in here we can just dump the entire thing and instead

multiply the result of our parse in function right here.

Times math does sign and we'll pass in.

So now math dot sign is really taking the place of the if statement that we just had if and is greater

than zero it'll be positive or the result of all this will be positive.

Otherwise it is less than zero than the result of all of this will be a negative one and we'll end up

with a negative number.

So let's save this and see how we're doing.

Go.

So now we're still back to four passing tests.

But our code here is looking pretty straightforward.

Now one thing I want to throw out there.

It's totally up to you.

This is really a style thing but you'll notice that we didn't really have to come up with this temporary

variable reversed right here.

We could have easily wrapped this entire statement inside of the parsing function call.

However I think that the code right here looks pretty legible in this fashion.

And really if we wanted to kind of put everything into a one liner it really ends up being kind of nasty.

And I've actually got a example of that that I'll copy paste onto the screen.

So this would be kind of a one line solution right here.

I think that it's really tough to understand what's going on.

So personally I would really recommend leaving it as the two separate statements like so great.

So like I said this is just one solution.

There was many ways that we could kind of reiterate on this thing and change up the actual reversal

of the number.

But we already spoke about some of the different ways of reversing a string if you came up with a different

solution for actually handling the negative sign here.

We're actually pulling in number.

How do the string.

That's totally fine.

But this is definitely a solution that works as well.

So let's take a break here.

We'll continue the next section and move on to our next problem.
------------------------------------------------------------------------------------------------------------
============================================================================================================




Раздел 6:MaxChars

18. Max Chars Problem
I'm really excited about this next question that we're going to work on because the technique that we're

going to use to solve it is directly applicable to many other string related questions.

So in this one question Max Chaar there we're going to work on.

Let's open up the index not just file for it.

The technique that we're going to use to solve this can be used to solve many other string related questions

as well.

And I'll give you a list of some of the other ones that are very closely related in just a second.

First let's make sure that we start up our tests for this problem.

So at my terminal I think you know what to do by now.

We'll run just Max Chaar test dot genius dash dash watch like so you know I think I made a little.

It's not Max char's just Max Chaar.

My mistake.

Like so we should see at least three tests running.

OK.

So let's look at this problem in good detail and let's talk about the technique that we're going to

use to solve it.

So given a string we are going to return the character that is used the most.

Inside that string for example if we pass in a string of A B C C C C C will clearly C is used most frequently

inside of here.

So we see a return seat.

Likewise if we pass an apple and then 1 2 3 1 1 1.

Yeah.

These are numbers but they are inside of a string so they're still considered to be characters as far

as we are concerned.

And so clearly the most use character inside of here is one.

So we return the character or the string one not the number.

So no concern about numbers or in particular we're just saying unique characters inside of a string.

Ok so let's talk about the trick that we're going to use to solve this problem and many others like

it.

So first I want to show you some other common variations of this question.

So if you ever see questions like this on the screen right here you want to be thinking about using

this exact same technique.

And honestly I was going to put some of these other questions into this course but we would have just

been using the same technique again and again and again which would have been kind of annoying for you.

So I figured we would just do this one problem and have a good grasp on how to do it.

So if you ever see questions like the most common character on the string you see something like Does

one string have the same characters in the same quantity as another string.

That's what we refer to as an anagram.

By the way or do you ever see the question.

Does a given string have any repeated characters in it.

So anything like this anything around counting the number of characters or comparing the number of characters

between two strings.

You can always use this technique.

So let's talk about what it is here's what we're going to do for all these different problems that are

related to counting or verifying the number of characters in the string.

We are going to take our string and we're going to essentially convert it into an object where the keys

of the object are the characters from the string and the values are the number of times that that character

has been found.

So for example we could take the string Hello there.

Notice how hello there has one H.

It has three E's.

Here's what he 2E and three and he has two L's.

So with that in mind let's look at the resulting object that we would build up.

So inside of our object we would have one capital H and would have a value of 1 because that character

specifically capital H was found in our string exactly one time.

There are three E's present and they're each lower case so we would add a key of E and assign it a value

of three because it has been found three times.

Finally for l there is clearly two els here.

So we would put L in as a key and then assign a value of 2 and then we would repeat the process for

the rest of the string as well.

So when you have this kind of map right here it makes many different types of questions very straightforward.

For example if I asked you what is the most common character in the string which is pretty much what

we are trying to do right now.

Well now that we have this object we could walk through the object find the value that has the highest

there is give me find a property with the highest number assigned to it which in this case would have

been 3 and we would really know.

OK looks like is the most frequently used character.

If someone ever asks you to string a string B how the same characters at the same frequency.

Well we could build up an object that looks like this for both string a and string B and then compare

the two and make sure that both objects have the same number of properties inside of it and the same

values.

Finally does the string have any repeated characters so the words are there any duplicate characters

in the string.

Well this one's probably easiest overall.

If there's any value inside of this object with a value greater than 1.

Yeah that means that found say l twice were eat three times which means if someone asked me Does that

string have your repeated characters I would say yes that definitely does.

In this particular case.

So setting up an object like this is clearly a really strong tool for solving any type of question around

producing some counts or verification or validation of a word.

So with that in mind let's continue in the next section and I'll give you a quick overview on how we

would put together an object like this.

So quick break and we'll tackle this thing in the next section.
------------------------------------------------------------------------------------------------------------

19. Max Chars Character Map
In the last section we spoke about how turning a string into an object where the objects keys are the

letters in the string or the characters in the string can be used to solve a wide variety of problems.

In this section we're going to look at one possible way of generating this object right here.

Now if you want to give this entire problem that we're working on a go on your own and maybe even come

up with a solution that doesn't use an object like this that's totally fine.

Just pause the video here and continue on in the next section.

Otherwise let's get to this thing.

So I'm going to go ahead and use my little notepad over here to show you the solution.

So I hope to hear is that maybe you watch the solution but don't copy it down.

So maybe you watch it right now and then when you attempt the max Keres problem Remax charas problem

that we have cued up right now.

Maybe you tried to reproduce the solution from scratch at that point but of course I leave it up to

you.

All right so here's what we're going to do.

We're going to create some new string and I'll say hello there.

Just like the one we just saw in the diagram and then we're going to iterate through this string.

And for every character we're going to add that character to a new object.

So maybe you'll make a new object as well called chars short for characters.

So now there's a couple of different ways that we can take these characters and add them to the object.

We can either split the string into an array and then use a For Each helper to loop over all the characters

or we can use a four of loop to live through all the characters inside there and do basically the same

thing because we just saw the four of syntax just a little bit ago.

I think we should use four of again because it's nice and fresh in our minds.

So we will iterate through our string.

And for every character inside there we will either add the character as a property and assign it a

value of 1 or if we've already seen that character before we will add 1 to it.

So we'll save for let char of string and then for every character that we find and iterate over we're

going to add a property to chars to do that.

We'll say char's we'll use our index notation.

So this right here will return a reference to that particular character or at least its value.

Now if it's the first time that we are seeing this character we want to set its value to 1.

So if we have never seen chars at SE Capital H then this right here will evaluate to undefined.

So we need to make sure we handle that case.

So we'll say if nothing exists here right now.

Then set char's at Chaar to one otherwise assuming that there is a number already there will take charge

Chaar and will increment it by one like so.

So then at the very end we can print out charters and we end up with our object.

So we have a capital H with one.

We have three E's two l's and you get the idea.

Now the logic that we placed inside this for loop break here can certainly be condensed down from what

we have.

So a good way to simplify this would be to maybe use a tertiary expression.

We could also kind of condense this down to one line with a little bit of boolean logic and you want

let's let's see a quick example of that.

So another way of putting this logic inside if you're together without using an if statement would be

something like chars at char is char's char plus 1.

Now you'll notice this is why we can't just say add one.

Because if we try to add 1 to undefined we end up with no.

As you see right here.

So that's why we have to put in that statement to see if that value exists yet.

So one way of handling this eloquently in this particular case would be to say if adding one onto this

number resulted in a null value that's fine.

Then instead assign the value of 1 like so.

So if this is falsie then otherwise assign one to char at char and we end up with the same object either

way.

It's like I said many different ways of putting together the body of the for loop right here.

It's really up to you which way you want to do it.

All right.

So hopefully that kind of illuminates how we put this data structure together.

So at this point let's take a look at our question here and make sure it's really clear what we're trying

to do.

So inside this question member we are inside the max char folder in the index start G-S file.

We want to pass in a string to max char and then return the character that is most frequently used inside

that string.

So clearly inside the string C is used the most.

So I would expect to return see otherwise if we have Apple 1 2 3 1 1 1.

Well then we want to return one call.

So at this point we're going to take a break give this thing a shot see if you can't solve it.

And we'll go over the solution in the next video.
------------------------------------------------------------------------------------------------------------

20. Max Chars Solution
In the last section we spoke about how he can use a character map to solve a wide variety of different

string related questions a character map is an object where we take every character out of a string

we added as a key to the object.

And then the value for each for that key is the number of times that letter has been found in the string.

So hello there has three E's Inside of it.

So we have a Kievan E and assign a value of three.

Let's take this technique right here and approach and apply it to our Max char problem.

So remember inside of Max char we're trying to find the character that occurs most frequently inside

of a source string.

So definitely a problem that is well-suited to building up a character map.

So let's get to it inside of our function.

We'll start off by declaring a new variable called Char map which is short for Character Map and will

be an empty object.

Next will iterate over our source string right here and use that to build out the character map.

So we'll save for let char of string and then for every character that we receive we will add an entry

to Character Map and if an entry already exists there.

Then we'll just add 1 to the number.

So we'll say if Char map at char.

So if this exists if we already have an entry here.

Great.

Let's increment it by one

otherwise we will set char map at Char equal to 1.

So char map that char equal to 1.

Now you'll notice that I wrote this out opposite of how we just said in the example of minute ago I'm

just doing that on purpose just to give you a little bit of variety and make you use your brain just

a little bit.

So do you take note that I flip the kind of order of operations here between the two cases.

So now we should have our character map built up at the bottom of the file.

Or this function let's print out the character map that we just built just to make sure that it is working

correctly.

So I will console log char map like so let's flip on over to the terminal and see what happens.

So over at the terminal I should see my two console logs appear right here.

And so it looks like I correctly have.

Here's my character of one.

A B C D F G.

So remember this is some test input that is provided right here.

So looks like the test input has the character 1 and it's used six times.

So I would definitely say it this looks like it's working correctly right now.

All right let's take a quick pause right now.

We'll continue in the next section and we'll discuss how we can now iterate through our character map

and find the character that is most frequently used.

It's a quick break and we'll finish this up in the next video.
--------------------------------------------------------------------------------------------------------

21. Max Chars Solution Continued
In the last section we were able to verify that we successfully built a character map to represent our

strength.

Now it's up to us to somehow iterate through this character map and find the character that was used

most frequently in a given string.

So taking care of this is going to be very much like iterating through an object.

We're going to iterate through it.

We're going to try to find the value that has been used most frequently.

Now there's several different ways to iterate through an object like this and find the max value.

But we're going to take a very direct straightforward approach.

So we're going to start off by declaring to helper variables at the top of the function we'll say let

Max set that equal to zero and then let Max char and set that to an empty string.

So we're going to iterate through the character map if we ever find a character that has more uses than

max.

Then we'll set max equal to that new value and we'll set max char to a character that was responsible

for that number of uses.

So in other words the first time we iterate through say this hello world object right here we would

look at the key value pair of H and one.

Now one is greater than the initial variable of Max.

So we would say oh this must be a new maximum that we found.

So we would set max to 1 and then Max char would be set to the key at that location which is H.

We would then go onto the next value.

This one has three.

So we would set three equal to max and then Max char would be updated to e because that is the new maximum

character.

So in practice really not the worst thing in the world.

Let's give this a shot.

So I'm going to go down to the console log at the bottom and we will replace this with the new loop

to iterate through our character map.

So we'll save for let char.

And now here's something that's going to kind of blow your mind.

Notice how in the past we've been talking about that for of loop.

So the for loop is used for iterating through an array or a string or any type of iterable object.

But in this case we are iterating through an actual object like a collection of key value pairs.

So to iterate through this object or any type of javascript object as opposed to an array or a string

we instead use a slightly different kind of loop.

So in this case we use a loop that uses the for in syntax as opposed to four of the way that I remember

the difference between the two of these are just remember that object starts with 0.

And ironically they chose not to use of or you know starting with 0 to iterate through an object.

So I remember object starts with 0.

We do not use the four of which begins with 0 to iterate over an object.

Instead we use for it in.

So that's how I remember it personally.

So look at each character for char map.

Then if the char map at this particular character is greater than our Max we're going to update both

the max number and the max character.

So Max will become char map at char and Max char will become char.

So as you can guess right now when we iterate with a for in loop char right here is assigned to the

keys inside that object.

So this is not the values it is the key.

So char will be the different letters that we have added to our object.

Now after we run the loop we should then know which character is the greatest number of uses it will

be assigned to max char which means at the very end all we have to do is return Max char like so.

All right let's see how our tests are doing.

It looks like they're all passing.

Terrific.

OK.

Like I said using this kind of character map set up right here can be used to solve many different types

of string related questions.

And I really recommend you keep this technique close at hand whenever you are an interviewer they ask

you anything about strings it can be used in so many different locations.

So hopefully this has been helpful.

Let's continue the next section and continue working.

So a quick break and I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------
=================================================================================================================




Раздел 7:The Classic FizzBuzz!

22. FizzBuzz Problem Statement
The next problem that we're going to work on is going to be a lot of fun because it is the classic interview

question.

It is this buzz the question that has been asked more times than you could possibly believe in an interview

setting.

So in our physio's folder we're going to open up the index not just file will also immediately start

up our tests for Hizbullah's it as well.

So at my terminal or run just this buzz slash test that J us dash dash watch like so and then we should

verify and make sure that we see three Tests in total right now.

Two are failing one or passing OK.

Like I said this is the classic interview question.

As we said much earlier in the course one of the first sections we looked at and that one of those earlier

sections we had said that this is a problem that is really kind of challenging maybe moderately challenging

the first time you see it but as soon as you learn that little trick to it it becomes the easiest thing

in the world or so everyone claims.

So really if you haven't seen this problem before.

Don't sweat it.

If it seems challenging it's not until you see the little trick that it starts to get a little bit easier

to handle.

So let's make sure that it's really clear exactly how this problem works.

We have our first bus function down here towards the bottom when we call the fizz buzz function with

some whole number.

So some whole positive number we need to print out all the numbers from 1 to that number.

So when I say print out I really mean console logs we're going to cancel log out all the numbers from

1 to n. However for any number that is a multiple of three it's a multiple of three.

We are going to print out the string fills.

If the number is a multiple of five we're going to print out because if the number is a multiple of

both 3 and 5 then we're going to print out fizz buzz.

That's it.

So the real challenge here is I would really imagine you know how to count Konst alog you know how to

write a for loop to loop from 1 to n..

Clearly the challenge here is determining when the number is a multiple of 3 and five.

So that's it.

That's the little trick.

That's all there is as long as you can figure out exactly how to calculate a multiple of a number.

You can solve this problem without any issue.

So let's do a quick reminder on how to calculate a multiple of a given number in Javascript.

So I kind of flip back over to my little notepad here.

So we're going to use a very specific operator.

Now when I say operator I'm talking about like an addition sign a negative sign or a minus sign division

whatever it might be.

So if we say for example one missed one in this case the minus sign right here is our operator.

Now there is a very rarely used operator in the javascript world called the modulo operator and we spelled

out maade modulo like so.

So the modulo operator we can determine the remainder of a number during during division.

So for example if we took nine modulo three and returns zero.

So in this case it is zero.

Because if we divide 9 by 3 3 goes into 9 exactly three times and there is no remainder left over.

However if we divide 10 by three we'll then 3 goes into 10 still three times.

And there's one left over.

So three times three equals nine.

That is 1 away from 10.

And that's why we get a result of one over here.

If we do 11 mod 3 we'll then we're two away.

But if we go to 12 12 is again a multiple of three.

So we're back to zero.

So to determine if a number is a multiple of another we can use the modulo operator.

And essentially what we want to do is take some given number that we're trying to test use the modulo

operator with the number that we are using as the multiple.

And then the real question here that we are asking is whether or not the result to that is equal to

zero if 12 maade three is equal to zero then 12 must be a multiple of three.

However if we use 11 mod 3 this is not equal to zero.

So we get false.

So the story here is pretty much it.

This right here is the line that is the sole trick to fizz Buzz.

All you need to know is how the modulo operator works and then you can solve the entire problem.

So in practice you're going to test for each number from 1 to n and remember and is the number that

we pass in as an argument to the physio's function right here.

You're going to test to see if a given number modulo 3 is equal to zero.

And if a given number modulo 5 is equal to a given number person B is equal to zero.

And that's pretty much it.

That's the challenge here.

So I'd like you to give this thing a shot now as you're working through it.

There is one thing I want to point out here just because of how the tests are written.

Note that when you are printing out fizz and buzz and fizz buzz for multiples of three and five.

Notice that the expectation is that you're going to print out lower case things.

So lower case is not upper case for doing lower case fears here.

That is specifically what the tests are looking for.

Now the other thing to keep in mind is that you are not returning these numbers.

So if you find a multiple you're not returning it from the function you are con. logging the number.

OK.

OK.

So with that I'd like you to take a shot give it the best.

Darren can help go over the solution in the next section so I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------

23. Solving FizzBuzz with Style
All right hopefully you had some success with putting together your fist but solution in this section

we're going to walk through the solution and make sure it's really clear exactly how it works.

Remember the whole key to the solution is recognizing exactly how that modulo operator works.

The other thing that's really important to keep in mind is that as we are iterating through our list

of numbers we want to print out the number or features or buzz or fix bugs.

So for one particular number we print out only one thing we don't print out like three and four is for

the number three right here we print out only fizz.

So let's get started.

Step one is to make sure that we can iterate from 1 to n inside of our function.

So I get to find my first bus function down here towards the bottom and we're going to set up a loop

inside of it to iterate from one to end.

Now I know that I said a little bit ago that whenever you're doing interview questions you want to avoid

setting up manual for loops.

However this is one of those cases where we really can't get around it.

We don't have any object to iterate over.

We don't have any numbers or me any array to iterate over all we know is that we want to iterate from

one to end.

So this would be a case where we kind of are in a situation where we really want to just set up a for

loop manually.

So we'll set up our for loop to iterate from 1 to eat less than or equal to N and each time we're going

to increment by one.

Now one important thing to keep in mind here is yes we do want to start at 1.

If you write a lot of four loops in your life well you might be used to saying start off at zero.

We're not starting at zero here are the directions specifically say that we are iterating from 1 to

10.

So we're going to make sure we write out our loop like so next.

What I really recommend you do an interview setting just to make sure you nail this question 100 percent

is to write out some comments to guide you.

So the first thing we want to do here is check to see if the number is a multiple of both 3 and 5.

So we're going to say is the number a multiple of 3 and 5.

Because if so we want to cancel log and then do nothing else in this step through the loop.

And that's really important.

Remember if our number is say equal to 3 we only want to print out things and we don't want to print

out the number three.

So we need to make sure that we whenever we do all of these checks we initiate the check.

We print out the statement that is required and then we do nothing else inside of the step through the

loop.

So let's get started by writing out the if statement that is going to check to see if our number is

a multiple of both 3 and 5.

So I'll say if I modulo 3 is equal to zero.

So that's going to check to see if we have a multiple of three.

And if I modulo 5 is a multiple of zero then we want to cancel log out fizz buzz like so so that's step

one.

Now one thing that I will mention right away is if you look at this and you are kind of got a thing

for numbers.

You'll very quickly realize that we only are going to meet this kind of criteria right here having a

multiple three and a multiple of five when it is a multiple of 15.

So any number that is a multiple of three and five is going to be a multiple of 15 because three times

five is 15.

So if you came up with a solution where you said I modulo 15 and left it just like that.

That's totally fine and appropriate.

This is something that sometimes people do because it is just a little bit more terse and easier to

read but honestly you're totally fine leaving it just like so.

All right.

So we have successfully checked to see if we are a multiple of three and five.

Now the thing to recognize next is that we don't want to set up a nother separate if statement.

So if we met this situation right here this condition this is the only code this council is the only

law that we want to execute.

So essentially what I'm saying here is we want to make sure that if we meet this case we don't execute

any other code inside the for loop.

And so to make sure that's the case rather than writing out a bunch of separate if statements we'll

write out a bunch of ELSE IF statements.

So we're going to see if we meet this condition if we do.

Great.

Do the console log and go on to the next step through the loop.

Otherwise if we meet this next condition execute the next console log and so on.

So for the next one we'll check to see if we have a multiple of three

and I'll add a comment here just to remind myself is the number a multiple of three.

And if it is a console log out this next we'll out in the next.

Else if if so if we have a multiple of five then we'll cancel log out buzz.

And then finally if we have failed all three if statements inside of here.

So if we are not a multiple of 15 not a multiple or three not a multiple of five.

Finally at the very end here we'll just print out the number.

And so I will console log simply.

I like so ok.

You'll notice I missed my comments on these last two cases but I think you have a reasonable idea of

what those comments would be if you want to add them in.

So this right here is the classic an imitation of this buzz.

Now you will see sometimes other situations online or other implementations that kind of condense this

code down a little bit and they might use Tzschirner expressions or some oddities around javascript

to shorten it.

But honestly at the end of the day if someone asks you this question I really recommend you basically

just do exactly this right here.

There's really no need to get fancy.

And honestly if you start to get fancy with fizz buzz that's kind of something that interviewers lock

on to interviewers like to see that you understand advanced syntax and they want to see that you know

how some neat helpers inside javascript works.

But if you start putting what is otherwise very straightforward legible code like this into some really

fancy one liner honestly it's kind of ironic.

But their first inclination and I've seen this happen so many times in person.

Their first inclination is to say something like Wow you took some really easy code and you turned in

as some fancy one liner.

That's really hard to understand.

And so it's like well you know on some questions they want you to go above and beyond and use some fancy

javascript.

But on the ones they really want it to be just straightforward and simple.

And I would definitely classify fizz buzz as one to leave as very straightforward and simple.

So I really recommend you just kind of leave it in long form like this and not try to make it fancy

or condense it down to anything else.

OK.

Let's make sure that our tests are passing.

If we flip on over to the terminal.

Yup looks like we got three test passing.

Awesome.

So again classic this was all you got to remember is how the modulo operator works as long as you do

you're going to have an easy time with this question.

So now that we've heard this buzz it's time to move on.

Let's get on our next topic in the next section.
------------------------------------------------------------------------------------------------------------------------------

24. Array Chunk Problem Statement

I'm really excited about the next prong are going to work on because it's one of my personal favorites

in as much as you can have a favorite interview question.

So inside my code editor I'm going to find the chunk folder and then open up the index G-S file inside

of it and then of course before we forget we'll also flip on over to our terminal and start up our tests

as well.

So just showing tested.

Yes.

Dash dash watch like so and just make sure that you have.

Let's see five-Test popping up.

That's how many we have for this particular exercise.

So let's look at the directions here inside the index file.

You'll find the directions at the top.

So given an array in a chunk size as arguments and so look at the chunk function right here it accepts

an array and the size as argument.

Using those we want to divide the array into many sub arrays where each subarray is of length size.

So in other words we're taking one big array and splitting it into many smaller substrates that are

all contained within one larger array.

This function is probably easiest to understand when you start looking at some examples.

So let's do exactly that.

Let's look at the first one right here.

If we call chunk with an array of the numbers 1 2 3 and 4 and specify a chunk length of 2 then we should

end up with one big array that contains smaller arrays inside of it.

And so these smaller arrays are what we would refer to as the sub arrays each separate is of length

2 because two as we passed in as the size.

Notice that the two here is specifying the number of elements that go into each chunk.

It's not specifying the total number of chunks.

So to write here doesn't mean that we should have two separate chunks.

It means that there should be two elements in each chunk.

Perhaps the next one gives a little bit better example in that regard.

So in this case we have 1 2 3 4 and 5 and we still have a chunk size of 2.

So in this case we put two elements into the first chunk two elements into the next junk and there's

only one element remaining.

And so we take that one last element and put it into its own chunk at the very end and then you can

see this repeated throughout the other examples as well.

Another good example might be the one down here second to the bottom.

So we have one two three four five and a chunk size of four.

So we create one chunk that has one two three four elements inside of it.

And the only remaining element goes into its own chunk.

So in other words if you have kind of an orphaned element or you don't have enough elements to fill

up its own chunk that's totally fine.

You just stick it into its own chunk at the very end.

So that's pretty much it.

That's the challenge.

This is definitely a harder problem to solve.

But nonetheless I'd love it if you gave it a shot.

I'm going to let you kind of take it from here.

Without a lot more input from me.

Consider this a little trial by fire.

But of course if you get stuck at all don't sweat it.

Watch a couple of minutes of the solution and then come back and give it another shot.

So a quick break for you to work on this and we'll look at the first solution in the next section.
----------------------------------------------------------------------------------------------------------------

25. Chunk Solution #1

Hopefully you had some success with that chunk problem.

This is definitely a pretty challenging one.

So if you ran into any issues hey don't sweat it.

In this section we're going to go through one possible solution to that chunk problem.

Now there are two solutions that come to mind kind of easily when I think about this problem.

So we're going to look at one possible solution in this video and then we'll look at another possible

solution in the next one.

Now I think that the difficulty between these two solutions are kind of equal in putting them together.

But I think the second solution so the one that we'll look at in a little bit is probably more challenging

to arrive at by yourself.

So this is another great example of when you know the trick things get easy.

But if you don't know the trick well life is a little bit hard.

OK.

So we're going to look at a diagram.

This is going to describe our first solution.

So let's take a look at this.

So we're going to walk through this series of steps right here.

So this is our algorithm starting at the top and going down.

And as we talk through this algorithm We're also going to kind of trace out how all these different

puzzle pieces are changing or all these different arrays are changing over time.

So it's going to be just a little bit awkward.

Hopefully you can bear with me as I tried to diagram or demonstrate this with some of these shapes.

So let's get to it.

First off we're going to assume that our chunk function gets called with some array that has three elements

inside of it.

And so this green thing right here this is the array that our function is going to be called with.

We're also going to assume that we have a chunk size of two just for the purposes of walking through

this example.

So here's the algorithm we're going to use.

We'll first start off by creating a brand new empty array to hold this kind of chunky version of our

data and we're going to call this thing chunked.

So this is like the chunked version of our array.

So we're going to represent this brand new array that you and I are going to create with this blue box

right here.

And so I will draw an arrow from that step to this blue box to just remind you hey this is the chunka

version of our array.

After creating this empty array we will then start to L to iterate through the original n chunked array

that was passed into our function.

So the unchecked array is this original one right here up top in green then for each element in that

unchecked array we're going to go through a series of steps right here.

First we're going to retrieve the last element in the blue chunk.

So the last element the element that's Furnas to the right hand side.

Now the first time our algorithm runs this brand new chunk array will be completely empty.

So when we attempt to retrieve the last element inside of it we will end up with essentially undefined

will have nothing to show for it.

So the next line is how we handle that we're going to look at that element that we just retrieve the

last element in the chunk array.

We will say that if the last element does not exist or if the last element inside the chunk Drey is

equal to chunk size then execute this step right here.

So we definitely fall into this statement right here because the last element in our chunk doré does

not yet exist for the first time we run through this.

So we're going to execute this line of code right here in this line of code says that we are going to

push a new sub array or a new chunk into the blue chunk to one with the current element that we are

iterating over which is 1.

So this is the for loop that we are iterating through right here.

So we're going to take a new sub array this kind of chunk right here.

We're going to push it in and then we're going to add our first element to it.

And that concludes our first loop through this array.

We now will will iterate through this array again.

So we're going to move on to element 2 right here.

We will attempt to retrieve the last element and chunked.

Now this time it's going to be this blue chunk that we return right here.

So this is the last element in our chunk.

So this time we checked to see if that last element does not exist.

It does exist.

So that's not satisfied.

We then checked to see if the length of that chunk is equal to our chunk size of two.

Well at present our chunk size is 1.

So we don't fall into that case.

So rather than executing this line of code we'll go down to the else case right here in the case says

add the current element which is to into the chunk the last element in the chunk Drey.

So we're going to take two and added And right there.

Finally we'll iterate through the last element inside of our unchecked array.

So this is going to be a 3.

We retrieve the last element in chunked.

So that's going to be the purple block box right here.

We checked to see if its length is equal to the chunk size.

And so now at this point in time there are two elements inside of here and we have 2 a chunk size of

two.

So we do satisfy the if statement right here.

And we're going to run this line of code so we're going to push a new chunk into chunks.

So we're going to take this new chunk shove it in there and then we'll take the current element and

put it inside that.

And now we have nothing else to iterate through with our for loop.

Our original loop right here is now empty.

We've gone through everything and we have ended up with our correctly chunked array right here.

So this is it.

This is pretty much how we're going to accomplish this.

First run through this first solution.

Now again if you came up with a different solution than this one that's totally fine.

Totally appropriate.

This is just one possible solution and one that I personally think is kind of straightforward and easy

to understand or at least relatively easy.

So let's now take a break.

We'll continue in the next section and start to code this solution up.
----------------------------------------------------------------------------------------------------------------------------

26. More on Chunk

In the last section we looked at the diagram to understand our chunk solution.

Let's now continue by coding this thing up.

So inside my code editor I'm going to make sure I'm inside of my shunk index dot js file.

I will open up my function here and we'll start adding a little bit of code.

So remember Step one is to declare a new array that is going to hold all these different chunks.

So I'm going to create a new array.

I'm going to call it chunked to say hey this is the array that holds all the different chunks of data.

Next we will iterate through our original array of elements right here to iterate through the array

we're going to use the four of helper again.

So we'll say for let element of array and then we'll execute some logic inside of here to look out the

last element inside of our chunked array.

So to get the last element inside the chunk array we'll make a temporary variable.

So we'll say last is to say this is the last element inside that array and then you get the last element

inside of there.

We can say chunked at chunked dot length minus 1 like so.

Now the next part is pretty well explained by the diagram over here.

We want to check both to see if that last element does not exist or if its length is equal to the chunk

size because if it is we want to push a new chunk into chunked with a current element that we are iterating

over.

So to accomplish that we can say if last does not exist or if the length of last is equal to our chunk

size remember chunk size appear as an argument.

Then we want to add a new element to chunked or a new chunk to chunked and put our element inside that.

So to do that we can say chunked Daut push and then rather than put a new chunk inside of it and then

add the element ID in we can do both things at the same time.

So we'll push in a new chunk and we'll immediately put our element that we are currently iterating over

inside there.

So we're doing both things in one step.

Now the last thing we have to take care of is the case in which we already have a chunk but it does

not get full.

So in that case we're going to take the current element and add it to the chunk and remember the chunk

that we're discussing is this last variable right here.

So otherwise we will last dot push because remember last year is going to be the chunk that we are currently

working with and we will put our elements into that thing.

Now the very last step and make sure you never forget this.

This is such an easy thing to forget.

Make sure that you return the chunked array at the very bottom.

So we will make sure that we return shopped like some.

OK.

So save this let's check our tests and see how we're doing.

Well hey it looks good to me.

We've got five test passing out five.

So like I said this is one possible solution.

I think that this might be the slightly more obvious one.

Are you whenever I say obvious I don't mean hey this is so obvious you should definitely get this.

I just mean to say this one is probably a little bit more evident than the alternative solution that

we'll look at in the next section.

I do consider the next solution to be a little bit easier to put together and probably easier to understand.

But it's definitely more challenging to kind of think of on your own.

It's one where you can have to sit down and kind of noodle on it for a little bit.

This kind of iterative solution right here is probably one of the first ways a lot of people will think

about accomplishing this.

Now maybe if you thought of a solution like this and you didn't take this entire hey let's look at the

last chunk and see what to do with it.

Well maybe you didn't take that approach but maybe you at least did this kind of let's iterate through

the array and consider each element.

That's what I mean by you know I think this one might be a little bit more common to see in the wild.

So this is one possible solution.

Let's continue in the next section we're going to look at the second possible solution to this problem.

So quick break and I'll see you in just a minute.
------------------------------------------------------------------------------------------------------------

27. Chunk Solution #2

In this section we're going to look at a alternate solution to that chunk problem.

Now as usual we'll make a backup of our solution.

So inside of my current index not just file I'm going to copy my first attempt at chunk I'll paste it

down at the bottom of the file just for records.

Now a comment that went out and clean up the original chunk function by deleting the contents like the

OK so just like the previous section or the previous two lectures in this video will look at this alternative

approach.

We'll take a break and we'll come back and code up the solution because I do want to give you the opportunity

to attempt a solution with this other fashion if you want to.

So let's get to it.

All right now knowledge of this second solution.

Like I said it's a little bit harder to come at this solution on your own unless you are very familiar

or have very recently at least how this function in mind one particular function that has to do with

arrays and this function is called sleights.

So if we call letters dot slice.

So this is a function or a method that exists on all arrays.

We can pass in some start index.

So let's say I start index of 0 and then as the second argument some and index.

So maybe I'll put in three like so.

So this says starting at element 0.

Give me a copy.

That's very important.

We are taking a copy of every element inside of letters from 0 to element 3 but not including element

3.

So in this case element 3 would be the letter D right here.

So take everything from 0 up to element 3 but not including it.

One very common mistake around slice is thinking that the second argument is the number of elements

that we want to slice out of the array.

That is not correct.

If we change say the first Delman right tool 1 we're now taking everything from Element 1 up to but

not including element 3.

So clearly the second argument is not a length here.

If it was a length then we would still see three elements inside our result over here.

So with this slice method in mind we can start to think of a alternative approach to the chunk problem.

So again we're going to kind of sketch this out with a diagram.

I know this is kind of sloppy to do with the diagrams but frankly I can't do animations and you know

fancy Illustrator or what have you whatever you would use to make illustrations so I kind of like just

drawing it out keeps it simple.

So again we're going to start off by creating a empty trunked array and that's going to be our blue

box right here.

Then we're going to create a index variable.

So just some random variable.

We're going to call it index and we're going to start it off at 0.

We will then create a for loop or be a while loop and this while loop will run as long as index is less

than our original arrays length.

And then here's where things get interesting.

Inside this while loop we are going to take a slice out of our original array starting at index and

ending at index plus size will take a slice out of it and then we will push that into our chunk array.

So let's put some numbers to this thing for the first go through.

We're going to start off with the index of 0 and we have a chunk size of two.

So we're going to take a chunk size from 0 to.

And we're going to put that into our array right here.

So our a slice from 0 to 2 on the green array would include everything from 1 to 2 right here.

So take that slice it puts it into our chunked array element one element to we then add size to index.

So chunk size to index.

So the second time around we then restart our while loop right here.

Index would now be equal to 2 and we'd then repeat the process.

So we had now attempt to take a slice from two to four.

And in this case we don't have elements going up to 4.

So it just gives us everything left inside the array.

And we would end up sticking everything in like so.

So I think as far as the code goes with this solution it's probably far less code that we have to write.

And there's really kind of less edge cases that we have to worry about but it really does.

It's all predicated on your knowledge of the slice method.

If you're not familiar with slice in the interview setting.

Well then this would be a hard one to kind of pull out of a hat and imagine if you did come up with

a solution.

I've got to like hats off to you like nice job coming up with this one because this is definitely not

a solution that I think I would come up with on top of my head personally.

So now that we have a better idea of how this works let's take a quick break and then put together the

implementation in the next section.
--------------------------------------------------------------------------------------------------------

28. Even More on Chunk!
All right let's give a shot at our second implementation here by using the slice function.

So I'm back inside my chunk file I'm going to open up my function and we'll start off by following some

of the blueprints that we left over here on the diagram.

So we had said that we would create an empty chunk array and we would create an index variable starting

off at zero.

So inside of chunked or something inside of chunk we'll create chunked which will be our empty array

and it will create our index variable.

Now index is going to be changing over time.

So we're not going to use a concert keyword here.

Instead we use a let keyword because this is a variable that we want to allowed to change over time.

Next we'll set up our while loop.

So we want to run this while loop as long as index is less than the original arrays length.

So I will say while index is less than array length and then inside of here's where the magic really

starts to happen first we'll write out the slice statement.

So this would be the statement that we'll take a slice out of our original array right here.

So we want to slice everything from index to index plus size.

That's the magic that's the hard part right there.

Array that slice produces an array that contains some number of elements out of the original array right

here.

So we can take this slice that gets produced and just stick it directly into the chunked array by using

the push method.

So we'll take this whole thing and stick it into chunked by saying chunked dot push like so and then

make sure you're close off the parentheses on the other side.

Then immediately after that after we do our slice statement right here we need to move on to the next

index.

So we're going to take our index variable and we'll add size to it.

So we're not incrementing by one here where incrementing by the size variable because you want to essentially

take big scoops out of the original array over time.

So say index plus equal size and then remember that one very important step that I would never want

you to forget.

Make sure you return chunked at the bottom OK.

Let's check our tests and it looks like they're still all passing.

So I think you can agree with me that this is visually a kind of more straightforward solution at least

in terms of lines of code.

And as long as you understand how slice works it probably is a little bit easier to understand what's

going on rather than the solution that we came up with before where we iterated through the entire array.

Again I think this would be a harder one to come up with on your own so if you didn't come up with this

hey don't sweat it.

Remember this course is all about just giving you these little tricks and tips because that's how you

get better over time.

You just see more problems.

You learn tips like this and you apply them to future problems that you see.

So let's take a break right now.

We'll continue in the next section and start looking at our next problem.
--------------------------------------------------------------------------------------------------------------
==============================================================================================================

Раздел 9:Anagrams

29. What Are Anagrams?

Our goal here is to check to see if two strings are anagrams of each other.

Remember an anagram is where we take one string and then generate another string out of it that has

the same number and quantity of characters.

So for example if we took the string rail safety and jumbled those letters into this string fairytales

they both use the same number in quantity of each character.

So for example I will find exactly 1 are in both strings.

I will find two ways in both strings and so on.

You get the idea.

Now some special directions on this question in particular is note that we only want to consider characters

we don't want to consider spaces or punctuation like say ex-school exclamation marks or anything like

that so we can completely disregard exclamation marks and spaces.

In addition we want to consider capital letters to be exactly the same as a lowercase character.

So the second example right here is a great example of both those two rules.

So you'll notice right above we have real safety and fairytales are anagrams.

The second example right here has still real safety but with capital letters and exclamation marks.

However we should still consider this to be an anagram of the lowercase fairy tales.

Now just to make sure that you start down the right path.

I want to give you a couple little tips for dealing with these kind of edge cases around characters

and not spaces or punctuation.

And also a quick tip around capital letters as well.

So let's flip over to my browser really quick.

We're going to look at some examples here.

So the first thing I want to give you a quick note on is on the Indiana documentation we have Regg axes

which are short for regular expressions regular expressions can be used to manipulate strings very easily.

And in this case we can use a regular expression to very easily remove all the spaces and exclamation

marks from a given string.

So in this article I'm going to scroll down a little bit and one of the items inside of here right here.

So backslash w specifically shows us how to match only characters and completely disregard any type

of space or any type of punctuation or other symbol for that matter.

So let's see an example of this in practice as a quick example let's say maybe we have a string called

Word and it is the string.

Hi there.

All capitals with a lot of exclamation marks and a space in between right here.

So we can very easily remove the space in all the exclamation marks from this thing by calling word

dot Daut replace and they'll make use of a regular expression inside this.

So I'm going to place a forward slash a square bracket a carrot backslash w a closing square of race

slash G.

And then we will replace any characters like that are that are found with an empty string.

And so you can see that very easily that removes all the extraneous characters from the strings so it

gives us something a little bit more cleaner to work with.

Now the other thing to keep in mind is that we only want to work with lowercase characters.

So a very easy way of making sure that we are working with a lowercase string of beats of chain on the

method to lower case like so and so essentially with these two methods right here we can take a string

that is capitalized with spaces and punctuation side of it and reduce it down to just the bare characters

like so.

So I really expect to you will end up making use of these two methods right here and your solution.

So essentially copy these things down because I really expect you're going to need them.

Now the other thing I want to mention just as a reminder about how we'd generally like to solve any

type of question involving strings and comparison between them is to generate character maps and that

was something that you'll recall we did earlier on in this course.

So just as a suggestion.

One possible way and this is just one way there is more than one way to do this question but one possible

way is to generate a character map out of both the strings you are given.

So for example if we are given the strings hello and I don't know what this is supposed to be.

Li Li Ho I guess I don't know if we build a character map out of both these.

We would end up with 1 h one e two l's and 1 0.

And we would get the exact same character map for Leo as well.

So we could iterate over one of these character maps and compare all the letters inside of it with all

the letters and the other one and the quantities as well.

So I'll leave that one up to you to kind of get through a little bit and figure out.

So there is one last little gotcha around the character maps that you're going to generate here.

If you decide to go with this method let me show you what this kind of edge case is when I just told

you that you would want to compare these two character maps.

You might have thought OK we can iterate through this object right here and then compare all the properties

and values with the properties and values in the other object as well.

So there's one little edge case that I want to throw out there just so you are aware of.

Imagine the case of we were going to compare these two character maps.

So notice I just change the diagram the word over here on the right has changed to close.

So has an extra s on here.

Now imagine if we wrote a loop to iterate only through this object if we only iterated through this

object we would look at the character H see that it has one use and compare it over to this object we

would say OK this one has h as well and it has one uses well within repeat the process for E.

They're the same l they're the same.

Oh they're the same.

And that's it.

We've now finished iterating through this object.

But notice how we completely missed the fact that this other character map has an extra s on it.

So one possible way of solving this problem is to compare first this character map to this one and then

iterate through this character map and compare to this one.

However there is the easier or kind of a little shortcut that we could use to avoid that.

So we don't really have to do a comparison one way on a comparison back to the other.

If you want to know what that little trick is I'm going to say right now what we can do is count the

number of keys that are present inside of one object and compare it to the Keys that exist inside the

other.

So for example this key over here has four legs or letters inside of it.

This one over here has five.

And then another very obvious way of handling this would be to count the length of characters inside

this string and compare it to this one over here.

So just two ways of addressing that issue.

OK.

So we've laid out a couple of notes here.

Now this anagrams question is a rather challenging one.

So do give it a shot but as usual if you get stuck feel free to check out the solution and we'll walk

through how to solve this thing together.

So quick break and we'll continue with the solution in the next section.

--------------------------------------------------------------------------------------------------------------

30. Solving Anagrams
I'll read my friends hopefully anagrams was not too bad.

This is a rather challenging question.

It is challenging but it's also one that I can almost guarantee that you would see in an interview setting.

So if you go on like 10 interviews I would personally be surprised if you didn't get asked this question.

So it's definitely a very good one to keep in your back pocket because you never know when it's going

to be asked.

So let's talk about her solution here by using character maps.

We're going to build a character map out of string A and string B and then we'll compare all the characters

inside those two maps together.

So let's start off by giving ourselves a little bit of space inside this function.

Now we're going to need to make a character map out of both of these things right here.

So the first thing I'm going to recommend is we don't really want to build two for loops to iterate

both through string A and string B instead.

A really easy way to save ourselves the pain of having to write two separate four loops to iterate through

each string right here would be to write a helper function to build a character map for us.

Now if you didn't make a helper function if you wrote out two character map assemblies inside this function

already that's totally fine.

But the interview setting interview is kind of like to see you create helper functions and it kind of

also allows you to better segregate or compartmentalize your code which is always helpful in sort of

an interview.

I have some other tips around creating helper functions that we'll talk about later on in the course.

They're actually kind of a great thing to keep in mind in an interview setting.

So let's first start off by making a helper function here.

And we're going to use this helper function to build a character map for a given string.

So we only have to write this logic one time and then we can use both on string A and string B will

say function build char map and we'll pass a string in to that function.

Then inside of here we'll create an empty object that will serve as our character map we'll then iterate

through our string and for every character inside there will add it to our character map.

Now one other thing to keep in mind is that we had said that our string needs to be only considering

lowercase characters and we also need to strip out any spaces or any punctuation.

So we certainly could do something like create a cleaned string ahead of time and do the Ragg X and

the two lowercase call right here.

But one easier way of doing it or maybe not easier but a slightly more compact way would be to tuck

that kind of Clean-Up logic directly into a for loop itself.

So let's look at what that might look like.

You could say let char of string dot replace.

So this is where we're going to do that replace in lower case logic logic just right here in line with

the for loop.

So we will replace forward slash square bracket.

Carit backslash W..

And then on the other side of the square brace we'll put a forward slash G.

So note that everything inside of your code editor should very likely turn into a slightly different

color when you've got this regular expression put together correctly.

So any time that we find a character that is not a number a character Kapell character or a lowercase

character we want to replace it with nothing or essentially an empty string after we've done that Clean-Up

logic.

Well then take the entire string and turn it to lower case like so you no open up our for loop.

Ok so now we're iterating only over the portions of the string that we really care about and remember

how we put our character maps together.

We take our character map we assign a key to the character map of the current character that we're looking

at and then we increment the value out that character.

So we'll say char map at char is char map at Char plus 1 and then we need to handle the case in which

this particular character has not yet been assigned to the character map.

So to say or one like so then very important.

I can't stress this enough because when you're in a high stress setting like interview or even when

you're practicing these problems yourself at home.

So easy to make tiny little mistakes so I I know it might be annoying for me to remind you all the time

to get the return statements in here but honestly you have no idea how often people just honestly forget

to put in a return statement so I will harp on that throughout the course.

I apologize if that is annoying.

OK so we've got our helper function here to build up our character map.

Now we can use it to produce a character map both string a and string B.

So let's declare a variable let's call it a char map will be build char map from string a and b Schar

map will be build char map from string B.

So we've now got these two character maps and it's now up to us to compare the two of them together.

The other thing that we still need to keep in mind is that kind of edge case that we mentioned at the

end the last video where if we only compare this object to this one we might miss out on some extra

entries inside the second one.

So I had mentioned that an easy way to solve this is to either compare the length of the two character

or the two strings.

If we do that do you remember that you would have to compare the length after subtracting out spaces

and punctuation.

So if you want to take that approach you can do the same kind of replace in two lowercase for both strings

up here and then compare the length of the two of them.

Another possible approach would be to look at the number of keys inside of both these maps and check

to see if they are identical in length.

So that is the approach that we're going to go with so we're going to pull out all the keys from both

these objects right here and we'll count the number of keys that is contained in both.

If you've never pulled out the number or the schism if you never pulled out the keys inside an object

before that's totally fine I'll show you how to do that.

Let's look at a quick example.

So if we have an object that would call just O.B. J.

And it has keys a b and c we can get a list of all the keys inside this object by calling object.

Notice that is a capital O object.

Keys will cast an object like so.

So that returns an array with all the keys from our object.

If we then call DOT length on that.

Well then we can very easily tell how many keys exist inside of our object.

And so this is the solution that we're going to use to address this problem of some extra character

existing in one character map or the other.

So we'll get the number of keys inside this character map the number of keys and this character map

and then can compare the two together.

So in practice will put a little if statement here will say if object we use for aid char map length

is not equal to object.

Keys for the char map length.

Well then we must know that we do not have an anagram because they have a different number of characters

or maybe a better way of putting that would be to say one character map has an extra character type

that the other one does not.

So if that's the case we'll just immediately return false from this function.

Now if they do have the same number of characters that we want to proceed with the map checking process

in which we will look at each one of these characters and compare the number of uses that it has to

the other map most part might sound like it's kind of challenging.

You know this I know that when I kind of see that with words you know I put it in a plain-English it

sounds like it's something is challenging but honestly I think you know how to do this I think this

is something that you definitely can do what we have to do here is to iterate over one char map look

at every character inside of it and then compare it to the other Charmel.

So we're going to iterate over a char map and really we could iterate over either one it doesn't really

matter here we just have to pick one.

In this case we'll iterate over a char map.

So save for let char and then don't forget here a little.

Gotcha.

And if we are iterating iterating over an array We use of.

But if we are iterating over an object we use in and remember that what's the term for it not anagram.

We're we're working at anagrams.

I know it's going to come to me.

The little trick for remembering which one to use.

If we are iterating over an object We use of which is really confusing because 0 starts where object

starts with oh so you would think that you would use of to iterate through an object but that's not

the case.

So for an object we use in which is kind of doesn't line up with the first letter in that word right

there.

I know that's probably an awful way of remembering but that's what I use.

So look through a char map and if a char map at char is not equal to the char map at char then something

must be wrong.

So let's say we're iterating through a char map and the first character that we look at is the letter

A.

We say how many times has a been used inside of HRO map if it has not been used the same number of times

and of the term map.

That means that something must be wrong or these two things do not line up at all.

So in that case we can't immediately return false

OK.

Now the last thing and again I know I'm harping on the return statements here but this is another very

easy one to forget.

Notice how we set up here inside the directions that we need to return true if they are anagrams and

false if they are not.

So we've handled the cases in which they are not anagrams by basically returning false.

And the thing that we cannot forget is that if we succeed in both these checks right here that means

that they must be anagrams.

And so in that case we should return true.

Like so.

OK so this is our solution this is solution number one for solving anagrams.

Let's check our tests.

It looks like they're all passing which is fantastic.

So I think that is going to work out just fine.

Now in the last video I had mentioned that this whole anagram question and the two solutions that we're

going to look at is kind of nice because it frames some later content that we're going to discuss in

the course.

So I want you to kind of look at this solution right here.

Very quickly when we look at it you'll notice that if we consider the number of times that we have to

iterate through either these streams right here we iterate through string a one time to build our character

map we iterate through string B one time to build our character map and then we iterate through one

character map to do the final comparison here.

And so I just want to very quickly point that out because we are going to come back to this question

or this solution right here later on in the course and I'm going to just kind of point out some interesting

things about the way that we solved this problem right here.

And the way in which we solve it in the next section because we are going to look at a second solution.

So if any minds let's pause right now we're going to continue the next video and we're going to look

at another way of solving this problem that is far far easier.

But it does run into some interesting issues that like I said we'll kind of consider later on in the

course.

So a quick break and we'll tackle that second solution in just a moment.
--------------------------------------------------------------------------------------------------------------

31. Another Way to Tackle Anagrams

All right.

Time for a solution or two to anagrams.

So this one's going to be a little bit more straightforward.

Well I should say a lot more straightforward but like I said at the end of the last video it will run

into some interesting performance concerns.

That is something that we're going to kind of use to frame another topic later on in the course.

So the first thing we're going to do is a little bit of clean up of our indexed not gigas file.

So I'm going to take both the anagrams function and the build char map function.

I'm going to highlight it all.

I'm going to cut it.

I'm going to move it to the bottom of the file and I'm going to comment both those functions out.

So I do want to keep these around just for record keeping.

Honestly it's for you for the future when you come back and review this stuff if you choose to.

But we'll keep it there.

And then we do need to redefine the function anagrams because we cut and pasted the entire thing.

So call string A and string B like so.

OK.

Seligson.

Now the second solution for handling anagrams.

Like I said is going to be a little bit more straightforward but like many many things that we've seen

inside this course it all depends upon knowing one little trick.

So let me show you a little trick.

It's going to flip on over here.

I'm going to make an array and then we're going to look at one specific method that exists on array

an array that will make solving these anagram things pretty straightforward.

So let's make an array of numbers and I'll give it about ten thirty five negative ninety one 10000 where

that is.

So here's the interesting function.

I want to show you where you look at numbers dot sort.

So when we sort in array it will take all the elements in the array.

And your javascript runtime will do its best to figure out how to somehow meaningfully sort the characters

or I should say the elements within that array now sort cannot only be used with numbers.

It can also be used with characters as well.

So if we had instead like Z c b d y and then we sort it we end up with alphabetical order.

And so this alphabetical order is what really forms the basis for this alternative solution to anagrams.

So here's we're going to do.

We're going to take our two inputs.

So in this case like maybe rail safety and fairy tales we're going to clean up both strings by replacing

or I should say removing any spaces or punctuation.

We're going to lowercase both strings and then here's the magic part.

We're going to sort both strings.

So when we sort both them no matter what characters we have inside they will end up in the exact same

order.

If the two sorted strings are then completely identical then we can say that we have an anagram and

so when you take this solution we you and I don't even have to do some four or Luper iteration or anything

like that to look at every single string.

We can just sort both these strings and then say that's it.

Compare the two.

We're done.

I think the best way of covering this solution will probably be to write out some code and then we can

copy that code over to this little editor over here and see it in play.

I think that will be the best way of handling this.

So let's get to it.

So again I'm going to make myself a little helper function to automatically kind of clean up each of

these strings.

So remember that kind of replace statement and the two lowercase statement.

And in this case doing the sorting of the string as well.

So I don't want to duplicate that logic inside of this anagrams function so I'll make a helper function

to do all that for us.

So don't I make helper function called Clean string.

It will be called with a string.

We're going to return the string.

We're going to replace and this will be our regular expression again.

So do forward slash square brace square bracket

carrot backslash W..

And then on the other side of the square bracket forward slash G and we'll put an empty string inside

there as a second argument.

Next we'll do a two lower case and now before we attempt to sort this thing remember we just looked

at the sort method that is a method that belongs to arrays not strings.

So we do have to temporarily turn this string into an array sort it and then turn it back into a string.

So we will split this thing on an empty string we'll sort it and then we will join it back together

into a string.

So that's a lot of statements chained together into one.

Remember when we consider chaining of methods in javascript we read it essentially from left to right.

So first we call replace then we call to lowercase on that then split then joint Simien then split then

sort then join.

I think maybe as a quick little test we should copy this over to that little code editor and just see

how this thing works.

So back over here I'll make a short string let's say Konst as TR is b c r c d do a real example.

Hello there.

So then if I paste that snippet.

So here is string replace to lower case all that stuff.

This is what we end up with right here.

So if we then consider some anagram like let's say string two and this one is there.

Hello.

So these two are clearly anagrams of each other.

Remember we are completely ignoring any punctuation.

And so if I then do string two and then that whole chain loops let's clean that up.

There we go.

So now I've got two strings I can very easily compared to each other and in this case you can see very

plainly.

Yeah they've got the same characters in the same order so they must be anagrams.

However if I start to add in characters to one of the other.

Well this is clearly no longer an anagram because these two sorted strings over here are no longer equal.

So now the last thing do is to figure out how to actually do that comparison between the two strings.

So again you might be thinking OK we have to loop through one string and we have to compare every character

to the other string.

Well no it's actually a lot more straightforward than that.

We will call clean string will pass in string a and then we're going to make it take advantage of the

equals equals equals operator.

So compared the cleaned up string a string the end if the two are absolutely identical.

Then we must have an anagram.

So essentially what we're doing with this line right here is to compare these two strings together.

So of course if we wrote out let's do this actual statement if we wrote out is that equal to that well

then we get true.

So that's essentially what we're taking advantage of here.

We don't have to compare this in character by character.

We're going to say hey is this string identical to this string.

Yes they are.

OK well then we must have an anagram.

And of course last thing never forget it.

Don't forget that return statement.

Most important part.

OK.

So this is the alternative solution.

You know this is another one where once you see the trick once you understand OK we can split it into

an array sorted and then join it back together and then compare the two results.

This is a real easy you know maybe relatively easy solution to remember probably a little bit easier

than remembering how to build a character map on the fly.

So yet again out of so many examples that we've already seen in this course and so many that we will

see as we go through.

Once you've done these problems one time you learn that little trick and you'll be able to solve it

more easily in the future on an interview.

Now very last thing I need to save this file and we'll check our tests.

So back at the terminal it looks like all six Tests are still passing here.

Fantastic.

Great.

So this has been the anagram problem again.

Very common one that I would really expect to see in an interview setting.

Let's take a break and we'll continue to our next question in the next section.
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================


Раздел 10:Sentence Capitalization

32. Understanding Capitalization

The last problem that we worked on was a little bit more challenging.

So in this section we're going to go live take a little bit of a breather with a slightly more easier

problem or at least one that is certainly short in nature.

Not many lines of code are required for this one.

So inside of my exercises folder I'll find the capitalize directory and open up the index file inside

there or then change on over to my terminal and I'll make sure that my tests are running over here by

running the command just capitalize test.

J.S. dash dash watch and we should see about three or four tests start to run.

So it like yeah three tests right here.

So let's look at this problem.

Now this one is a little bit more straightforward but I think that it's one that appears at first glance

to be very easy but in practice it does require at least a little bit of thought.

So the goal is to write a function that takes a string.

We want to capitalize the first letter of each word in that string and then return the capitalized version.

So for example a short sentence which is all lowercase should turn into Kapolei short with the last

sentence with the capital S..

So essentially just capitalize the first letter of each word.

That's pretty much it.

Like I said at first glance it looks really easy but once you start pulling together well it might get

a little bit more challenging.

Now I'll tell you right now that there are two distinct solutions that we're going to look at this problem.

The first one is going to will say that the first I'm thinking of them out of order here but I'll say

that the first one that we're going to look at is pretty concise.

It's rather few lines of code and it's rather easy to read.

But that solution requires a pretty good knowledge of the JavaScript standard library for working with

strings.

The second solution.

The second one that we're going to look at is kind of easy to reason about but it does require a kind

of nasty looking for loop and it's kind of hard to tell exactly what's going on with it by just looking

at the code.

So I'm telling you right now that you can either take a slightly easier to read solution by having a

good understanding of the JavaScript standard library or you can take a slightly more challenging to

read version that just kind of brute forces it and makes it happen.

So before I let you go I do want to give you a little tip or two on how to approach that kind of easier

to read solution.

And I want to point out to you a couple of methods that belong to the standard library that you might

want to be aware of.

So the first method that we're going to look at and again we are at the India and India documentation

page is the slice method belonging to all strings.

Remember slice can be used on a string.

It will take some number of elements out of that string.

The first argument is the index of that string to start from.

And then there is an optional second argument of the end index.

If you don't provide that second argument right there then the rest of the string is just automatically

included.

So where would this be useful.

Well let me show you a quick example of it.

Let's imagine that we have a word of simply there.

If we do we're slice with simply one.

It gives us everything after the T.

Now if we wanted to get just the t we can look out word at 0 and now the part that you really need to

be aware of.

Remember we have access to the to upper case function like so.

So very quickly I think you can see how we can take a lowercase word like this and start to capitalize

just the first letter.

So here is clearly a capital T.

Here's the rest of the word and I'm sure you can figure out how to join those two together.

So these two methods right here will lead you towards a rather straightforward solution.

Again this is not the only solution you can take a little bit more brute force one and this but certainly

give this a try.

So I'm going to let you kind of roam free on this one.

Give it a shot and I'll catch you in the next section and we will go through the first solution.

So quick break and I'll see in a minute.
-----------------------------------------------------------------------------------------------------------

33. Capitalization Solution #1

OK hopefully you had some success with this problem.

Like I said you might have found that it is a little bit more challenging than it appears at first glance.

However I do hope that you came together with a good solution in the section we're going to walk through

one possible solution very quickly.

We'll then take a look at an alternate solution in the next video as well.

So for this first solution let's look at some pseudo code that will kind of guide us in exactly what

we're going to do.

We're going to start off by making an empty array that we're going to call words.

This word's array is going to store the end result of the final kind of capitalized words that we are

dealing with after we create this.

Words.

Empty array.

We will then take the original string that was passed into our function and we'll split it by the space

character to get an array of words.

So each of those words are what we're going to try to capitalize.

We will then loop through that an array.

We will uppercase the first letter of each word.

We will then join that first letter that is now capitalized with the rest of the word.

And then we will push the result into that original words array that we created at the very beginning

after we loop through each word.

We will then join the words array together into a string and then we'll return it from the function.

So that's the general idea here.

Let's give it a shot.

Back inside my code editor I'll get myself a little bit of space.

We will declare an array of words that's going to start off as empty.

We will then loop through our string.

So we do need to split it by spaces.

Remember if you split by spaces we can do so by.

Let's say we have Konst sentence and our string is something like.

Hi there buddy.

We can call a sentence dot split and then rather than splitting on an empty string as we have done many

times in this course we will split by a space character instead.

And so now we're working with three individual words.

And that's what we want to do here.

So we're going to save for.

Let word of string dot split with a space.

So now whatever string gets passed in here assuming it is a sentence that is split by spaces they will

be split up by this split statement.

Next we will take the first character of each word so word at 0 and we will uppercase it by calling

two upper case then we will join it with the rest of the word and we can get the rest of the word so

everything minus that first character by using the slice function.

So we'll say word dot slice with one which means give me everything from the element at index 1.

So that's not the first element that's the second element.

Everything from index 1 onto the last character in the word.

So we're going to join us to get two together and then we will push the result into our words array.

So I'll say words.

Push and push the results into that.

Then finally at the very bottom after we have iterated through all these different words we will take

that word's array we will join them together with the space character.

So note that again this is not an empty string.

Here we are joining all of these different words together with the space character.

We will make sure that we return the result.

So let's see how we're doing.

OK.

Three-Test passing looks good to me.

OK.

So like I said this is the easier I think or maybe the more direct easier to read solution of the two.

Let's take a pause.

We're going to come back in the next video and we're going to look at another solution that is just

a little bit more effort goes into it.

But it's one that I think is much more easier to arrive at or I think that one it's easier to kind of

picture the other solution.

It is harder to code.

That's what I mean to say.

So let's take a quick break and then attempt that solution in the next video.
---------------------------------------------------------------------------------------------------------------

34. How Else Can We Capitalize?

In this video we're going to take another look at the capitalized function and come up with a slightly

different solution.

So as usual I am going to back up my result here by copying it down to the bottom of the file and commenting

it out.

I will then clear out the contents of the capitalized function like so.

All right let's look at a diagram that's going to help us understand this alternative solution.

So here we go.

Cascio here's a serious sequence of actions this time around.

We're going to start off by creating an empty string called result.

So notice that in this case we're creating an empty string not an array.

We are then going to iterate through every character in the string for each character.

We will look at it and we'll say in the character to the left of the current one.

So whatever still left is that a space if it is a space then we're going to take the current character

that we are iterating over.

We'll capitalize it and we'll add it to the original result string.

Otherwise if it is not a space to the left of the current one then we'll just simply take the character

and added to result without capitalizing it.

So essentially we can imagine a string.

Say hi there.

When we look we iterate through this thing and let's say we look at the character eye right here.

We'll look at the character to the left of it.

That's an H.

It is not a space.

So we're going to say no problem.

Just add in to the result string.

We'll then move onto the space.

We don't care about the fact that this thing is a space.

We're going to look to the left of it see that there is an eye there and we'll say OK that's an eye.

We don't need to worry about it.

So we'll take this character and add it into result then we'll move on to t with t look to the left.

We'll see.

Oh you know what that is a space.

So we're going to capitalize T and then add it into the result string.

Now this solution right here has one very big weakness to it.

One very big weakness.

I'm going to ask you if you can kind of find it right now based on a description I just gave you.

The problem with this solution is that it doesn't work well with the very first character.

So when we are capitalizing a sentence the very first character should always be capitalized.

So if we try to look to the left of the first character well there's nothing to the left and so we will

never attempt to capitalize it even though it absolutely should.

So 8 easy way to solve this is to say that when we create this initial string result rather than creating

it as an empty string we should create result which is the first character of the input string capitalized.

So that's how we're going to get around that little limitation when we create this first result string

the very the only content it's going to have will be this first character or just going to immediately

capitalize it.

Then when we start to iterate through the rest of this array of characters here we'll start with the

first character or I should say the character at index 1.

The second element and consider everything from here moving forward.

So the downside to this approach is that it will require a manual for loop.

We cannot use a for loop in this case because a for loop is always going to attempt to iterate through

every character.

And in this case we don't want to iterate through every character we want to skip that first one.

So little bit of a downside here.

But such as the way.

All right.

So let's give this a shot.

Back over my code editor will first declare this starting string that we're going to call result.

So say let result and it's going to take the first character out of string and automatically capitalize

it because that first character we always want to capitalize.

So we'll say string at zero dot to uppercase like so.

Now we can iterate from one to the length of the string.

And for every character will look to the left of it and decide whether or not we need to care to capitalize

the current character.

So we'll say four letters.

I equals one.

I less than string dot length plus plus.

Now we'll look to the left.

We'll say if at string I minus 1.

So this is to the left of the current character.

If that thing is a space then I want to take the current character that we're looking at.

I want to uppercase it.

We have two upper case with a capital C and then I'm going to add that on to the result string by saying

result plus equals like so.

If the character to the left of the current character is not a space well in that case we want to just

add it on to the results string by saying string as I like so.

And now if you look very carefully at my function I'm missing the most important parts.

The return statement down at the bottom don't forget it.

So will return results.

All right let's look at our terminals.

Our tests are doing looks good to me.

So yeah this looks like a reasonable solution here this solution.

I'm not super happy with personally because it is kind of weak against you know assuming that that first

character always needs to be capitalized.

You know what if for some crazy reason we are attempting to capitalize a Spanish string or something

like that.

You know I say Spanish because they've got you when they do a interrogative sentence they start off

with a question mark like you ok tall like so.

So clearly in this case that first character we wouldn't really want to capitalized because it is a

question mark so you know but hey I'm not I don't think we can really clear claim that this solution

would address that as well.

I guess I'm just not super happy having this thing being hardcoded to always catalyze the first character.

I don't know just kind of natural engineering judgment.

I feel like it's a little bit off anyways.

At the end of the day I would still claim that this solution is harder to take a glance at and really

understand what's going on.

I think that the solution right here.

The first thing we worked on is very legible and I think that it would be pretty reasonable to hand

this solution to an engineer.

Ask them what is going on.

And I think they'd be able to give you a reasonable answer as to what's happening here and I don't think

that's really the case with the solution up here.

But hey to each their own.

OK.

So that's their solution to the capitalized sentence function.

Let's continue with our next example in the next section.
----------------------------------------------------------------------------------------------------------
==========================================================================================================

Раздел 11:Printing Steps

35. The Steps Question

I'm really excited for this next problem because the next problem we're going to work on is very closely

related to the one after that.

So we're going to have two questions in a row that are extremely closely related.

The first version is going to be kind of a easier version of the problem and then the second one is

definitely much more challenging in my opinion.

So we'll get kind of like the warm up and then the real deal immediately after that.

Now even the warm up is still kind of a hard problem and it is also definitely a problem that I think

is very common to see our interviews.

So they're both very useful but it's going to kind of prep us for the tougher ones.

So I think it will be a nice little build up.

So inside my code editor I'm going to find the steps folder and then I'll open up the index file inside

there.

And I think you know exactly what else we need to do.

We'll start up our test with steps test Scott J J.S. dash dash watch lifeso and we should see a number

of tests running in this case about four by the way just to clarify the reason I always point out the

number of tests is just to help you make sure you don't make a typo in like you know the test file name.

If I do a step slash test dodgiest then it's going to say Oh hey I can't find any tests to see you know

that's why I always happen to mention that.

Anyways let's take a look at this problem.

So the directions are to write a function which is kind of already done for us that take an argument

of a positive number.

Or in this case really an integer n so some positive number the function should then cancel log.

So key statement there we need to console log a step shape whatever that is with and levels using the

pound character.

So in practice you know the directions are kind of hard to read.

It's a lot easier to just look at the examples right here.

Basically is what we want to do.

So if we call steps with two I want to see like pounde and then on the next line pound pound and so

they're supposed to kind of form a visual staircase you know where the steps are the actual pound symbols

here.

That staircase is a little bit more evident on some of these larger number ones down here so like you

know first step second step third step fourth step the number just to be clear is the number of lines

that we want to log.

So we pass into I want to see two lines of steps we pass and three we've got step one step two step

three.

The other thing that is extremely important and the other thing that makes this problem a little bit

more challenging is the fact that we if we have like just one step right here out of two total there

has to be a space character to the right of it.

See there's a space character right here with Steps 3.

We should have a pounds and then one space and then two space.

So you can very easily kind of quickly realize that the number of characters in the strings is always

going to be square.

So we've got three console logs down for end of three and we have three characters from left to right.

So character one character or two in character three that's really important.

Don't forget that if you only log out just the bare minimum here of just the pound symbols the tests

are going to fail so the tests specifically want to see the correct number of empty spaces to the right

hand side.

And that was important because like I said the next problem that we're going to work on is very closely

related.

And the next problem is going to kind of build on this idea of making sure that you actually print out

your steps here.

So make sure you do that.

OK.

So that's the problem.

In this case I think that this is one that really just requires a little bit of thought on your end.

So there's not necessarily any big tips I want to give you ahead of time.

I'm going to I'm just going to let you give this one a stab.

Remember that much earlier in the course we walk through the technique of placing a debugger statement

so that you can kind of work with your code and see what it's doing.

And remember the directions for that are in the diagrams for this course.

This is a problem where I very highly recommend you use that debugger technique if you get stuck because

it's going to be really easier to help you figure out exactly what's going on as you run through your

code.

So let's take a break here.

Give it the best shot you can.

Remember if you get stuck.

Don't sweat it.

Just go solution Watch a minor to the solution and then take another stab at it on your own.

So quick break and we'll go over the solution in the next video.
--------------------------------------------------------------------------------------------------------------

36. Steps Solution #1

All right hopefully you had some success with this exercise.

One quick thing that I want to mention here is that the intent was that you should be making multiple

console log statement calls.

So we are not assembling one string and then escaping it with like a newline character at the end.

We are making multiple strings and cancel logging each of them.

When I say multiple strings I mean one string for each kind of set of steps here or each level to the

staircase.

So if you saw some error message saying Hey I expected you to call stairs more often or something like

that that's probably why you were seeing the message.

Make sure you are logging each independent level.

OK.

So in this section we're going to go through one possible solution.

I think that this is definitely the easier to come up with solution that we're going to go through first

after we look at this solution.

We'll then take a look at an alternate way of solving this by using a little bit of recursion.

I think that the recursion solution here is ultimately maybe a little bit easier to come up with and

put together.

However it does require to kind of use your recursion skills to think of which is definitely quite challenging.

So anyways we'll do the iterative solution first and then take a look at the recursive solution.

So let's look at a diagram that's going to help us understand this iterative solution.

So the first thing to recognize here is that we are kind of dealing with a matrix of sorts or kind of

like a to d array.

We're not really working with the race here.

We're always working with strings.

That's what we are assembling.

But it's helpful to just kind of think of it in terms of like indices.

It's going to make it a lot easier to come up with the actual solution.

So here's the idea.

First we want to recognize that we're going to have some number of columns in the rows that we want

to iterate through.

So this would be row one right here and then row 2 and row 3 and then we are also kind of going to want

to iterate through some number of columns so call them 1 call 2 and column 3.

I came up with the nomenclature saying that we will reflect the current row that we are iterating through

with a variable that we're going to call I.

And then the current column with a variable that we're going to call J.

One very easy way to make your solution look much more straightforward and you what I think that we'll

probably end up doing this rather than calling is i and j.

Because that's kind of tough to remember.

Let's call this like row and column that makes life a little bit easier.

I think that's going to be a little bit better.

OK.

So then mind let's take a look at exactly how we're going to do this.

First we're going to write a for loop the first for loop that we're going to write is going to iterate

through all the different rows that we have.

We're going to iterate from 0 to N and we'll call this you know we'll say specifically iterate through

rows then for each row that we are considering.

So let's imagine this particular row right here.

We are going to start off by creating an empty string that we'll call stare.

Now Syria is meant to be singular like just stared by itself to indicate that this is one individual

row that we're looking at.

Then we're going to iterate from 0 to and again in this case this second for loop right here is meant

to iterate through all of our different columns.

So from left over to right then inside this inner loop will say if the current column that we are looking

at is equal to or less than the current row we want to add a pound.

So this is kind of like the big jump in logic right here.

This is kind of tough part is this if statement.

So I want you to look very carefully at this thing right here.

We have columns 0 then column 1 column 2.

Let's add a little bit of numbers on here just to make that all that easier.

So do a copy so we'll say see 0 meaning column zero.

I'll put that right here and then we'll put rows 0 right there and then I'll just do two others with

this nomenclature we'll put our one right here.

We'll put still sees zero right here because we're still in column 0 and then just one more we'll put

Rozier show over here and see one right here.

So when you start working on these problems where you are kind of iterating through two sets of rows

and columns especially I honestly I want to use more generic terms but any time instructing in terms

of row and column you want to start seeing if you can see a pattern of any sort here.

And so if I start thinking about a pattern between which of these squares or which these characters

are supposed to have pound which are supposed to have a space.

The first thing they start to notice is that we want to have a pound.

If C has a value that is equal to or less than R and we can see that in a very quick action here.

So C is equal to our.

So we get a pound.

In this case C is less than our So we get a pound.

But over here C is greater I said poun excuse me C is greater than our row.

So we get a space instead and that's the pattern that we're following all throughout this thing.

So even when we start going down to the very bottom right corner down here.

So down here we would be working with column two and road 2 right here.

So still we are less than or equal to the row count.

So we're still going to get a pound down here.

So that's basically the row that we're going or the rule excuse me that we're going to use if we do

not meet this if statement right here.

Dan Rather than adding a pound we must be on this kind of upper right hand triangular section up here

in which case we want to add a space rather than a pound and the last kind of Keats.

The problem here is that after running through this for loop where we iterate through all the different

columns we will take that stair or that kind of row representation of this one line that we have and

we will con. log it.

Then we go through the next iteration or move onto the next row we're going to read it clear that Stehr

variable as a new empty string.

So that's very much the solution.

Again this is just one possible solution.

There's definitely more than one way of doing this but I think that this is a relatively straightforward

way of doing it.

So let's take a quick break right now.

We'll continue the next section l put together the implementation for this solution.
------------------------------------------------------------------------------------------------------------

37. Steps Solution #1 Continued

In the last section we looked at one possible solution to the steps problem and this section we're going

to start to code up.

We'll get through this solution pretty quickly and then we'll move on to an alternative solution that

I think is a little bit more interesting in the next section.

So let's get through this one.

Now I want to use the steps that I've written out over here so we can very easily read through them

as we put together the solution.

So I going to kind of place my Windows ever so slightly so you can see both them at the same time throughout

this course.

You've seen me put together several diagrams like this that kind of use pseudo code to walk through

a solution.

I hope that you're definitely getting a sense of how you might put these together yourself in an interview

setting.

Anytime you're in an interview setting especially at a white board I highly highly recommend.

I can't say enough.

I highly recommend you try to write out a possible solution with pseudo code or like basically plain

English before attempting to code it on the white board.

When you use pseudo code pseudo code to outline your solution it's going to more easily communicate

what you're trying to do to your interviewer and your interviewer might be able to help you catch errors

rather than if you went straight into a code solution and they're both helping you try to catch errors

but also understand what the heck you're trying to write with code.

So in general I highly recommend you try writing out a pseudo code solution.

All right let's give this a shot.

So we're going to start off first by iterating from 0 to N and this is intended to be the current row

that we are operating on where row is like one string set OK.

So we'll say four let row equals zero row less than an ROE plus plus.

And then inside of here for every different row that we are going to operate on we're going to create

a completely empty string.

A brand new string that we're going to call stare.

Now we could call Stehr anything else.

Honestly I just you know maybe you would be better to call it step or something.

I thought Sarah was still reasonably related to the problem but different enough from the function name

of steps like steps and step there a little bit too close.

So I would definitely not you step personally so we'll say let's stare because going to be an empty

string.

Next we're going to iterate from zero to N and this is intended to be our iteration through all the

different columns that we're going to work on.

So for left column starting at zero column less than n column plus plus.

So for each column we're going to write an IF statement we're going to say if the current column that

we're looking at is equal to or less than the current row.

So if the current column is less than or equal to the current row then we want to add a pound symbol

to the stair string.

So we'll say stair plus equals pound.

If column is not less than or equal to RHO then we're going to instead add a space.

So else stare plus equals space and make sure you have a space here not an empty string.

It is supposed to be a space.

Make sure you have a character inside there.

Finally after we process one entire row.

So this is the row processing step right here we have processed the entire row.

We have now assembled a full stair string.

We need to make sure that we can still log it it's console log Stehr make sure that you are logging

Stehr still inside of the road for a loop because we want to end up with an number of console logs like

in the case of passing and for here we want to end up with four console logs.

So I don't want to put the console log at the very bottom of the function.

I want to still be inside of my for a loop so that I get one console log for each row that we are attempting

to assemble here.

OK.

So this looks good.

Let's save this we'll run our tests and see how we're doing.

So back over here in my terminal you can see that we got a lot of the console logs from the testing

code and I've got four test passing which definitely makes me feel like we've got the right solution.

So this is looking pretty good.

This is one possible solution.

If you are in an interview setting this is probably a type of solution.

I recommend you go for.

It's very easy to reason about.

It's easy to troubleshoot.

Pretty reasonable.

Having said that we are going to look at an alternate solution in the next section that uses a little

bit of recursion.

This next solution is going to be a little bit more tricky and just because it is tricky I generally

recommend not going straight to the solution.

In an interview setting unless you are specifically asked for a recursion solution nonetheless we haven't

spoken a lot about recursion yet inside this course.

And so this is going to be our first good taste of recursion which is a topic that we'll be discussing

a pretty good amount throughout the course as well.

So let's take a quick pause and then start to tackle that second solution in the next video.
---------------------------------------------------------------------------------------------------------------

38. Step Up Your Steps Game
In the last section we looked at an iterative solution to the steps problem in this section.

We're now going to continue by looking at a recursive solution to this.

Now if you're here in this course and you're preparing for a professional javascript interview I am

going to assume that you have seen recursion before at least once.

Nonetheless we will do a very quick review just to make sure that we are on the same page.

Well then look at a couple of general tips around recursion and then we'll come back to this problem

and figure out how to tackle it.

So let's do a quick review first with recursion.

We always start off with some type of function.

So let's imagine we've got a function called about print number about that.

Let's imagine that we want to make a recursive function called Print number.

We should be able to pass this function a number and it will print from that number down to zero.

So we'll assume that we always pass the thing a positive number.

Let's write out an example of that.

So let's pass it like the number 10.

So I'll say that to succeed in this problem.

I want to see a console log from 10 all the way down to 1 or 0 1 and the other.

And the first thing that we always do with a recursive solution is to identify what is called a base

case the base case is the case in which we decide there is no more work for us to do.

And it's time to return and stop the recursion process.

And so without even thinking about the term base case or anything like that.

Think back to the description of this function I just gave you two seconds ago I said we want to print

from whatever number is passed all the way down to zero and then at zero we stop and we do no more work.

So to think of a base case in this situation I would say that if the number that is being passed to

this function right here is equal to zero.

That means there is nothing else we need to do.

We have hit the base case and we want to stop recursion.

So let's write that in here.

Let's imagine that print number gets called with some number and as an argument we will check to see

if n is equal to zero.

And if an is equal to zero then we are going to return and we're going to do no more work during the

recursion process.

Nailing your base case like this is one thing that is absolutely critical during the recursion process.

I really encourage you to spend a lot of time in general thinking about your base case.

It's way too often that people start to think about the base case only at the end.

And if you think about the base case only at the end Well usually it means that if you try running your

function before then you'll end up in a infinite recursive solution which is always nasty to try to

debug.

So we start thinking about your base case from the get go after checking to see if we've met the base

case.

We will then do some amount of work and then call our function again.

So in this case the work that we want to do is to print out the current number.

And so I'm going to print out with a log.

And then the last thing to do is to call our function again when we call the function again.

It's extremely critical to make sure that we have changed the arguments in some fashion.

If we call print number again with an We're going to immediately and are seemy we're going to enter

an infinite loop because we have not changed the arguments and the exact same code path will occur.

So I'm going to be 100 percent sure that I would to change the arguments they're going to call print

number with here.

I'm going to make sure that the change that I'm making will somehow eventually get r r and number here

down to zero.

So specifically I mean to say I want to make sure I subtract 1 or subtract some type and number.

OK.

So when we call print number again and this of course right here is the actual recursive step because

we are calling the function that defines that this function call is defined in again then we see our

numbers printed out here.

Now you will notice that you see two if you're using this tool or if you're just looking at my screen

you'll notice that we get two sets of prints from 10 down to 1.

That's just because of the way that this tool right here behaves.

The code that we have is 100 percent correct as just because the way that this tool works to make stuff

print out nicely that you see the log out here twice.

OK.

So what are some takeaways that you can immediately notice about recursion from this process right here.

Here they are.

So the first thing that we really want to do is to identify the bare minimum pieces of information that

represent what we are trying to accomplish.

So in this case the bare minimum of minimum piece of information that we want to pass from loop to loop

or from I should say call to call a recursive function is the current counter.

I did not pass along some extra piece of information like what the number was the last time it was called

or some object that we're not doing anything with.

I identified just the bare minimum information that was needed to call our function again and progressed

towards our base case.

The next thing to keep month recursion is to always give yourself some reasonable defaults to those

minimum pieces of information.

So in this particular case we had said that we were going to provide the number and then always subtract

1 to get towards our base case right here.

But let's imagine that maybe we had said well maybe an additional requirement of the print number function

was that it should be to be called with some number to decrease and by each time.

So in other words maybe we don't want to always decrease by 1.

Maybe we want to decrease by some other argument here that you know me we'll call mentor or something

like that.

So this second step right here giving reasonable defaults make sure that if there are any optional inputs

you give some reasonable default input to them.

So in this case I would want to maybe default the value of deck to be one.

And then I could very safely use it down here.

Print number and even if someone didn't pass in that debt variable or the deck value.

I've got some reasonable default to make sure they don't accidentally fall into some infinite recursion

situation right here.

For example I can very easily show you if I were to I'm not going to because my browser would lock up

but if I were to delete this declaration right here of deck or if I were to not default it to be one

then every single time we called Print number we would take an minus deck.

Deck would be undefined.

If I didn't defaulted to be one and would we would then call print number again and would probably be

like not a number or something like that.

And so we would never hit the case where an equal zero in return.

So make sure you have some reasonable default in here to safely handle your recursion.

The next thing to do during the recursion process always remember to check that base case inside the

base case you want to see is there anything left for us to do.

If there's no work that's it we're done.

OK.

Don't color function anymore and return if we do not meet the base case then we want to make sure that

we actually do some work.

We call the function again and when ever we call the function again this is a really important part

when ever we call the function again we want to make sure that we have changed our arguments in some

fashion.

The arguments have to change if they don't change.

That means that we're very likely going to end up in an infinite recursive solution which is again something

we don't want to deal with.

OK.

So with all this in mind let's take a quick pause.

We're going to come back to the next section and we're going to apply these rules right here to the

steps problem and we're going to come up with a recursive solution.

So quick break and I'll see you in just a minute.
---------------------------------------------------------------------------------------------------------------

39. More on Steps
In the last section we got a very quick review of recursion.

Let's now take some of these lessons right here and apply them to the steps problem at hand.

So I've taken one of the diagrams we were looking at previously and I pulled out some very interesting

pieces of information.

My goal here was to identify the base case and I also wanted to identify the remember bare minimum pieces

of information that represent our problem.

So let's take a look at some of these different notes that I made right here.

OK.

So the first big note right here is our base case.

So if we imagine that we still have some row counter that we're going to pass during each recursion

step then if we increment row each time we kind of progress down here when ever row is equal to N and

member and was deciding how many steps we have in total then that means that we have hit the end of

our problem.

So this was something that we noticed with our Interesse solution as well.

Remember we had the for loop where we iterated from an up to or something from 0 up to N and as soon

as we hit that we said okay that's it.

No more work for us to do.

So essentially I think that our base case here is to say if we have some row piece of information that

is being incremented from 0 to 1 to 2 and eventually to 3 as soon as we hit 3 that means nothing else

for us to do.

Now the next kind of interesting note that I made about our interim solution here was I noticed that

the stair string remember the stairs string kind of represented a row and all the elements within that

row.

If that row has a length of N So RHO means length of and or a stair string has a length of.

And it means that we are at the very end of the row and we are ready to print or do console log out

that row.

So if we have a string with one element to element 3 element inside of it three is equal to and equals

three.

That means that the stair string is ready to be printed.

Now the last very important note here is that if the length of the stair string so if the length of

the string that is being used to generate or it's that string is being used to represent the row here

has a length that is equal to or less than the current row that we are working on.

Then we want to add in a pound.

Otherwise we're going to put in the space.

We saw this exact same thing just a moment ago when we were looking at our iterative solution.

So remember back over here we had said that we had that inner for loop we had the inner for loop that

iterated through our list of columns and if the column counter that we had inside there was less than

or equal to the row counter then we would use a pound sign.

Otherwise we would use a space.

The interesting thing about this solution right here is that you can kind of very quickly tell that

this for loop right here.

It was made to iterate from 0 to an but we actually have another piece of information inside of that

interim solution that mirrors or kind of encodes that exact same counter the length of the stair string

right here the length of it was always equal to the current count column that we were iterating over.

So back here we were looking at the column counter to decide whether or not we wanted to use a pound

or a space but for our recursive solution we're going to instead look at these stair string to decide

whether or not we want a pound or a space.

OK.

So these are the three big things that are going to help us put together our recursive solution.

So we're now going to flip back over to our code editor and we're going to put this thing together.

Now as we write the code for this we're going to kind of speed through the implementation because honestly

writing out recursive stuff is challenging to explain to say the least.

So it's more important that you understand these kind of base cases right here and that you get a sense

of how to kind of discover these on your own once you can think of your base case life gets a lot easier

and you can start to put together this implementation.

So anyways let's just put this thing together and see what it looks like.

So back inside my code editor I'm going to take my whole steps function I'm going to copy it.

I'm going to put it down at the bottom the file and comment it out again just so I have a nice little

backup then scroll back up I'm going to clean out the steps function.

So it's now empty.

All right.

So the first thing we're going to do here is we're going to define our base case and we're going to

check to see if the base case is satisfied and if it is we will return.

So I'm going to check to see if n is equal to Roe and if it is I'm going to immediately return now.

Right away you'll notice that there's no variable inside of your called row.

So let's say that every single time that we call the steps function one very important piece of information

that we always want to pass along to every function call it steps is the current row that we are operating

on.

So as an argument to the steps function I'm going to add in row now the first time that steps gets called

we can assume that we called like that steps of three.

Remember that is exactly what the directions up here said it said Write a function that accepts a positive

number.

And so I'm kind of arbitrarily deciding that there is an additional argument I want to add into this

function call.

Now just like we saw a moment ago over in the code editor over here we need to make sure that if row

is for some reason not defined in our function call we need to give it some default argument.

Otherwise we might get some really unexpected behavior.

So to handle it first time that steps is called Where presumably Roe will not be passed along.

I'm going to default the value of row to zero.

So this means right here I want to start on the very first row where the top row of our problem.

OK.

The next thing that we're going to do is we're going to examine our second case.

The second important note here this one right here we're going to write in some code that checks to

see if the length of the stair string is equal to a length and be equal to the variable and if it is

then that means that we are at the end of the row and we should probably print out the stair string.

So the next thing we'll do back over here we're going to check to see if an is equal to stare length.

And if it is then we need to assume that we are at the end of this particular row.

And we should print out the stair variable.

Now again you will notice that we have not yet defined stare.

So satyr is another piece of information that I really think that we need to share in between function

calls.

So as an additional argument I will assume that we are going to call this thing with a stare argument

and I'm going to give it an initial default value of an empty string.

So by default nothing is nothing is inside of stair.

Now the only thing we have to take care of now is figuring out how exactly we are going to decide to

call steps again in the future and how we are going to make changes to stare and row.

So at some point in time we need to increment row right here.

And at some point time we need to add a character onto stair.

I can ask you a question here.

When do you think we need to increment row row needs to be incremented when we hit the end of a row

like when we have completed a stair and we just wrote an if statement for that right here.

So when ever we have hit the end of a row we're going to cancel log out stare and then we're going to

call steps again but this time around we're going to increment the value of rho.

So after we hit the end of the stair we'll console log stair and then we'll call steps still with N

but with RHO plus 1.

Now you'll notice that I'm not going to provide a third argument here because when we move on to the

next row I want to use an empty stare again and song and rely upon the fact that we are using a default

Stehr value of empty string here.

I could very much just as well do something like this.

You know I could pass an empty string manually but it's not necessarily necessary because we've already

got this default value set up here.

Now the other thing to keep in mind is that if we hit the end of the row as indicated by this if statement

and we Consolo this thing and we call steps again we don't want to do anything else inside this function.

So if we meet this case right here there's nothing else we want to do.

So when I call steps right here I'm going to make sure that I just return right away.

Now we don't necessarily have to return the value of steps that's not necessary.

You know if we wanted to we could put return down on the next statement because we are not returning

anything here per se.

I just want to point that out.

Not really important either way.

Just one thing to keep in mind.

OK so we've handled the case that we have completed all of our work.

We've handled the case where we've hit the end of a row.

The last thing we have to do is handle the case in which we are still assembling our stair string and

remember the big thing to keep in mind for that was that if the length of the stair string is less than

or equal to the row that we are currently working on we're going to add a pound.

Otherwise we're going to add the space.

So for that we can add in a little if statement will say if stair length is less than or equal to Roe

then we want to add a pound onto stair so we can say stair plus equals pound.

Otherwise we want to add a space like so now the very last thing keep in mind here the last line of

code we need to write.

Notice how the only points and right now that we do any type of recursion is if we've hit the end of

a row but we still need to make sure that we recurse through a row as well.

So after we have appended on some character to the stair string We then need to call steps again and

that's going to start the entire process over again.

So after we do that statement we will again call steps we'll pass and we'll pass and row and notice

that we are not going to change the value of Roe here because we are still working on the same row.

And the last thing we'll do is pass and stare.

Okay.

So I know this has been a little bit complicated but I think that if you really think through these

steps they make a lot of sense.

The problem with recursion is that arriving at which steps to put together is really challenging.

You know this is the kind of thing where you when you see the solution you can go like oh that makes

sense.

But before you see it it's the hardest thing in the world.

And that's why recursion is kind of the story is difficult to pick up.

All right let's do one last run through here.

So the first some we call steps and I'm going to move steps 3 up here by the way make sure you get rid

of that don't want to throw off any tests.

So make sure you dump that statement.

So the first steps we're going to have and of like 1 2 three four 5 whatever it might be will have a

roll of zero.

We'll have a stair of empty string.

So a 0 0 empty string is an equal zero.

No it's not because and is equal to 1 2 or 3 or whatever is an equal to stared at length.

No it's not because there is still an empty string.

OK.

Well don't go down here is stared at length less than RHO will start at length zero RHO is equal to

zero.

So yes it is equal to or less than.

So we're going to add a pound to stare.

We then call steps again.

So we go back up to the top again we have and of one two or three whatever it is we have a row of still

zero.

But now Stehr is a pound.

This case doesn't apply.

This case doesn't apply.

We hit here again Stehr Now now has a length of 1 1 is not less than or equal to Rho.

So we fall into this case here.

We add on a space to stare and then we call steps again.

So at this point in time Stehr is now equal to pound space RHO is still equal to zero and is still equal

to 1 2 or 3 or whatever.

So this no longer not not relevant not relevant.

We hit here again stared at length will be too.

So we fall into adding a space again we call steps again.

We now add on an additional space and this is the last step we'll go through right now.

We call steps again.

We have let's say three in this case RHO is still zero Stehr is now pounde space space.

We checked to see if and is equal to a row.

No it's not.

We checked to see if N which is three is equal to stared length which is three.

Yes it is.

OK.

So we console log out stare.

We then return from this function.

So we do no other work inside of here.

We call steps again but this time steps is now have steps of an equal to three and RHO is now moved

on to one.

The entire process repeats until we hit this case again and then eventually RHO is incremented up to

three.

We checked to see if any is equal to three.

It is.

And so we return here.

All right.

So that's a full run through.

Yeah recursion is real nasty.

Like I said earlier my big tip to you.

In an interview setting if you get asked anything about recursion try to put together the solution first

and then look to refactor it over to recursion it will make your life easier.

In fact when I put together this recursive step solution right here that's exactly what I did.

I put together this eritis solution.

I looked at which variables were changing and then I realized OK like we can probably do at x y z and

I identified that base case and it made life a lot easier.

If you asked me to put together this recursive solution from the get go yeah I would have a tough time.

Probably like most other people in the world.

So I really recommend if possible you try the solution first just to get your mind in the right place

and then go to the recursive solution.

Now lesing I want to mention here.

Completely optional.

But if you wanted to we could definitely shorten this statement down here with a little bit of a turner

expression.

So this is totally optional.

This is 100 percent equivalent syntax spital just kind of condensed down our solution.

We could say something like Konst add equals square dot length less than three goals to row.

And then if this expression right here is true we would assign a pound to add.

Otherwise we would assign an empty string to add and then when we call steps we would pass and stare

Plus at.

So in this case add a short for like character to add.

OK.

So I think that's the only factor that I kind of want to do here to shorten things up.

And of course I bet we could maybe shorten up one or two things here beyond this but I'll leave that

up to you.

OK.

So that's pretty much it.

That is our recursive solution.

We will look at recursive recursion again in this course several times.

Again I can't say enough.

It's one of those things where you just have to see it many many times before you start to get a feeling

for yourself.

Now I did forget to do one thing.

I'm going to check my tests.

Yeah they're still passing.

So we're all good there.

OK.

So I think that's enough on recursion.

Let's take a break and continue on to our next problem in the next section.
------------------------------------------------------------------------------------------------------------
============================================================================================================

Раздел 12:Two Sided Steps - Pyramids

40. Pyramids Vs Steps

The next problem that we're going to work on is going to build directly off the steps problem.

So we're going to take care of it right now while we still have the steps problem fresh in our mind

inside of my exercises directory.

I'll find the pyramid folder and then open up the index file and then of course will also start up our

tests as well.

So at the command line just a pyramid pyramid test Geass dash dash watch.

And let's see how many tests we have.

All right.

So now you got about four tests running.

All right let's take a look at this.

So we're supposed to write a function that accepts a positive number and the function should cancel

log a pyramid shape with an levels using the pound character.

Make sure the pyramid has spaces on both the left and right hand sides.

So this looks very similar to the problem we just worked on the steps one.

However now it's not only one side that we want to put these kind of spaces on both sides.

So we are now forming a pyramid shape.

So definitely you can very quickly see why this is very much so similar to the problem with it we just

worked on the steps one.

So methodology will be very similar but now it's going to be up to you to kind of figure out some very

interesting edge cases around this one.

So I'm going to give you a little bit of a head start here.

Beyond the fact you know saying obviously go back and look at the code from the steps problem we're

going to look at a diagram that's going to kind of help you focus in on a couple of different areas.

So we looked at one diagram very similar to this for the step problem.

This time around I've kind of removed some information and changed some stuff around to accommodate

the differences for pyramid.

So I think that the general algorithm that we used for the solution for steps is still going to work

here.

So I think that we should still iterate from 0 to n so and here being the total number of rows that

we have.

So we'll start off at 0 1 2.

Then for each of those rows I think we'll still create an empty string.

But now things start to get really interesting is that inner for loop.

So we're going to iterate from 0 2.

I don't know if you're going to have to figure that part out.

That's going to be one of the challenges here.

In addition once you figure out exactly what balance you want to iterate to for that inner for loop

you are also going to have to do some very interesting logic to decide whether or not the given column

should have a pound.

So remember previously it was a pretty easy determination for us before when we were doing the steps

we said if the current column is equal to or less than the current row yes we want a pound.

So this time around it's going to be a little bit more involved than that.

I'm going to leave it up to you to figure out exactly how to do it.

One tip that I will give you just so you are aware that this exists.

And I really want to just give you a quick example of it.

Remember that math floor is a function.

So if you use math floor it will take a decimal number and it will rounded down to the nearest integer.

In this case 5.

So I don't know maybe they'll be helpful for you depending on how you tackle this.

Maybe it won't.

I just want to remind you that that function exists.

So that's what you're going to have to do.

You have to do a little bit of work to decide whether or not a given column should have a pound.

Otherwise everything else is going to be pretty darn similar.

Now I do want to focus on one thing here.

Remember previously and was determining the number of rows and columns but like we just said now that

enter number or that inner for loop or the number of columns is going to be not exactly identical to

three.

So this is an accurate diagram for and 3 because we have three rows here.

But you can see that there's clearly more than three columns.

And if we start to think about the different pyramid shapes that we might have you know put some of

them together here.

Here is the pyramid shape for any equals two.

This one has three columns years and equals three.

This one has five columns and we can go to any of those four and this one has seven.

So in each case here you can see that the number is changing.

Yes it's changing by two each time.

But you know I'll leave it up to you exactly how to calculate it.

So just keep that in mind anyways.

Give this a shot.

Obviously again you draw upon your experience from the steps problem quite a bit as you're working on

this one.

I will say that we are going to go over the iterative solution first.

So I recommend you put together the iterative solution first and then we'll take a look at the recursive

solution after that.

So if you want to just do one or the other totally fine.

I leave it up to you anyways.

Quick break.

Give it a shot and we will look at a solution in the next section.
--------------------------------------------------------------------------------------------------------------------

41. Pyramid Solution #1


In this section we're going to start to look through the iterative solution to the Paramount problem.

So let's get started.

Now the first half of this solution is going to look very similar to the steps one.

So we want to make a for loop that's going to iterate over each row of our output.

So very similar to what we did before.

Well write a for loop and iterate from row equal to zero row less than an ROE plus plus.

So that will take us from row 0 all the way up to and minus one for each row that we create.

Just like before.

We'll make an empty string here.

Now previously we call this empty string something like steps or something like that.

This time around just because we're working with a pyramid I'm going to call this string level to represent

a level of the pyramid.

If you want to go with stair steps or whatever we use totally fine there is no difference.

Now inside of here is where the real magic begins.

So this is where things start to get a little bit different from our initial steps.

Solution in sight here we want to iterate over all the different columns inside of our pyramid.

And like we said at the end the last video the number of columns is not equal to N like it was before

with steps.

So this time around we have to say somehow produce four.

And he goes to we need to get three columns for any equals three we need five and so on.

Now one thing I would really caution you against really try not to look at the relation between each

of these levels here like we're not trying to really derive a pattern from three going to five because

you could very quickly be thinking OK I just need to like add to to something every time.

And that's not correct.

We don't want to think about the difference in rows.

Irks me the difference in columns each time.

We're really trying to think of is how N is related to the number of columns.

So I don't want to compare three to five and try to figure out some pattern there.

I want to look at two to three three to five and four to seven and try to figure out some combination

or some pattern between each of those pairs of numbers.

So the relation between these you know there's not a super easy way to lead into this I'm going to tell

you what it is essentially the relation is we're going to take in we're going to double it and then

subtract 1 and that will give us the total number of columns so we can test this out very quickly in

our heads.

So two times two is four minus one is three.

So that works out two times three is six minus one is five.

So that one's good.

And then two times four minus one is seven.

So that's pretty much it.

We're going to iterate from 0 2 to two times and minus 1 and that will give us the correct number of

columns.

All right.

So back over here we'll write out our inner for loop will save for left column equal to zero column.

Less than two times and minus one column plus plus.

Like so OK.

So this will take care of our correct number of columns.

Now very quickly we start to run into the next big issue.

So previously when we worked this problem when it was all about steps we had a very clear and easy comparison

to make.

We had said that if the current column is equal to or less than the current row we should add a pound.

But this time around it's way different we've got a much more complicated calculation going here.

And really I'm not sure how much we can just do a very simple comparison between the two to figure out

what to do here.

In particular in this case we have some like range in-between here that we need to somehow figure out.

So this is another location where the math starts to get a little bit hairy.

Let's do a quick code up over here and figure out exactly what we need to do.

So essentially going from 0 1 2 3 4.

So from values 0 1 2 3 4 we need to make sure that number two or kind of value.

Number two in there gets a pound.

So I'm going to kind of make do a little pretend over here.

Let's say our columns are 0 1 2 3 and 4 and then our ROE.

Let's get some identifiers here.

Our row at this point is zero.

So I need to somehow relate these two sets of numbers together to make sure that I somehow can pull

out a pound for this index right here and spaces for these other areas.

And then if RHO was one then I would want to make sure.

So just to be clear that would correspond to this second row right here if RHO is equal to 1.

So in that case I would need to make sure that I can somehow produce a pound here a pound here a pound

here.

But then space's on the ends and then of course for RHO equals two.

Everything needs to be a pound.

So we need to figure out some relation to essentially generate that kind of stuff.

So here's my thought.

I think that what we can do is calculate the midpoint of our array right here.

So we'll calculate the midpoint.

Like what is the very center index of this thing.

If we can figure out the center index then we can say that take row number of elements on either side

of that Centerpoint and make those into pounds.

So with words that's really confusing.

So let's look at what this looks like in practice.

So first I want to get the midpoint of columns right here to get the midpoint in and when I say midpoint

I'm typing it like the index.

So in this case I had one index of two.

So I need to somehow turn zero one two three four or five into two.

So essentially you know let's just get to the point here.

Essentially we can do math.

Floor two times and minus one and then divide that by two.

Where and is the number of elements Hursey the number of total rows that we're working with.

So if we wanted to only consider the actual number of rows here it would of course be we're dealing

with five elements divided by two and then we'll take math top floor of that and that will give us a

second element to Spickler that two times and minus one.

I made a mistake right there this is the final solution.

I didn't mean to go that far forward.

Let's just forget we saw that and just think about five divided by two.

So now we can think of two and zero elements on either side should also be made into a pound as well.

So only element 2 in this case should be made into a pound.

If RHO goes to 1.

Then I want to take essentially math floor and math for floor plus 1 and math out for floor minus 1.

So elements in position 1 2 and 3.

So 1 2 and 3 should be made into pounds.

So hopefully that makes a little bit of sense here.

Again this is kind of getting into you know challenging stuff as far as some of these math calculations

go.

Let's try coding this up and I think it'll will start to make a little bit more sense.

So back over here the first thing we're going to do is to calculate the midpoint of our row.

So the midpoint of our row is going to change depending on N and that's why we had that two times and

minus one calculation in there for a second.

So we're going to say the midpoint is that index math Daut floor two times and minus one divided by

two like so.

So that's the midpoint index.

Now the other thing to keep in mind here is that we are iterating through this list of columns.

So in truth you know we don't really need to be calculating midpoint every single time here.

We could actually calculate midpoint at the very top of our function because it's only ever going to

be reliant upon and is never going to change.

So let's pull midpoint out to the very top up here.

And then inside of our loop all we really have to worry about is watching for row number of elements

to the left of midpoint and row number of elements to the right of midpoint as well.

So in code that would look a little something like this will say if midpoint less minus II is less than

or equal to you know not.

My mistake Roe if midpoint minus Roe is less than or equal to Culham.

And if midpoint plus Roe is greater than or equal to column then we want to add a pound.

So this if statement right here is going to make sure that the current column that we are looking at

is within the bounds of midpoint minus Roe and midpoint plus Roe.

So this is a check right here to make sure that we are inside of some bracket of numbers.

So if we meet that condition we'll add in a pound.

Otherwise we'll add in a space like so.

All right.

I know that was nasty but we did get through it.

I am pretty confident that if you look at these numbers a little bit they will make sense.

So do you know if it still seems a bit confusing do you try writing it out on paper.

You know for all the matters and I think that you're going to get a hang of it pretty quickly.

So here's our for loop inside of there we assemble one rows worth of numbers or one levels worth of

numbers.

So after that for loop just like before we will cancel log out level.

So let's see how we're doing with our tests back over here.

Looks like we've got 4 tests passing.

All right.

That was a challenging one but I think that steps gave us some pretty good preparation at least to pull

it into kind of two separate problems that we had to worry about.

So this looks good.

Let's now continue in the next section.
--------------------------------------------------------------------------------------------------------------------------

42. Pyramid Solution #2

In this section we're going to look at the solution to that pyramid problem by using recursion.

Before we get started.

Quick pause I wanted to tell you if you had any difficulty with the recursive solution to the steps

problem that we worked on just a little bit ago I really encourage you to give a shot at doing pyramid

on your own with the recursion solution because you essentially already know how the recursion solution

is put together.

All you really have to change is some of the bounds or some of the like you know essentially the range

of numbers that we're considering with this new solution for Paramount.

So this would be a great opportunity to practice some recurrent related stuff on a problem that you're

already kind of familiar with.

Now if you're to give it a shot or if you don't want to you know whatever it is no problem we're going

to go through the recursive solution right now.

So as usual we're going to make a backup of our pyramide function.

So I will copy the whole thing go down the bottom.

I'll paste it here it is right here and commented out.

I'll then go back up and I will clean out the pyramid function.

So now we've got only pyramid and the export statement right here.

All right.

So in general the recursive solution is going to look very similar to the recursive solution for the

stairs problem.

So the first half of this we're going to speed through pretty quickly.

And then as soon as we start getting into some pyramid related stuff will slow down just a little bit.

So just like before we're going to take special note of our argument list up here.

We're still going to hold onto the value N we're still going to worry about which road we're currently

looking at and we're still going to want to consider some given level here as an empty string.

Now the most important thing as usual and we want to make sure we spend careful thought on this even

if we are speeding through a recursions solution we always want to make sure that we set up our base

case correctly.

So just like before.

We're still going to watch for when Roe is equal to and if Rose equal to N..

That means we're all done with recursion.

We need to return and stop calling pyramid anymore.

Now note that Roe is still equal to and here because and ultimately was really describing the number

of rows we want in the last video when we spent some amount of time figuring out how to calculate the

number of squares going this way right here.

That was all about calculation calculating the column direction.

So Roe is still always going to be at a maximum of three.

It's the width of this thing that's going to start to change in nature.

Speaking of which that's going to be relevant right now because the next statement that we're going

to put together is going to detect when we are at the end of a level.

So at the very right hand side over here remember the maximum column length are the maximum number of

columns that we can have in a row is determined by the calculation two times n minus 1.

So essentially we want to check to see when our string the level string has a length of two times and

minus one.

If we are at that length then it's time for us to cancel the level and move on to the next row.

So we'll say if level length is equal to two times and minus one then we need to console log the current

level and move on to the next row.

So we'll call it pyramid with an will increment row by 1 and note that we are definitely in a place

the return statement here to make sure that we don't do any other work inside this function.

OK.

So that's looking good.

Now the last third to this thing is where things start to get a little bit more hairy.

Remember that the last third here is really intended to to decide whether or not we need to add a space

or a pound to the level string.

Now previously we had that very simple calculation to worry about how we had to worry about was if the

length of our string was less than or equal to Rho.

But this time around just like we had to kind of struggle a little bit with the solution this time around

we have to again calculate that midpoint and then decide if the current element that we were considering

is within that range of the midpoint.

So just like before I know the description on this was a little bit challenging but we still want to

do this kind of midpoint calculation.

We want to consider the row that we're on and then mark every element that's within some range of that

like plus or minus some amount to be a pound.

Otherwise it should be a space.

So let's look at the math for this first.

We'll calculate the midpoint which will be math floor two times and minus one and then another.

Outside of this first set of parentheses right here.

Remember order of operations will divide by two.

So that will give us our midpoint index.

Next we're going to put together an if statement to decide whether or not we're going to add on a pound

or a space.

Now rather than do our actual function call to the next pyramid call inside the if statement I'm going

to make a temporary variable called add at is going to contain the character that we're supposed to

add to our level string.

It'll make sense in just a second when we put down this if statement.

So we'll say if this is the nasty part.

So pretty big comparison we've got here.

If midpoints minus Roe is less than or equal to level dot length.

So remember in the recursive solution we determine which column we are currently operating on by looking

at the length of our level string.

So if the length the level string is less than or equal to or greater than or equal to the difference

between midpoint a row.

So it would essentially take care of making sure that we are you know on the right hand side of this

barrier right here.

And then we'll do the opposite side as well.

So Iand if midpoints plus RHO is greater than or equal to level length

then we will add in a pound.

So the second portion of the statement over here.

So this portion right here is making sure that we're still to the left of this found right here OK.

So now we're going to decide which character to add or I should say we just did.

We're going to sign the character that we should add to the variable add.

So in that case it's going be pounde.

Otherwise you want to get a space in there and of course to make sure that this is a space character

not an empty string.

So that's by the way why we use this temporary variable add right here.

It's just to assign the character.

We should add in and then down underneath all this stuff that's going on right here.

We will then start off our next call to pyramid.

So pyramid and is always going to be unchanged.

We are not going to change Roe because we are still in the middle of a road here on this bottom third

and then the last part we're going to make sure that we take this new character that we just generated

and added on to our level strength.

So we'll say level plus add like so

just one.

Let's see this.

Check our terminal.

Looks like I completely forgot to start my tests.

Mr. Arty's back up we'll see how we're doing.

All right.

Four test passing out of four.

Not bad.

OK.

So this has been our recursive solution.

Again this was pretty good practice because we got to see kind of more straightforward application of

it with the steps problem.

And then we got to redo it over here with pyramid but with some added complexity on top.

Both these problems.

I know I say this all the time throughout this course.

I know I said oh yeah this is a real common problem.

But again all the problems I picked for the course are of course common problems.

I really do expect you to see an interview.

And so proms like this one right here that are kind of concerned with spatial things and you know laying

out objects and spaces or whatever it is.

Common interview questions you'll see even though yeah of course you know no one ever had no one in

front end engineering ever is going to do some stuff like this.

I know.

You know that's a totally separate discussion that we haven't really touched on in this course.

I know that most These questions are totally bogus and not relevant to relate to a real job at all.

But you know that's just life.

I could we could talk for hours about that.

Anyways this has been a recursive solution.

Let's move on to our next problem in the next section.

So see you there.
-------------------------------------------------------------------------------------------------------------------
===================================================================================================================

Раздел 13:Find The Vowels

43. Get Your Vowels

Let's move on to our next question.

This next one is going to be rather easy.

Really very very easy.

But it's one that I've seen asked in preliminary interviews more than one time.

So what the heck let's just get through it.

Inside my vals directory I'll open up the index file and then of course we'll flip on over to our terminal

and start up our tests with just vowels test dot J us lunch like so and we should see four Tests.

Very good.

OK.

So we'll flip back over to the index dot just file.

Let's look at the description for this problem.

So we're going to write a function that's going to take a string and scan return the number of vowels

that are used in that string.

And if you are a foreign English language speaker of English is not your primary language of vowel is

any character a e i o n u.

So essentially we pass a string like Hi there.

Lis has one vowel two and three.

So we would return three for the next one.

Why'd you ask.

We have one two three and four.

So we were turned 4 and then the last one down here.

No vowels so we turn return y.

When I was back in elementary school we were always told like why is a half vowel.

I guess that's not really a thing anymore so you know we're not going to count y.

Who knows.

Anyways as you might guess this is not the hardest problem in the world.

So I encourage you to give it a shot.

We will look at two different solutions.

One is going to be an iterative solution and the other one is going to use a regular expression.

So if you are not up to speed with regular expressions this would be a great time to get a little bit

of practice in.

So give it a shot and I'll catch you in the next section and we'll go through the iterative solution

first.
---------------------------------------------------------------------------------------------------------------------------

44. Finding Vowels

In this section we are going to look at an iterative solution to the vowels problem.

Now this interim solution will be pretty darn straightforward.

So we're going to create a counter variable at the top will initialize it with a default value of zero.

We will then iterate through all the characters inside of our string.

If a given character is a vowel we will then increment the counter and at the very end of the function

will return that counter.

So not that bad.

Let's first start off by creating the counter variable.

So I'll say let count starts off a 0 and then we will iterate through our string.

So say for let char of and one thing that I want to point out here the directions didn't really indicate

if we wanted to consider capital avowals or not.

I think that it's entirely safe to assume that you want to include capital avowals and our fellow counting

here.

So we'll make sure that we lower case the string right before we iterate through it.

So say string to lower case and then we'll put some logic inside of here to decide if we're working

with a vowel.

And then afterwards we will return count.

OK.

So now the real thing that we want to care about here.

You know the real question is how are we going to check to see if we are working with a vowel.

Well you might be thinking hey let's put down a bunch of if statements.

If char is equal to A or if Char is equal to eat and so on.

Well we can definitely do that.

But that leads to some pretty nasty looking code with all these statements put together.

So I want to show you a little helper method that is included with all strings and all arrays as well.

That's going to dramatically simplify this.

So we'll look at a very quick example of it over here at my code editor.

I'm going to create a string.

Let's call it simply word and I'll give it the content.

Hello there.

Now a method that this string has is called include.

So I can Coale word dot include and then I'll pass in some substring that I want to see if it is included

in this string right here.

So maybe 0.

What do we get from that scares me.

Includes not include includes There we go.

So we're done includes We pass an O and yep there's Owen there so we get back.

True.

And then we can do something like capital F that's not in there.

We can do a substring like so.

So EHLO Yep that's unhealth right there.

So essentially using this includes method right here we'll go a long way towards helping us very elegantly

figure out whether or not a given char right here is a vowel or not.

So right above our for loop we will make a string that is going to contain all the different vowels

that we want to consider.

So I can say Konst.

Ideally I would really want to call this thing vowels.

But the function is already called vowels so we'll call this slight you know checker I don't know I'm

making it up and I'll make this a string.

So h e i o u like so now inside the for loop we can say if Sheckler

dot includes char then counter plus plus like so.

So if the character that we're looking at is included in this string right here then we're going to

increment the counter.

We'll iterate through all of our different characters and then eventually return it.

Now one thing I want to point out here is that using a string in this fashion right here is kind of

misleading.

You know it's not really the most clear thing in the world to any future developer who looks at this.

They might look at this and say oh is the order of characters here really important.

So even though we can use a string of characters to use this includes method I would probably recommend

that instead we should use an array as the kind of root comparison thing.

So arrays also have this includes helper method on it as well.

Let's see an example of what that would look like would be something like a b c c.

There we go.

And then we would want to see if C is included in the word array and Yezidis.

So if we use an array like this I think that life just becomes a little bit more clear for future engineers

who are working on this problem right here.

So maybe a e i o and you like so in addition this would also allow us to put in like discrete substrings

if we ever wanted to were kind of multi-character strings like if I ever wanted to.

For some crazy reason look for ABC is like.

Put that into this array.

I could not very easily do this same thing with only a single big book string.

So just one thing to keep in mind as well you know that's the kind of thing that interviewers want to

see you having consideration of.

To be honest.

So even though it might seem like this is overkill discussion for a function check and see if we avowals.

Honestly it's kind of a good discussion point to have during an interview.

All right.

Lesson do is make sure we're passing our test here.

Let's check the terminal and it looks like we are failing here.

Counter is not defined.

My mistake I'm incrementing counter right here is should be simply count and back over here.

We're now passing our tests.

Very good.

OK.

So that's one possible solution.

Now there is another solution that is much more condensed than this right here.

So let's take a break and we'll check out that alternate solution in the next section.
--------------------------------------------------------------------------------------------------------------

45. Another Way to Find Vowels

In the last section we went through an iterative solution for the vals function.

We're now going to replace this with a slightly more condensed version so I'm going to copy this thing

down to the bottom the file as usual.

Commented out just to leave a backup here and then I'm going to clean out the contents of the vals function.

Now this alternative solution is going to make use of a reg X expression or a regular expression.

So using a regular expression here in my opinion is so easy it's almost like cheating.

So what we're going to do is to look at the string we're going to call the match method on the string

matches used to see if some possible thing right here is included inside of this string.

So we can pass in a regular expression and this regular expression is going to check to see if we have

any values inside of here.

So our regular expression is going to have a pair of square braces when put in square pair of square

braces like this where essentially saying hey if this string contains any character that is inside of

the square brackets right here then let us know.

So we're going to put in all the characters that we care about a B.

I knew you'd think that we're going to do is to add on two options to the X itself.

Both G and III the G.

Regular Expression right here make sure that we don't stop at the first match that we find inside of

our string.

So if there are multiple vowels of some type in there we're going to attempt to find them all.

And then the right here stands for insensitive or case insensitive.

So remember before we had to manually turn our string into a lowercase version of itself the right here

will automatically take care of cases for us.

Now just one little odd thing about this match function right here.

If it finds any matches it will return an array of all the matches that were found.

So we will return that and assign it to a variable called matches.

But the part that's kind of awkward is that if no matches are found then match will return.

No instead.

So in other words matches right here will be either an array or no.

So we need to handle both cases appropriately.

We're going to use a turner expression for this.

So we're going to look at the matches variable if matches is no no considered to be a falsie value if

it is an array then that is considered to be a truthy value.

So for the first part of our turn an expression will say if this thing is a truthy value.

So if it is in an array then I want to return matches length otherwise it matches is null or if it is

a falsie value then I want to produce 0 and then ultimately we really want to just return the results

of the Turner expression.

So make sure we put the return keyword in there as well.

All right so we'll save this and let's see how we're doing now.

So still for passing.

Fantastic.

Again this is definitely more concise but it really is kind of predicated on you really closely understanding

exactly how a match works especially the fact that it returns no if no matches are found.

Personally if I were you I would probably stray towards this interim solution.

It's very clear and you can have some side discussions with your interviewer like the one that I just

mentioned at the end of the last video where using an array here is kind of the checker thing rather

than a string is beneficial.

So really up to you.

But honestly I think that the kind of value or the solution down here is probably the safer bet.

OK.

This has been a nice little breather Meisl easy one.

Let's now continue with our next exercise in the next section.
------------------------------------------------------------------------------------------------------------------
==================================================================================================================


Раздел 14:Enter the Matrix Spiral

46. General Matrix Spirals

Let's move on to our next problem inside my code editor I'll find the matrix directory and then open

up the index geas file inside there and then of course we'll also very quickly start up our tests with

just matrix test stuff.

J.S. dash dash watch like so and we should see about four Tests pop up.

Yeah here we go.

So four tests running.

Very good.

All right.

Let's look at these directions.

The directions say write a function that accepts an integer n and returns and end by and spiral Matrix.

Well those directions are not very helpful.

So let's look at the examples right here instead.

So the idea is that we're going to call the function and then we're going to return a two dimensional

array or an array of arrays.

So notice how there are two arrays inside of one larger array.

Here's the outer array right here.

And then we've got two arrays inside of it.

The reason that we call this thing a spiral matrix is that we're going to start off from the number

one and then going around clockwise in a spiral fashion.

We're going to count up from 1.

So we start off at 1.

We go over to two down to three over to four with Matrix 2 right here it's a little bit hard to see

the pattern.

It's a little bit easier to see the pattern with Matrix 3 and Matrix 4.

So let's look at this over here we start off at 1.

We go over to two three down to four five over to six seven eight nine.

And so you can kind of see the incrementing values here.

They form a spiral of sorts.

That kind of spiral from the outside into the center of the matrix and it's a little bit easier even

with Matrix 4 down here to see that pattern.

So we go one two three four five six seven eight nine 10 11 12 and then we spiral in to 13 14 15 16.

So we go in this clockwise spiraling in fashion the last number that we're ever going to print out inside

of here will be.

And squared.

So for example we have four here.

So the last number that we will print out inside if you will be 16.

Three times three is nine.

So that's going to be the last number.

And then two times two is four.

So that would be the last number.

Now let me tell you right now this is a very challenging problem.

This is tough because there are a lot of different variables that are going to be flying around inside

our solution.

Nonetheless this is a problem that you can be expected to be asked inside of an interview setting.

And I can tell you that from experience unfortunately because I have been asked this question right

here and it's really tough to do on a white board.

I got to tell you.

So this is a great example where it's extremely important.

Before you attempt to attempt to solution to get to to get out a sheet of paper or to you know draw

a diagram on the white board or whatever it is and try to draw out exactly how you're going to try to

tackle this.

This is a problem where if you just start writing code you're going to have a very tough time and I'm

pretty convinced that this is a nearly impossible problem to solve.

If you just immediately start writing code without putting some thought ahead of time into how you're

going to solve it.

So let's take a quick break.

We're going to come back in the next section and I'm going to give you a couple of notes on exactly

how to solve this.

So come back to the next section.

Don't attempt a solution just yet.

We'll look at a couple of different aspects of this problem and I'll give you some tips on exactly how

to approach it.

See you in just a minute.
--------------------------------------------------------------------------------------------------------------------

47. Spiral Solution

In the last section we started looking at the spiral matrix problem.

We're now going to continue by looking at some notes on a possible way to solve this.

So let's take a look.

So this is the general notation that we're going to use as we look at our solution.

So the outer box here is meant to indicate the outer array and then each of these inner boxes indicate

the sub array that are inside of it.

So this would be one subarray right here with the values 1 2 3.

Then the next subarray is right here.

And the final one right here and then all three Subah rays are contained within this outer array.

So then mind let's take a look at our diagram.

All right.

So this is a nasty thing right here but it is a nasty problem.

So I'm going to give you a kind of cursory description on the algorithm here.

I'm not going to try to walk in great detail through every step right here.

But if you want to look at these notes right here remember you can always pause the video and take a

glance at the diagram or all the Corson's diagrams or inside of the accompanying get repository which

was linked at the start of this course.

And so you can always go back there and take a look at these steps right here.

I would love to walk through all these steps verbally with you.

However if I start essentially reading these off it gets really confusing very quickly.

So you know honestly it's probably best that you might sit down and take a look at the steps here on

how we might solve this.

This solution is 100 percent predicated on this idea of maintaining some counter variables that reflect

what starting column we are working on and what end column we are working on along with the starting

row and ending row.

So the idea here is that we are going to have some integer values that keep track of the current index

that we are trying to fill inside of our matrix.

So we might start off with a start row equal to zero.

And that means that when our algorithm first starts off we want to look at row 0 and start attempting

to fill values inside of that row.

Then the last row that we want to be concerned with would be wrote two down here.

Notice that these are not necessarily hardcoded values.

I'm assuming that we have an an equal to 3 right here.

So if we had an equal to 2 or equals 4 or 5 6 whatever this and Roe value right here might change.

And so you're probably going to have to do a little bit of math to calculate exactly what the end Roe

should be depending on the value.

And that is passed into the function the start column is going to be some counter of sorts that decides

what value or what index we're currently trying to fill out for.

On the left hand side that will start off as zero.

And in the end column will start off as 2 as well.

So the general idea here is that we're going to make a series of four loops.

So here's one for loop right here.

Here's one for loop right here.

And then I did not show the other 2 for loops that you'll have to make on here inside of each of these

four loops.

You are going to iterate from some start column up to some end column and for every value or every index

between Start column and column you will insert some value into the matrix So for example the very first

lubra here will iterate from start column to and column.

So from zero to two and then at every step throughout that loop you will attempt to insert some value

on this first starting row right here after you have filled out these first row right here.

Or in other words after this first loop has completed running you can then increment the start row value.

So we could increment start row by 1 and it would say all right this is now the first row that we want

to be concerned with.

So essentially after you fill out the first row with one two three you don't worry about the first row

anymore.

You are now only concerned about this remaining part of the matrix.

So now the start row right here would be equal to 1.

You would be looking at this element right here.

Then fill this one out fill this one out and then you would decrement the end row to over here.

And so essentially these starting and ending counters that we're looking at right here are going to

be changing over time to essentially set the bounds of what portion of the matrix you are trying to

look at at any given time.

These directions right here probably give a very good direction or a good idea to you of exactly how

those bounds are going to work.

So again do look at the steps right here.

Now the last thing I want to mention to you is that I highly highly recommend that you create the results

set from the very beginning.

And when I say resultset I mean the empty array of arrays.

So build that at the very start of the problem and do not attempt to start to insert arrays as you are

iterating through this thing much easier to build out the empty arrays at the very start and then insert

numbers into that.

Okay.

So I know that this is a very tough problem.

It really really is very tough.

But as soon as you see the solution I know it's going to make a lot of sense.

So I encourage you to give this a shot.

Do the best you can.

All right.

Do the best you can come back in the next section and we'll walk through the solution.

So quick break and we'll take a look at this thing again in the next video.
--------------------------------------------------------------------------------------------------------------------

48. More on Spiral

Hopefully you had some success with a solution if you didn't.

If you struggle with the problem that's totally fine.

It's really what I would expect to be honest.

I'd be really surprised if many people got this problem correct on the first time through.

This is one of the classic problems where the first time you do it it's really hard.

But then we attempt the solution a second time.

Life gets a lot easier just like every other interview problem there is.

And that's why you're here you're here to practice the problem one time so that when you go and do it

in an interview setting it's much easier.

OK.

So let's start going through our solution as we go through the solution.

I'm going to be tabbing back and forth over this diagram quite a bit.

I know that's really distracting in a video.

I apologize for that but I want to use this diagram a lot to really show you exactly why we are writing

the code that we are.

So let's get started by doing Step one right here which is to create an empty array of arrays called

results.

That's step 1.

So inside my function it creates an empty array.

And then the number of sub arrays that are going to be pushed into this thing is dependent on the value.

And so I want to have an number of Subway's inside of results.

So we're going to have to iterate with the for loop from 0 up to N and for each step we're going to

push in an empty substrate into results.

It's all save for LeT I equal 0.

I less than an A-plus plus plus.

And then for each step we'll take the results array and we will push in an empty array.

If we we're now to con. log out results we would see something like four.

Let's assume that we have an end of two right here.

We would see something like this.

So for an end of two we would have two empty Subway's inside of one larger one.

Now a key behavior or a key feature of arrays that is really important for our solution here is the

fact that we can't assign values to indices inside of an array that have not been initialized.

In other words you know let's look at a quick example of this.

In other words if I declare an empty array right here so has no spaces inside of it no values nothing.

I can freely assign some value to say Index 3 and if I now print out a.

Notice how that value was assigned to index 3 right here.

I did not have to push this value in or I did not have to in it and shift the value into the array.

I can just freely assign any value to any index inside an array that I want and it's a very important

thing to keep in mind.

The solution here.

OK so back over here.

So our next step is going to be to create a counter variable.

Starting at 1.

So I will say let.

Counter equals 1.

So that's going to be the thing that actually keeps track of what number we are attempting to push into

our results array right here.

The next thing we're going to do and I did not specifically put this on the diagram right here.

We are going to create a number of variables that keep track of the current column.

The start column.

The end column the start row in the end row that we are trying to consider at any given time.

The start column and the start row will always be initialized to zero but the end column and the end

row their values will depend on the value of and that is passed into our function.

So to calculate the end column in the end row will take N and subtract 1 from it.

So to calculate this matrix right here or to produce this one we would have been given an end of three.

And so the last index that I want to say give me the last.

Next I want to consider would be and minus one.

So three minus one would be two.

So with that in mind let's declare those 4 variables we'll say start to call them is going to start

off at 0 the end column that we want to consider.

During this first run through will be and minus one the start row will be zero.

And the end row will be and minus one.

It's now going to move on to the next step here which is to somehow make sure that we are going to execute

all of this code right here.

As long as this statement is true.

So that's a classic case for a while loop.

We're gonna use a while loop here.

We're going to say while start column is less than or equal to column and blah blah blah we want to

execute these code blocks right here.

So let's write out that while loop will say while.

Start column is less than or equal to and column and start row is less than or equal to and row execute

some code inside of here.

So just to make sure it's really clear at this point start column and column start row and row all these

little counters things right here.

They're going to change over time so these are not fixed values that we just assigned right here.

We are going to change the value of start column start row and so on to indicate which row which column

and so on.

We are currently working on it.

Any given time.

Now that we've got our while loop put together we're going to start on our first for loop.

The first for loop right here is always going to be responsible for assembling the top row of our solution.

So this first row right here.

After that we will define the next for loop the next for loop will always be responsible for defining

this row on the right hand side.

And then there's the two other four loops.

I did not indicate on the diagram right here.

One of them is going to be always responsible for assembling the values here on the bottom and then

the last one we always responsible for assembling the left hand side of our solution and then we'll

enter the for the while loop again at the very top and this first for loop will then be responsible

for assembling the top block here.

So essentially we've got these for four loops in each of them is responsible for assembling a different

side and then each time we progressed through the while loop we're going to be constraining these start

row and row start column and column to control what section of The Matrix.

Each loop is attempting to create art.

So let's get started with this first for loop right here.

So for the first for loop I'm going to get my self comment here.

I get to say this thing is responsible for the top row we are going to iterate from I equal to not zero

but our start column.

So we're going to iterate from our start column which is going to start off at zero right here.

We are going to progress through this for loop as long as I is less than or equal to end column and

for every step through we will increment by 1.

Now inside of that for loop at every step along the way we are going to assign some value to the results

section or the results array excuse me.

So at our results start Roe at I we will assign the counter variable.

So inside of your results at start Roe at II we will sign the counter and then immediately afterwards

we will increment the counter and then after the for loop.

And this is the really critical part right here.

After we put the last line of code or this next line of code will take a second to kind of iterate or

to kind of imagine this first for loop and what it's really doing for us.

So after the first loop we will then increment the start row.

So merely after the for loop we will increment start row start row plus plus like so OK so we've got

one for loop put put together here.

Let's look at this on the diagram and really picture what this thing's purpose is.

So we are iterating from start column to end column.

We then put something into our set and then we increment start row.

So let's see what the result to that is.

So we are going to increment from zero up to 2 at every step along the way.

So from 0 1 to 2 we are going to look at our results set at the results set at the index 0 or essentially

start row and at the particular step through the four that that we are at we will assign the counter

variable.

So we start off at index 0 for start row 0 for II which is right here.

We assign the counter variable within increment by one which moves us over here.

We assign the counter variable we increment by 1 which moves us over here and we assign 3 at that point.

We have now iterated all the way from the start column to the end column.

So we're all done with this first for loop right here.

We have assembled the top row so we exit this first for a loop and then we execute this next line of

code which is to increment the start row.

So start row has served its purpose.

We have assigned everything in this first row right here.

So we are now going to increment start row by 1 which means this is now the first row that we are going

to be concerned with inside of our solution.

So now start row is going to be one.

So now let's consider the next for loop that we are about to put together.

We are now going to iterate over from start row to end row.

So from 1 to 2 inside of there we're going to look at results I at and column.

So now we have flipped our indices here and column.

At this point inside this for loop and column is always going to be equal to 2.

And we're going to have values of i ranging from 1 to 2.

So essentially this for loop right here the next one we're going to write we are going to iterate from

results at one at two.

So results 1 2 and that would be this index right here.

We will then increment I buy one and that will then move us on to results at two at two and for both

those steps we will assign our counter variable.

So let's go through that process right now.

I know this is some pretty crazy stuff but you know this is the kind of thing that you've got to answer

in the interview to get those very high paying jobs.

All right.

So this is going to be our right column.

We're going to iterate from i equal to our start to Roe.

So remember we are iterating from 1 to 2 now because we want to go from this spot to this spot.

So we're going to start at our start Roe we're going to iterate as long as I'm less than or equal to

end Roe and will increment by one each time.

And then for every step along the way we will sign results at I at the end column equal to our counter

variable and then we will increment our counter variable by one.

All right.

So again this is taking us from this spot right here to this spot right here.

Now immediately after we achieve that after we get through that for loop we have now taken care of this

entire column right here.

So we no longer need to consider this column.

So we're now going to detriment and Roe.

So we're going to take and Roe we're going to shift it over one to right here.

So now and column is going to be equal to 1.

So now we need to repeat these 2 for loops right here for the other two sides specifically this bottom

row and then the left column over here.

Now again I did not put the for loop on here but I think you get the idea of what's going on.

So for the end Roe we are going to want to iterate from the end column.

So we're going from right to left.

Now we're going from the end column down.

So we are now decrementing we are decreasing here we are iterating from the end column down to the start

column for every step along the way we are going to assign some results and then results right here.

And then we will detriment our and Dreux.

So Andrew will be subtracted by 1 and we would now be considering just this row right here.

So let's give that a shot.

All right.

So this is now going to be our bottom row.

And for this thing we're going to say from left I equal to and column.

So we're starting off right here at our end column as long as I in this case.

We are decrementing this case so we're going to flip a lot of these conditions we are recommending from

I down to zero.

So as long as I is greater than or equal to our start Roe are just not our start our start column.

Typo.

So from I.

As long as it is greater than or equal to our start column of zero right here.

So from this guy over to this guy and then every step along the way we are going to subtract 1 from

my then inside of here we'll say results at and Roe.

So that's where you're looking at this suburb right here sort and Roe at I are going to assign counter.

And then we will counter plus plus.

And then the really critical part right after the for loop right here and I just realized we made a

mistake on the for loop right above.

We'll fix that in just one second.

So Meely after our for loop right here we need to make sure that we move our end Roe up.

We have now taken care of everything inside this and Roe.

So we're going to shift it up by one which means we are going to subtract 1 from and Roe.

So I will say and Roe minus minus like so okay.

Really important really important to be back in here for a second.

I completely neglected to update our our coal encounter right here.

So for that second loop for the second loop right here that we just put together we needed to detriment

the and row really after it was at.

Now we need to decorate the column that should be document and column.

So the end column was over here.

We need subtract one to get it to this column right here.

So we are going to add column minus minus like so.

All right.

Last step here I promise I know this is brutal but very last step.

So this is going to be our For loop for the start column.

So this is going to be it's kind of boring on this three by three 1.

It would have been a little more interesting if we had a four by four matrix to look at but we are now

going to iterate from essentially right here up to here.

So we're going to go from our end Roe down to our start Roe.

So we will iterate from let by equal to you and Roe I greater than or equal to start Roe minus minus.

And then for every step along the way we're going to do is to assign results.

I would start calling because remember we want to assign at column zero right now.

And we're going to sign the counter here and then increment the counter and then Amilly afterwards.

We have now taking care of our start column right here.

So we now need to move it in words over here.

So I'm going to increment start column by 1 so start column.

Plus plus like so OK who.

That's nasty.

But that is all.

That's it.

That's it right there.

So after we finish that start column we will then go back up to the top so we will execute the while

loop again.

We will check to see.

Let's check all of our bounds here.

So we now have a start column of one and column of one.

This should be and column one right here in the Start column one.

So all of our columns are now one.

So we're only looking at this right here.

So we'll now check the while loop will say is Surt column less than or equal to and column.

And yes it is they're both one and start row less than or equal to and Roe.

And yes they are because they're both equal to one.

So we're going to execute all of our four loops one more time and it's probably going to be this for

loop right here that captures that very last placement of the number.

So we'll start off with one here.

One less than or equal to and column Yes it'll be this one right here will assign that very last number

will not satisfy any of our other loops inside of here.

And so will you will then exit our for loop or see me exit the while loop and then the very last thing

we have to do is return our resultset.

All right let's our test see how we're doing.

So over here it looks like my tests are running which means I probably have a typo somewhere due to

an infinite loop.

So let's check our solution here really quickly I'm going to check against my notes just to make sure

we've got the right thing.

I start Ro and column and row and then start column plus plus.

All right so we definitely have a typo somewhere here.

What we need to restart the test that's what it is.

So if your test stopped running is probably because they entered into an infinite loop.

I mean a restart my tests by running just matrix tests J us dash dash watch.

There we go.

All right so that's the problem we've got an unexpected token here somewhere with the counter.

Here it is right here.

Fix that.

And now the tests are passing.

OK I know this has been a brutal section.

I know this has been very brutal.

If you are not able to follow through all the way.

I really recommend you go and check out the get hub repository for this code and walk through the code

and take a look at all the balance on these four loops.

Honestly this problem it does make a lot of sense.

As soon as you understand how we are defining the start column and column start row and row variables

and then kind of constrain their solution window over time to spiral inwards.

That's what this problem is all about.

It's all about recognizing that you want to have some variables to keep track of the current range that

you're trying to fill in on the matrix at any given time.

Again I know the solution has been kind of brutal to be honest with you.

I have recorded this solution four times now and I think that this one has been the first sign that

actually came across at least somewhat clearly.

So I think this is going to be it.

This is the video you're probably going to be watching.

I tried recording this three other times and it really just didn't quite work out.

So hopefully this has made some sense.

So at this point hopefully you've got some idea of how this solution is put together.

I would really encourage you to maybe delete the solution entirely and try it again you know put the

solution together on your own at least one time so you can feel at least somewhat confident.

In an interview setting of communicating to an interviewer about what's going on here I'll get so a

very tough problem.

But we have seen it one time so you've got at least some idea of how to approach it.

Let's now take a break.

We're going to continue the next section and start working on our next problem.

So see you in just a minute.
--------------------------------------------------------------------------------------------------------------------
====================================================================================================================

Раздел 15:Runtime Complexity

49. What is Runtime Complexity?


We've now gone through a number of different problems in this course and along the way we have seen

many problems where we put together many different solutions.

So in some cases we did two solutions or even three solutions in some cases as we compare those different

solutions.

I need a very personal claim.

And I said oh yeah I think this solution is better than this one because it is easier to code or it's

easier to come up with or it just looks better.

However there is another way of comparing all these different solutions or algorithms that we are writing

that is much more concrete than what I was telling you.

So in this section we're going to start to investigate this much more concrete way of deciding what

given solution is better than another.

So this is where we are going to start to talk about something called runtime complexity runtime complexity

is a term that we use to describe how performant an algorithm is.

We use runtime complexity to compare different solutions to a given problem or different algorithms

for solving a given problem in the context of an interview.

So in the context of like you going and interviewing with someone you are going to be asked very frequently

in many different interviews many times you're going to be asked what the runtime complexity of a given

solution is.

So usually I interviewer will ask you a question you will solve it on a computer or on a whiteboard

and then they will turn to you and say OK what is the runtime complexity of the solution.

You just did.

So the real goal with runtime complexity for you and me like in this course right now our goal is to

make sure that you have the ability to identify a given runtime complexity.

That's our goal.

That's what we're trying to learn here in this video.

In the next few.

So just keep that in mind.

Now when we talk about runtime complexity we're really asking a very discrete question here we are saying

how much more processing power do we need to run a given algorithm or a given solution.

If we increase the number of inputs into our algorithm.

So let's look at some examples of this right here and try to answer this question let's look at some

examples of some problems that we have worked on and try to figure out what their runtime complexity

might be.

So the first problem we are going to look at is the string reverse problem we worked on.

And let's pull up the code from that very quickly.

So back in my code editor I'll pull up reverse string.

Here it is right here.

And I want specifically to look at the iterative solution that we put together that used a for loop.

So for this problem right here we said that we would have some input string and then to execute our

algorithm or our solution here.

We iterated through each character of that string exactly one time.

So it would be fair to say that as we started to add one additional character to the input to our algorithm

or like the actual input string that we threw in there we had to do one additional step of work.

So for each one character one additional step.

So that meant that we had a very linear runtime we would refer to that as a linear runtime because there

is a direct one to one relationship between the number of input elements that we got into our algorithm

and the amount of work that we had to use to process it.

Many of the problems that we've been working on so far have been linear runtime but we've also had a

good example of another problem.

Actually several of the problems we've worked on that had a slightly different runtime one that was

not linear.

So let's look at an example of one of those.

So here is the steps algorithm that we worked on.

And let's pull up the code from that one as well really quickly and come back out and I'll pull up my

steps code.

Here it is right here.

And I want again specifically to look at the solution with for loops.

Here's the for loop right here.

So the for loop we took some input n right here and then based on the input n we had to nested for loops

right here.

So one nested inside of the other that meant that as we started to increase the value N into our algorithm

we had to do significantly more things each time and was increased by 1.

So when end was equal to 2 we essentially had to do four things we had to produce one to three four

characters when Ed was equal to three.

We then had to do nine things and one end was equal to four we had to do 16 things.

So in this case there's clearly not a one to one relationship between the input to our algorithm and

the number of things we had to do or the amount of processing power that was required in this case the

number of things that we had to do was an squared or we had to do essentially end times and things to

execute our algorithm.

So when you have to do end times and things we would refer to this as an end squared runtime complexity

or a quadratic runtime so we'd get these kind of different terminology for identifying or runtime.

We get both this kind of equation looking thing right here which is the end squared.

And we also have this kind of nomenclature or a kind of the verbal form I would identify this as quadratic

in this case.

So let's take a break right here.

We're going to continue in the next section and we're going to look at several other very common run

times and also start to talk about how we can identify the runtime of a given algorithm.

So quick break and I'll see you in a minute.
---------------------------------------------------------------------------------------------------------------------

50. Determining Complexity


In the last section we started talking about runtime complexity and we took a look at our reverse algorithm

or string reverse one and these steps algorithm we had said that because the string reverse algorithm

had to do one additional unit of work for each character that was added into the input we would have

a linear runtime because there was a one to one relationship between the amount of work we do and the

input set then for the steps algorithm we had said that each additional piece of input that we got or

each increment to it I should say in this case meant we had to do and square more things so we had to

do significantly more work.

Each time our input increased.

Now one thing I want to make really clear here because some of the nomenclature that I've used is not

super obvious.

Notice how during our steps algorithm when we were putting it together we had that input or the input

argument was called n this and right here of four or three or two.

This is a different and than the end that we're using over here to specify a runtime.

So over here the input to our algorithm.

This might have been better indicated as like you know a number of steps or something like that we could

call it steps maybe that would have made life a little bit more clear.

So the two are not the two are related but I'm not saying that it's the same exact number.

That's all I mean to say.

OK so let's now continue by looking at some very common run times that we will use to identify many

different algorithms.

So here's some notes on some different run times that we're going to see in the wild.

These in general are really the Algor are the seeing of the runtime.

You want to keep in mind there are other runtime that exist.

There are other types that you have to do a little bit of math to calculate but in general many of the

different interview questions you will be asked will fit into one of these buckets or some combination

of two and we'll talk about some of the rules around when you might combine two and all that kind of

good stuff.

So I know that you know it's really boring when a presenter reads notes directly off a slide or a diagram.

Nonetheless I do want to quickly read through some of these descriptions right here because a lot of

them contain some very important notes.

So we're going to start to talk and talk about this first run time and then go down towards the bottom.

So let's first start talking about constant runtime cost runtime means that no matter what our input

set is or no matter what input we give to the algorithm it's always going to take the exact same amount

of time to execute the algorithm.

So for example if we came up with some amazing magic algorithm that does not exist but if we came up

with some amazing magic one where we said as the length of string that we put into our string reverse

function changes it's always going to take exactly the same amount of time to reverse it.

If we came up with some magic algorithm that did that we would refer to that as constant time.

However such an algorithm doesn't exist as far as I know for a string of verse.

So we don't really get to do that easily.

All right back here.

So Constantine we really see this as the Holy Grail and many times in an interview setting there might

be some way to execute some problem or to solve some problem in a kind of easy way or there might be

some very easy solution that might take say linear time or quadratic time.

But your interviewer will say oh I specifically want you to solve this problem in constant time.

So there are several problems that kind of fit into that category and your interviewer might ask you

to target a solution that meets one of these specific times.

The next one is logarithmic time.

So log right here stands for logarithm.

It's like you know the math term taking the logarithm of a number we have.

We will have a runtime of logarithm or logarithmic time if we double the number of elements that we

work with are working with or if we just increase them.

But that doesn't exactly double the amount of work that we have to do logarithmic run times are most

important.

Whenever we start looking at any type of search algorithm.

So searching through a sorted array of data we can always assume that that might take an algorithm that

runs with logarithmic time and that's an important assumption especially as we start to try to calculate

the runtime of different algorithms.

That's another note that we'll talk about in just a little bit as well.

Linear Time is one of the more common run times that you're going to see and a lot of interview questions

especially the more simple or straightforward ones with linear runtime you can easily identify this

by seeing if you are iterating through some collection of data.

So for example in this course so far every problem that we have had where we had to iterate through

some string in some fashion every single one of those has all been when your run time.

So in each of those we had to iterate from zero to some length of some collection like an array length

or a string length or whatever it was.

And in each of those we were probably working with linear runtime again just like we were talking about

with the reverse string function in the last video.

Anytime you have linear time you are saying that if we add one element to our input set it's going to

take one unit of performance or whatever you want to call it one unit of more time to complete the algorithm.

Now the next one guy to look up the term the technical vocabulary term for this one I don't really like

that name right there cause causal linear time whatever you want to call that basically Antibes log.

And so this would be a runtime complexity that we would see if we start to increase our input set to

our algorithm but increasing that input set by 1.

Increase the amount of time it took to to execute the algorithm by one plus a little bit.

So one plus a little bit for every element we add to our inputs set a very good example of this would

be any type of or I should say any type but many different sorting algorithms that we might work with

are usually going to be working with and times log and runtime.

The next one is quadratic time here.

So we just saw an example of quadratic time with our steps algorithm here.

We had said that as soon as we started to increase or add one element to our input to the algorithm

it started to take dramatically more time to produce the result set a very easy way of identifying an

algorithm that uses quadratic runtime is what I like to refer to as the hand shake problem.

So an easy way to picture this.

Imagine a group of people standing in a room.

If you send some additional person into that room and you introduced that new person to everyone else

and you had them like Shake hands that would be essentially an end squared complexity.

So each additional element that we add to a given collection has to touch or somehow iterate over or

somehow deal with every other element in the collection.

So you can kind of remember that handshake problem as an example of quadratic complexity as another

person was added into the room.

They then had to shake hands with every other person and every person in the room had to shake hands

with everyone else finally exponential time.

So this is absolute assurances.

Worst case is not quite worst case but it's one of the worst cases that we're going to be considering.

So if we start to add a single element to a collection the processing power significantly significantly

starts to increase.

And so this is not any type of algorithm that starts to use exponential time is one that we absolutely

positively want to avoid and we will see an example of exponential time in just a moment with one of

the problems that we're going to work on.

If you start to suggest an exponential time solution to a problem in an interview that is a very big

deal that's a very big bad deal to clarify.

Very bad thing if we are able to identify an algorithm as requiring exponential time we never want to

propose it as a real solution to a problem.

In an interview you definitely can you know use it as a solution to get started but very likely if your

interviewer is proposing a problem or asking you a problem and you're thinking oh this will probably

take exponential time to solve.

Chances are there's going to be a much better way of solving it.

I can just about guarantee you.

And that's what a lot of interview questions all revolve around.

Your interviewer will ask you a question that might require exponential time or quadratic time.

And so it's relatively a not very efficient algorithm and you might be able to identify a solution very

easily that uses one of these.

And your interviewer is going to expect you to say Oh well I can think of a solution that uses this

but I can also think of this much more challenging and difficult to implement solution that might take

linear time.

That's what they're really asking.

In those situations they want to see that you can recognize an algorithm as being inefficient and come

up with some more efficient algorithm out of it.

OK.

So this has been a quick review of some of the very common runtime that we will see in action.

Let's now take a quick break.

We're going to continue in the next section and talk a little bit more about some common tips that I

have for you about identifying runtime complexity.

So quick break and we'll continue with this in the next video.
---------------------------------------------------------------------------------------------------------------------

51. More on Runtime Complexity

In the last section we spoke about some common runtime complexities.

We're not going to continue about by talking about some odds and ends around runtime complexity.

So just some things I think you should really know about it.

The first thing I want to discuss is Big O notation.

So Big O is another way of referencing runtime complexity.

So your interviewer after you finished some algorithm they might ask you hey what is the runtime complexity

of your solution.

They might also ask you what is the big O of your solution.

Either thing that they ask.

They are both asking what is the efficiency of your solution.

You know what is the runtime of your algorithm.

Big O notation is a way of writing out this runtime complexity that is commonly seen in the academic

world.

So for example linear runtime could be indicated by writing Oh and it's called Big O because it's literally

a big O of n.

So if you see all events like this that indicates linear run time all of one would be constant.

Of and square to be quadratic.

So essentially when you start seeing these big O's with some kind of little equation inside of it we're

really still talking about these different run times over here.

The term Big O in general means something slightly different in the academic world but in an interview

setting any time you hear runtime complexity or Big-O notation or anything like that they're always

asking you what is the run what is the efficiency of your algorithm.

Now the next thing I want to tell you about is some tips around identifying runtime complexity.

So for identifying complexity or number.

This is what you're going to be asked in an interview setting for identifying the stuff.

I've got good news and bad news.

The good news is once you get some experience with it it gets pretty easy.

The bad news is that like many other things in the interviewing world there's not some magic formula

that you can just be given that 100 percent of time always correctly identifies the runtime complexity

of something.

It's something where you have to have a little bit of experience you have to look at some different

algorithms and just get a sense of what's going on.

There's really not a hard and fast rule of exactly how this stuff is done.

So I'm going to give you some tips right here on some common complexities and how you can identify them

as we go through many other algorithms and solutions in this course.

We will also spend some time to discuss their runtime complexity as well so that you can start to develop

that sense of what runtime complexity is and how to really determine it.

So let's go through some of these really quickly.

Again I know it's really annoying when a presenter reads directly off a diagram but you all add some

extra words in here and each of these.

So the first one is if you ever see yourself iterating through a simple for loop with like a single

collection.

Great example of which would have been our reverse string algorithm back here.

So we had a simple for loop more or less iterating over a fixed set of records.

Right like just these characters right here.

When ever you see that chances are you have linear runtime extremely likely so simple for a loop probably

means you have Brunt's seemy linear runtime complexity.

The next thing to keep in mind is OK well if we are only iterating through say half a collection like

if we only look at half a string.

Does that mean that we are using a runtime of like end divided by two.

No there is no such thing as like end divided by 2 or 1.5 times n or two times and or three times then

in runtime complexity.

Take any of those numbers like any of those what we refer to as constants and you always drop them out

of the equation.

So any time you see a for loop iterating over a closed set of data even if it stops early even if it

says I'm only going to iterate through like half this thing it's still going to be a linear runtime.

So always drop out those constants.

Another thing to watch for is if you are iterating through two different collections of data.

So imagine for example if we had said Okay write an algorithm that reverses two different strings two

different strings reverse both them in one function call.

That would be an example of iteration over two different collections of data into separate separate

for loops.

So you would have one for loop to reverse the first string and then one for loop to reverse the other

string so those would be two separate for loops.

In that case we would introduce an additional term into our runtime complexity.

We would say something like that has runtime complexity.

And plus him.

So the end in this turn right here is meant to indicate the runtime or the performance impact of the

first string.

And then we would introduce this second term right here to represent the second string.

Because in theory you could be passed a very very short string for the first argument to your dual reverse

function and then a extremely extremely long string for that second argument or that second string.

And so we would want to separate those two out and say OK we are reversing two separate completely different

strings.

One might be short.

The other might be long and so we would want to represent those separately.

In general you know this is not only applicable to two strings.

Anytime you are iterating over or processing two completely different sets of data you'll frequently

see the runtime complexity split out to two separate terms.

Now the next one is very closely related.

If you ever see nested for loops a nested for loop is like a big O Take a look at that right there you

know it's a big red flag.

If you ever see nested for loops iterating over the same collection.

So this same collection of records very likely that you have quadratic runtime or and squared complexity

and a great example of this was the stair algorithm.

And the are seeing the steps algorithm right here heres the steps algorithm.

So we had one for loop right here.

And the second one nested inside of it.

Another great example of this was the it algorithm that we put together.

So here's pyramid.

Here is the iterative solution right here.

Oops there we go.

So here's the iterative solution.

And we very clearly had one for loop where we iterated from zero to some target number and then inside

of that we had another for loop that it rated from zero to some upper bound up here.

So any time you see these nested for loops huge red flag.

Extremely likely that you might have and squared runtime very closely related.

That again is if we have two nested for loops.

But each one is iterating over a different collection of data a different collection.

In that case just like we said a moment ago with two separate strings we might have one string or one

collection of data that's very short and the other one might be very very long.

So that would no longer be squared because we have two different collections of data and they might

have different requirements for different lengths and each of them.

And so we would reflect that as being End Times.

And remember that's not quite so different than squared.

Remember that squared is simply end times and as well.

So it's really the same thing here.

We are specifically saying hey there's this other set of data that is not related to.

And it's called em.

But still for every record in and we have to also iterate through him.

And so that would be an example of end times in complexity.

Now the last two here are two that are great shortcuts to have very close at hand.

These are very very commonly used.

Any time you ever see any requirement in assorting or a problem for sorting any requirement whatsoever

you can essentially just assume that it's probably going to be and log and run time.

So every sort.

Operation the best runtime complexity we can have for sorting something is an log.

And so if you have an algorithm where you have to sort something chances are you will probably see a

term like this inside there.

Then the other thing to keep in mind is sorting Sumeet searching through a sorted array.

So if you have an array of say numbers or a collection of anything that is sorted in some fashion and

you have to search through it chances are you have a log and runtime complexity from that operation.

So I mean again anytime you see sorting or searching you likely will have something related with one

of these run times right here.

So just something to keep in mind.

OK.

So that is a quick list of big tips to watch out for when identified runtime complexity.

Again this is something where you just got to have a little bit of experience you've got to do it.

You have to be told OK here's the algorithm Here's what the runtime complexity is and you have to develop

your own feeling for how it actually works.

It's not something where I can just give you hey here is the absolute you know rule of thumb to use

100 percent a time that doesn't exist for this.

Unfortunately I wish it did.

Now the very last thing I want to tell you about kind of a last minute thing I'm going to throw in here

is space complexity.

So we've been talking about runtime complexity which is a reference to the performance of an algorithm

in terms of processing power.

Another thing to are that you might be asked an interview setting is the space complexity of an algorithm.

So space complexity is extremely similar to performance but it is a reference to how much RAM or memory

or space an algorithm needs to complete a given task.

In general you can really apply a lot of the same rules around runtime complexity to space complexity.

Great examples of this would be something like reversing a string.

In our case for every additional character that we added into our input set we had one additional character

that we needed to return in the output set of data.

And so the amount of memory that we spent was linear because for every one additional character we needed

one additional element in our string to be added.

Another good example of this would be the steps algorithm.

We also looked at.

So in this case we had said that for each increment of these steps argument we had to do.

We had to printout to a dish or some number of additional items in our resultset.

So not only do we have to process more data or we had to iterate through some loop more times.

Our resultset also had significantly more entries inside of it.

For every record that was added in.

And so this will be a great example of quadratic runtime for space complexity as well because you can

see very clearly right here.

For two we had to produce four items so four elements in memory for three we needed nine elements memory

and for four we needed 16 elements in memory.

Now the space complexity and runtime complexity are not always going to be identical in many cases they

might be very different.

However you know again we'll see some examples of different complexities over time I will say that space

complexity is less frequently asked in an interview setting than time complexity.

So if you're going to spend any time doing any studying or anything like that I really recommend pushing

all your time towards studying up on time complexity of post as opposed to space.

But honestly once you understand one really well usually you can pick up on the other pretty quickly

as well.

So just keep that in mind.

OK.

So this has been a lot of discussion around runtime complexity.

A lot lot lot.

So let's continue the next section we're going to start looking at some more algorithms that start to

get into this world of runtime complexity.

So let's continue in the next section and we'll start looking at some more complicated algorithms.

So quick break and I'll see you in a minute.
---------------------------------------------------------------------------------------------------------------------
=====================================================================================================================

Раздел 16:Runtime Complexity in Practice - Fibonacci

52. The Fibonacci Series

Now that we have had an introduction to runtime complexity we'll begin working on another question that

is great for profiling differences in runtime complexity between different solutions.

So inside my code editor I'm going to find the folder and open up the index dot JSE file and then as

usual We'll also start our tests.

So at the console run just fib test us dash dash watch like some.

And we should see about six or so test passing right now or see me six total right now.

All right.

Let's take a look at the problem we have to work on.

So the goal of this function is to printout the nth entry where an is an argument to the function of

the Fibonacci series the Fibonacci series is this ordered list of numbers that you see right here that

Fibonacci series can be characterized by taking two numbers adding them together to produce the next

century.

So to look at this and diagram format we usually kind of take these first two numbers right here of

zero and one for granted because there's no previous numbers for it that we can add together.

So for this third element right here we would look at the previous two numbers zero and 1 we would add

them together and that gives us one then for this element right here.

We would add one plus one that gives us two for this one we have two plus one that gives us three 3

five is three plus two.

And so on.

You get the idea.

Now the Fibonacci series extends past 13 of course.

So it goes on as far as you want but this is the general pattern that we need to be aware of some just

showing the first couple of elements out of it.

Our goal with this function right here is to make sure that we return the nth entry.

So usually the way that we solve this is by generating the entire series all the way up to the nth entry

and then we return that entry.

So it's really tough to just say oh yeah I want to just generate this number right here.

Really.

Usually end up having to generate all the entries up to that number.

And then you can return that one.

OK.

Now there are two solutions that we're going to look at for Fibonacci in the next section we're going

to look at a solution that uses an iterative solution.

And then after that we'll look at a solution that uses a recursive solution.

So if at all possible if you've already seen this problem if you've done it before.

Go ahead and give a shot at the iterative solution for the next section.

If you've never done it before.

Just give it your best shot and try any solution you can think of.

So let's take a quick break right now.

Give it your best try and I'll see you in just a minute.
---------------------------------------------------------------------------------------------------------------------

53. Fibonacci Series Iterative Solution

Hopefully you had some luck putting together the Fibonacci series solution.

In this video we're going to go through an iterative solution that uses a for loop to return the nth

value from the Fibonacci series.

So here's the general plan.

We're going to create an array.

We're going to assemble all of the numbers up to entry n.

So let's assume it's supposed to be this entry right here that was given for N.

So produce everything up to that element right there and then we'll return it.

And that's pretty much it.

So let's give this a shot inside of my fit function.

I'm going to declare an array that is going to hold a series of numbers.

I'm just going to call it result.

Like so now the big trick behind this iterative solution that uses a for loop.

This is the big trick.

Again all these problems have a trick.

The trick is to recognize that these first two numbers inside of here cannot really be effectively generated

by a for loop or anything like that.

Remember the algorithm that we're using here is to say look at the previous two numbers add them together.

And that gives us in the element that we want to add to the series.

So for this number and this number there is no previous two entries that we can add together.

However you and I always know that there are going to be zero and one.

So the best way of handling this is to just manually insert 0 and 1 into this result set.

Now to produce this third element right here we can add together zero on one to produce 1 and then continue

on throughout the rest of the series just like that.

So we will use a for loop that is going to iterate from equal to 2.

So we're going to start off at two because we want to produce this element first and then we're going

to iterate all the way up to N.

So right out for left eye equals two.

I less than or equal that and I plus plus like so then inside of the for loop itself we need to pull

out the previous two records in the result array.

So the previous two records and then we will add them together and push that into the result set.

So we'll say constitute a equals result and we can either to get the previous two records and here we

can either look at the variable I subtract 1 and then subtract 2 or we could take result length minus

1 so it can be either resultant length minus 1 to get the previous record or we could take I minus 1.

Either way is totally fine.

I think we'll go with I minus one just for fun here and then B will be result at I minus 2.

So this is for Sanja loop runs now.

I will be equal to 2.

So a will be receiving the second element which is 1 and then B will be calculated by taking two minus

two.

That gives us zero.

That's the first element in the result set which is also 0.

We will then add these two numbers together.

So A plus B.

And then we will push that into the result array like so.

OK.

So this is going to generate our Fibonacci series all the way up to entry.

And now the last thing we have to do is return entry and from our result set right here.

So down below you can simply return result at an all right.

So let's save this and see how we're doing.

One other quick thing I want to mention by the way another thing we could do done here rather than saying

resulted.

And just to get the last entry we could have simply said result of length minus 1 to get the last record

to leave to you.

Again either way is totally fine.

So let's see our terminal is doing and yeah it looks like we've got the correct values here.

So all tests are passing great.

So this is the iterative solution to this problem.

Now I want to ask you right now do you have any guess as to what the runtime complexity of this is.

So the runtime complexity we can either take you know a very cerebral cerebral thought here or we can

use some short shortcuts.

So if we were going to take the more cerebral kind of academic approach to this I would say well for

every increase in n we have to calculate one additional number.

So as an increases by one we have to do one more calculation and that's never going to change.

So I would say this is linear run time.

The more kind of short cut way that we might arrive at that is to say well we've got a simple for loop

and it looks like we are always starting out at some fixed number always incrementing by one and we're

always incrementing up to this fixed target.

So another way could be to just say Well looks like we've got a for loop that iterates over this kind

of close set one for one.

So chances are it's linear run time.

So it's going the two ways that I might approach approach that.

Okay.

So this looks good.

Let's now take a break.

We're going to come back in the next section and we're going to put together and it a cursive solution

to this problem and that's where some of this runtime stuff the runtime complexity is going to start

to get very interesting.

So quick break and I'll see you in the next video.
---------------------------------------------------------------------------------------------------------------------

54. Fibonacci Series Recursive solution

In the last video we put together an iterative solution for the Fibonacci problem.

We're now going to continue by putting together an alternative solution that solves this by using recursion

instead.

Now of course as usual we will make a backup of our iterative solution here.

So I'm going to copy our previous effort.

I'm going to move down to the bottom of the file and paste it and then comment that thing at all then

go back up to the original implementation of top and delete the contents of the function.

OK.

There we go.

Now before we put together this recursive solution I want to tell you kind of a funny story that I think

is great commentary on the state of coding interviews in general and this is something that we've been

discussing all through the course so I have worked at a company in the past years ago where every interviewee

that came in every engineer who was interviewed they would all come in and we would we would always

ask them the same problem.

We would ask them Hey Saul Fibonacci using recursion and I got to tell you there was two types of engineers.

There was two types.

There is one type who could solve it.

They did a great job.

You know they solved it using recursion and then the other type the other engineer they could not do

it for the life of them.

And you might be curious what the difference between those two engineers was and this is for my own

practical experience I'm very much convinced of this.

So what was the difference between the engineers who could solve it and couldn't solve it.

Well at the end of the day there was one simple difference.

The people who could solve Fibonacci using recursion had already seen the problem before.

That's it.

So this is the classic problem where if you see it one time you say OK.

Yeah it looks reasonable.

I can memorize that and then you say OK that's how assaulted not using recursion because it is a classic

example of recursion.

However if you've never seen it before it's so incredibly unlikely that you will come up with a solution

to Fibonacci using recursion that I'm about to show you it's my opinion it's just really challenging.

Extremely unlikely.

I'm sure there are people out there who have came up with the solution independently but I am very much

convinced that this is an example of a problem where you've either seen it or you haven't.

So I'm very happy you're here watching this lecture because it means that you will see the solution

and you'll be able to answer this question when it comes up in your own interview.

By the way Fibonacci series is a incredibly common question to be asked.

So this is definitely one to keep in your head.

All right so let's do this because of what I told you.

You know this is a problem where you've either seen it or you haven't.

I'm just going to put the code up here for the solution and then we'll talk about the disk the solution

and how it works.

Like I said it's really challenging to come to this solution on your own.

My personal opinion of course.

So we're going to say if an is less than to return an and then Otherwise we want to return fib and minus

one plus fib and minus two and that's it.

That's the solution right there.

So let's flip on over to our terminal I'm going to save this file a flip on over to the terminal and

I'll verify.

Yeah it looks like our tests are still passing here.

So very good.

Well kind of very good.

So why does this work.

You know there's a couple of different things to talk about with this Fibonacci solution right here.

The first thing I want to do is tackle it from kind of the recursion side and understand how the recursion

here works.

After that I want to come back to a solution and talk about the differences between this one and the

one we worked on before.

From a time complexity standpoint.

So understanding this recursive solution right here is really challenging unless you put it into diagram

format which I've done.

So let's go take a look at that diagram.

Now before we do one thing I want to point out here is the only time in which we appear to actually

return a number from Fibonacci.

Right here is when and is less than 2.

So when and is equal to zero or one that's the only time that we're going to return an actual discrete

number.

So with that in mind this is what I want you to be aware of right here when we call Fibonacci with zero.

We get back zero when we call Fibonacci with one.

We get back 1.

Those are like very discrete numbers that we definitely get every other call to Fibonacci like if we

call Fibonacci with 10 or five or six.

Well it means that we start entering into this recursion and that's when we start having to think about

OK how do all these function call stack up and eventually give me a result.

So then mind let's take a look at a diagram that's going to help us kind of understand what's going

on here.

All right so at the very top we have an imaginary function call to Fibonacci with an input of five.

So as you just saw you know let's take five right here and let's go back to our code and think about

what would happen.

So we called fib with five is five less than two.

Well no of course it's not.

So we call Fibonacci with four and five with three so that results in two function calls.

And that's what I'm reflecting this diagram over here.

Here's Fibonacci being called with for years Fibonacci being called with three.

Now in the case of four.

Let's walk through the case of four.

So fib of four or an equal of four is for less than two.

Well again no it's not.

So we call Fibonacci with three and Fibonacci with two.

And then the process repeats itself for the rest of this tree right here.

So eventually we get down to the bottom of the tree and eventually we hit that case.

And it's less than two.

And we start to actually return some numbers.

So that is these blue squares right here.

All these blue squares.

This is where we actually return some numbers.

Now as you saw just a second ago right here.

So whenever we call Fibonacci recursively we are adding the result of those two together.

So at the end of the day you can kind of imagine that all these blue squares right here are eventually

going to be added up and total together.

So let's take all these different blue squares right here and take their sum.

So specifically what calling Fibonacci with this particular number would result in.

So when we call Fibonacci with one it returns 1 if we call Fibonacci with zero return zero.

So we don't really care about Fibonacci with 0 because it returns zero.

So I'm going to just kind of like gray those out.

All we really care about here is calling Fibonacci with one.

So when we call it with 5 it eventually results in Fibonacci being called with 1 1 2 3 4 5 times.

So we can add together one two three four or five.

OK.

So Fibonacci of 5 should be five.

Let's go back to our diagram right here.

The sequence right here so element 0 1 2 3 4 5.

So 5 is 5.

That is definitely the correct answer.

So that's how it works.

Basically we keep on calling Fibonacci with smaller and smaller numbers until eventually we meet this

base case right here and start to return some actual value.

Now that's kind of you know easy to think of for the fifth five case let's look at just one more case

here.

When we call for the notchy with an input of six.

So here's what the diagram looks like with six.

And yes this took me a couple of minutes to make to make this diagram right here.

But whatever.

So we called Fibonacci with six.

That of course results in a call to Fibonacci with five and four.

And then we go down this tree and eventually we collect all these 1 terms and add them all together.

So we get 1 2 3 4 5 6 7 8 8 is our total.

Let's go look at our series again.

We get 0 1 2 3 4 5 6.

So calling Fibonacci with six should return the six element in the series which is 8 and that's exactly

what we got from this result of adding these all together over here.

So that's how the recursive solution works.

Does that sound confusing.

Well I very much should.

I really think that it should.

I can't imagine why an interviewer would ask this thinking that someone's just going to bust out Fibonacci

on the fly with this recursive solution right here.

You know honestly a lot of interview questions especially coding questions are not so much designed

to test your ability to generate solutions.

There are more testing just to say hey do you have the common knowledge that we expect someone interviewing

with our with our company to have.

In other words I'm kind of convinced that people are asked for the notchy here just to make sure that

you know you have seen the problem Fibonacci before.

Because if you haven't seen it maybe that's some commentary about your experience in the computer science

field or you know something I don't know.

That's the only reason I can personally really imagine that Fibonacci is asked in a recursive type of

context.

Anyways enough of my ranting here.

You know obvious is a question that gets me a little bit upset.

I have been asked this question in an interview and you know I did pass it solely because I memorize

the solution not because I understood at all how the recursion was working and so I guess that's why

I get frustrated the question because it really proves nothing about your interviewee.

OK.

Anyways enough of that.

So I do want to have a good discussion about time complexity for this recursive solution right here

because it's actually quite awful and you might be surprised to see how bad it is.

So this whole time complexity discussion around Fibonacci I think perhaps that's why interviewers ask

this question because it is a great problem to kind of profile your understanding of algorithm performance

and time complexity and all that kind of good stuff.

So let's get to the next video we're going to do a kind of deep dive on time complexity between these

two solutions.

And we'll talk about some possible solutions to improve the time complexity of a otherwise very slow

algorithm.

So quick break I'll see you in the next video.
---------------------------------------------------------------------------------------------------------------------

55. Memoi-....Mem-...Memoization!

In the last section we put together a recursive solution to the Fibonacci function.

And I got to reveal some of my baggage around recursion just kidding.

Anyways in this video we're not going to continue by discussing some of the performance characteristics

of this recursive solution right here compared to the previous iterative solution we put together.

So really quick while we still have the recursive solution implemented I want to flip on over to our

tests running in the terminal you might have noticed that for each test that we're running here.

So here's one test is another issue is another.

Sometimes we can see the amount of time that that test took to execute printed off to the right hand

side.

If the test takes less than one millisecond the time is not printed.

So we run it again we might see that some of these tests randomly appear to take slightly longer than

one millisecond.

But most interestingly you'll notice that when we tried to calculate the Fibonacci value for 15 it ended

up taking just over 1 second total.

So that's kind of surprising because we've got one two three four.

These all appear to have been computed rather quickly like right around one millisecond.

But then by increasing up to 15 it took about a thousand times longer to compute really 1000 years one

millisecond years 1000 milliseconds that's a thousand times longer.

So what's going on here.

Why are we seeing such a dramatic increase in time for such a small increase in the value that we're

trying to compute.

Well let's look back at our diagrams a little bit and try to figure out what's going on.

So here's the diagram that we're looking at just a second ago of a call to the Fibonacci function with

five as the argument.

So when we called Fibonacci with five the Fibonacci function itself is being invoked many many times

automatically.

So each of these boxes right here represents one function call to Fibonacci during our with a recursive

solutions let's count these out.

We've got 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15.

So we've got 15 calls to the Nazi function with 5.

Let's now compare that to the Fed six function call over here.

So notice how 5 5 is still right over here and we just said that that was 17 calls total or 15 whatever

it was i already forget.

So we can imagine this is 17 calls or whatever it was.

And then when we also add in this additional 5 4 right here we have to call because we're now dealing

with the basics.

We now have an additional 1 2 3 4 5 6 7 8 9 10 calls so 17 calls for 55 and then 27 total for that 6.

This is what we refer to as back over here on our diagram.

Exponential run time.

So for each additional element that we add into our collection or for each increment of the value N

to our function we're experiencing a dramatic increase in the number of function calls that are required.

Now in my notes right here I say very clearly.

Oh yeah the processing power required doubles as we just saw.

It does not exactly double.

It actually slightly less than doubles.

But the idea is still very similar here.

For every additional element we're getting a dramatic increase in the number of function calls or essentially

operations required to calculate our value that we're trying to determine.

So our recursive solution that we're working with right here is what we would refer to as an exponential

time solution.

Remember like we said a moment ago when we were first discussing exponential time any exponential time

algorithm you create is an automatic no no.

We never ever want to accept an exponential time algorithm as a solution to an interview question.

If you came up with this solution right here and then your interviewer said Gee how long will this take

to run if you put in like five of 50.

And you said oh I don't know but you know whatever we can probably just sit around and let it wait.

Well Fibonacci 50 is going to take an extremely long time to be calculated.

So be aware that any time we start seeing a exponential run time function it usually means that there's

a different solution we can put together that might be much more efficient in nature.

So in this particular case you know let's say that you were sitting with your interviewer and they said

hey give me the recursive solution to Fibonacci.

And you came up with this right here.

They very likely will say to you.

Hey what do you think the runtime of this would be.

The answer that you want to give is what's definitely to be exponential because for every increase in

N we are going to get a dramatic increase in the number of function calls that we get.

So here's what's going to happen next.

And we've discussed everything to that point.

The next thing your interviewer is going to ask you is OK well is there any way we can improve this

recursive solution here to not be exponential run time.

Is there any way we can you know put in some additional fixes to make sure that it is not ex-special

runtime and you might say oh well we could do the iterative solution which we already discussed was

linear runtime and you know what maybe they'll let you get away with that.

But if your interviewer says is there anything we can do here to improve the runtime of this algorithm

they are looking for you to say something very particular.

OK here's what they're looking for you to say they want you to say well you know I'm looking at all

these different function calls because we know when we call like fibbers 6 we're calling Fibonacci all

these different times.

And when you start to look at this chart right here you start to realize that the function is being

called many times with identical arguments.

So for example here is 5:3 being called one time over here.

5:3 also gets called right here and right here here is fib to fib gets called with two over here over

here over here and over here.

So clearly our Fibonacci function is being called multiple times with identical arguments.

I've taken the liberty of kind of graying out a lot of boxes here.

And I actually I just realized I missed one let me do this one too.

So all of these greyed out boxes that you see or duplicate calls to the Fibonacci function with identical

arguments.

So if there is some way that we could avoid all these extra function calls then if we the Fibonacci

was six we would really only have to worry about doing all the computation stuff for 5 5 4 3 2 1 and

0 exactly one time and then all the other times you know maybe we could figure out some kind of clever

solution there.

So in other words or let me kind of cut to the chase here and say we are.

Interviewer asks you if there is some way to improve the runtime of our solution.

What they want to hear is this word right here.

Now the bad news is that I can't pronounce this word.

I'll be honest.

It's like I can't even it's memoir Mentawai memorize memorization.

You know what.

Go look up the pronunciation on Google.

Memoization What if for whatever reason I just can't do it anyways.

This is a term for something that we can do in with a function call that essentially does this right

here.

So when we memorize a function there we go that's it.

Memorize when we memorize a function we're going to record the arguments of each function call so we

can record the arguments we're going to run the function and then we're going to store the result of

that function call.

So we've got some like little table in memory that says hey our function was called with this number

and when it was and returned this result and then here's the key.

If that function ever gets cold again with the exact same arguments rather than running the function

again and doing the entire recursion process all that crazy stuff rather than duplicating all those

results.

Instead we're going to turn that result that we had computed previously.

So what does that look like in practice.

Well basically just like we saw in the diagram over here we're going to say OK whenever we try to calculate

fibs 56 we're going to immediately make a call to fab five that's going to make a call to four.

And so this is the first place where it's actually meaningful.

OK so let's concentrate on this right here.

So we're going to call Fibonacci with for you and I are going to write some code that is going to say

oh it looks like our Fibonacci function is being called with an argument that has never been called

with before which is for.

We will then run the Fibonacci function with four.

We will take the result from that and we will store it in some special location.

And so you and I will know that if Fibonacci ever gets called with 4 again we have already run that

situation we've already ran that scenario.

We don't have to execute the function again.

So if Fibonacci is ever called again with the number four we're not going to run the function itself.

We're going to go off to that special place in memory and retrieve that pre-computed result.

And so in practice here's Fibonacci four over here.

After we do that kind of caching layer as soon as we go over here and see Fibonacci 4 over here we are

going to say oh we don't have to do the recursive call here.

We don't have to go through all these additional function calls.

We've already ran Fibonacci with four and we already know what the value is or what that should be returning.

And so let's just return that right away rather than spawning all of these additional function calls.

So by doing this memoization process or by cashing all the results that come out of the function we

can dramatically dramatically improve the run speed of this function.

Now the one thing I want to be aware of here this is the very exact answer your interviewer is looking

for.

If they ask you how can we improve the runtime of this recursive solution right here.

They're asking you for a wise solution.

Now this is not something that's only applicable to Fibonacci.

There are many other interview questions or algorithmic questions I should say that can be answered

through this exact same memorization process.

So this is a great little tool to have in your back pocket because I can almost guarantee you you will

have an interview with someone who says hey this function looks really slow how can we speed it up.

And one of your first tools you want to reach for in that case is this memoization thing I'll get.

So enough talking about memorization.

Let's take a quick break.

We're going to come back in the next video and we're going to write some code to memorize this Fibonacci

function right here.

So I'll see you in just a minute.
--------------------------------------------------------------------------------------------------------------------

56. I Believe Its Memoization!

In the last section we spoke about how we can use memoization to dramatically improve the performance

of our recursive solution right here.

Remember I can't say this enough.

It is so incredibly likely.

In an interview that an interviewer is going to ask you to write out some problem or solve something

and then they are going to say to you how can we improve the performance of this thing.

If they see that it is entirely likely not 100 percent in time but it's very likely that they are referring

to memoization.

So this is a rather important technique.

So stay tuned and let's get through this thing.

Let's first start off by looking at a diagram that's going to help us understand how we're going to

set up memoization our Fibonacci function.

So you and I are going to write a function that we are going to call memo lies.

So we're going to write a brand new function.

This is going to be a generic memoization function.

When I say generic I mean that we can use this function that you and I are going to write not only for

this Fibonacci thing but for any other function that requires memorization as well.

So I'm going to show you a technique that you can just repeat in any interview setting and it's probably

going to work just fine.

OK.

This memoization function is going to be a function.

So this is a function right here.

We're going to call it with a slow function like our slow version of Fibonacci.

So we're going to take the slow version of Fibonacci.

We're going to pass it into this memo wise function and then the memorized function is going to return

a fast memorized version of for the notchy some of the words we're calling a function with a function

that returns a function base.

There's a lot of functions floating around here.

That's all I mean to say.

So let's put together some code to kind of set up this system right here.

So I flip back over the first thing I'm going to do here is to rename our existing function to slow

fib.

So I want to make sure it's 100 percent clear that this is the slow version of our function.

So I'm going to call it slow fib then right above it.

We're going to declare our minimalize function.

So this is the memo Lizer we're going to pass a function to it.

It's going to return a new function that has dramatically speeded up.

So whenever we call this thing we're going to pass a function into it.

So we will receive that as an argument called F.M. short for function then we will return a new function

right here.

So this is going to be our dramatically faster one this is going to be the one right here that is supercharged

and is much faster than the base version.

Now to give you an example of how you would actually apply the singing process or in practice excuse

me.

So we've got a slow here right here and we've got minimalized right here.

So an example of how we would use this thing in reality would be to do something like Konst fib equals

Mentawai is slow fib like this.

So we take our slow function we're going to pass it to memorize and then that's going to return a new

function assign it to fib.

And then we will export that minimalized version from this file.

So now all you have to do is add some implementation to minimalized right here.

So remember that the entire idea behind memoization is that we declare some storage area some place

where we can record all the arguments that are used to call the function and the respective result from

all those function calls.

So right above our return statement right here.

I'm going to declare a little object that is going to store all of our calls to the fast version of

our function.

I'm going to call it cache because that's essentially what it is.

It's a record of all the previous calls to this function and their respective results.

Next we're going to receive some arguments into the inner function right here.

Now this is the part that's really hard for people to understand.

OK so let's really focus on what's going on here.

When we called them Semmelweis we return a function.

So this anonymous function right here is fib right here.

This is the same as this thing.

So at some point time we're going to want to call fib with like 5 or whatever it might be right.

So this anonymous function right here is going to receive the arguments that were actually intended

to be sent to the slow fib function.

So we do not necessarily know how many arguments will be passed to this function right here because

we are making a generic version of memorize you and I know that yeah we're going to use it with Fibonacci

right here which only ever gets one argument.

But if you and I want to reuse this thing again in the future with some other function maybe it takes

two three four however many different arguments we need to code this thing to assume that we might be

receiving multiple arguments.

So to do that we're going to use a little bit of yes 6 or E.S. 2015 code.

We're going to say Dot dot dot X when we say dot dot dot ARGs that means I don't know how many how many

arguments this function will be called with.

Just take all the arguments and assign them as an array to this variable called ARX.

So this is kind of some defensive coding right here we are saying I don't know how many arguments a

singular receive all right now the next thing we're going to do is really check to see if this function

has ever been called with this particular set of arguments before.

So we're going to look at the cache object.

We're going to look at the key args and if something exists there then we're going to immediately return

that like so.

So this is the actual caching part.

This is the part where we say hey have you ever have we ever called this function with this particular

set of arguments before and store the results in this cache object.

If we have then just return that right now and don't do any other work and especially don't call the

original function.

So this is the actual caching mechanism in place right here.

Now if we get past this if statement then it means that we've never called our function with that set

of arguments before.

So we need to make sure we call that function take the result and cache it inside of our cache object

right here.

So we're going to say Konst result.

So this is going to be the result of calling our slow fib function.

We're going to call the original slow food function which remember was this argument efen right here

and then whenever we call a function with an array of arguments which this is right here we have to

use the Apply helper.

So this is a little bit of back to basics with javascript right here.

Zarian apply can pass in.

Yeah we're going to pass on this and Ark's like so if apply right here is a mystery to you.

I really recommend you flip on over to the Indian Web site.

Remember that's the Mozilla developers network Web site and read up on Apply a little bit because it

is kind of integral into how we make sure we call Ark's here.

Next we're going to take the result from calling our slow fill function and store it inside of our cash

object.

So we'll say at in the cash object at the key args store the result that we just created and then right

afterwards we'll return the result.

Okay.

So I know this is some crazy code right here.

This is bringing back flashes of that spiral matrix project we are problem we worked on earlier.

But nonetheless this is a working very generic minimalized function right here that will work for many

different functions that you'll create.

Let's go check our test now and see what's happening.

So in our test file when I run the tests you can now see that's the wrong set of us.

There we go is the right set.

So you can now see that we can correct the Fibonacci or calculate the Fibonacci value for 15 basically

instantly.

Now thanks to this memoization process.

Now I really do think that it still might be a little bit confusing on exactly how this is working.

So I'm going to do a quick review on how memorize works right now.

If you've heard me talk enough about it in years thinking like steamin I get it.

I understand memoization that's totally fine.

Pozza video.

Move on to the next section.

Otherwise we're going to do a quick review.

OK.

So quick review.

We had said that hey Colin's slow fib all the time recursively is extremely slow.

We need some way to improve the performance.

So we came up with the idea of saying before we actually call the slow fill function we are going to

create a little data store or a little cache object the keys of that cache object will be the arguments

that we were trying to call slow fib with and remember that are the arguments when I say arguments I'm

talking about like some number here 0 1 2 3 4 5 whatever it is.

So if we've never called Slow fib with a particular number and before then we will call slow fed then

we'll take an and the result and store it in this cache object.

And that's what we're doing with this statement right here.

But if we have called for slow feed before with some of the given value n then we'll look into our Cache

object we'll find that and then return it instead.

So the whole idea here is that we are just avoiding calling the same function multiple times with one

or something with the same set of arguments each time.

All right.

Now there's one other quick thing I want to mention here.

Something it's not super super great.

Notice how we renamed the function here to slow fed but inside that function we called fib.

So we're not technically calling the function from within itself.

You know we're calling this like kind of pseudo non-existent function.

So a slightly better way of putting this together would have been to leave this thing being named as

fib.

And then to just reassign overfed right here.

So this would have been a little bit better.

So now we have a function named fib and it's really clear to everyone like hey this thing exists here

is where it is.

But then right after it we immediately memorized that function and reassign it back to the variable

Philbrick here.

And the reason this is important is that when we do this right here and make sure that when we actually

execute the original function and attempt to call it recursively these fit calls right here are not

a reference directly to this function anymore.

It's now a reference to the men advised version of that function.

And so we kind of avoided that discussion by changing the name of this thing to slow fib.

I just wanted you to be aware that you know that.

Technically what's going on here.

You do have to make sure that when you recursively call the function you are calling the memorized version

and not the original non memorized version.

Let me give you just a quick example of that if we had been calling slow fib from inside this thing

fed contains a reference to the memorized version.

Slow food is always the slow version.

And so even though we memorize this thing when we call it recursively it would be calling the slow version

of fit which would entirely defeat the purpose of what we were trying to do.

We would be calling the wrong version of the function.

All right.

So hopefully that wasn't too bad.

Let's continue in the next section.

And we're going to move on to our next big problem.
---------------------------------------------------------------------------------------------------------------------
=====================================================================================================================

Раздел 17:The Queue

57. What's a Data Structure?

Now that we've spoken about runtime complexity and we've seen a good example of it with the Fibonacci

function we're going to move on to the next big chunk of content in this course which is data structures

data structures are all about runtime complexity and so all those discussions we had about identifying

runtime complexity and all that kind of good stuff is now going to get super relevant in the next set

of exercises.

Now when we start thinking about data structures in general especially in the context of an interview

there's two big important things I want you to remember.

So here's what they are.

First a data structure is some way of organizing information or data in your program with some optimal

runtime complexity for adding editing or removing records.

So in other words these different data structures that we're going to look at all have very well optimized

ways of accessing or editing data.

And so in the context of an interview usually a lot of these data structure questions are really themed

around runtime complexity.

If someone says to you.

Hey write some function that does X Y Z.

One of the first things that I want to get you to think of is what data structure can I use to solve

this problem that has some optimal runtime complexity for what we're trying to solve and we're going

to see many examples of this as soon as we start getting some background on these different data structures

and seeing what each of them are good for.

Now the second thing I want you to understand and this is something that's very confusing when you start

working with some classic data structures in javascript.

Right so this is something that will be a little weird javascript natively implements several very important

very core data structures.

Even so you're going to be asked about what I call your kind of inferior data structures.

That's not the best term in the world.

Let's look at a diagram that's going to help kind of illustrate what I mean by this.

So here's diagram kind of like I don't know not quite a pie chart but the big blue circle is kind of

demonstrating what a javascript array has the capability to do.

So the javascript array has a capability to do a tremendous number of different things.

Now down here in this tiny little white circle you know I'll make it like as small as I can possibly

make it basically this tiny little circle of functionality right here is what a cue does.

And so what I mean by this diagram right here is to say a javascript array does everything that a classic

Q data structure does.

Nonetheless you will still have interviewers who ask you to put together a queue from scratch.

That's what I'm trying to get at here.

So there are portions of javascript that take care of these really fancy data structures for you automatically.

However you will still have interviewers ask you to build these tiny little basic things from scratch.

Now in some cases especially in the QCA case of a Q or an array we're going to use a javascript array

to represent a queue and that's the part that is kind of confusing when you start doing this interview

stuff you're thinking like wait why am I making a queue when I could just use an array.

But wait.

I'm going to make a queue out of an array like that doesn't make any sense.

So this is just one thing I want to kind of introduce you towards and get you thinking about as soon

as we start working on queues and stacks in particular.

Speaking of which the very first data structure that we're going to look at in the next section is a

queue.

So let's take a quick break.

We're going to continue in the next video.

We're going to start to discuss exactly what a Q is and how it works.
-----------------------------------------------------------------------------------------------------------


58. The Queue Data Structure

The first data structure that we're going to take a look at because also one of the more straightforward

ones.

So we're going to get a nice gentle introduction to data structures here in this video.

We're going to start to discuss Qs.

So let's take a look at what a cue is a cue can be thought of as like a container of sorts where records

or pieces of data enter on one end of this container and then exit on the other.

You can really think of a cue as being very much like waiting in line to buy tickets from some ticketing

counter like for a train or for tickets from the movie theater.

In this example you can imagine that the line of people waiting to get to the ticket counter is very

much like a queue because a person will enter into the line at the very end.

Then they have to wait in the line until it's their turn to emerge from it and approach that ticket

counter in a queue.

There's no idea of skipping or cutting in line.

So the order in which you get into this queue also dictates the order in which you come out.

The process of adding a record into a queue is referred to as in queueing or adding a record and then

taking something out from the other end is thought of as deep queuing or removing a record.

You'll see these terms used interchangeably.

Now I want to expand on what we spoke about just a second ago with maintaining order in a.

So AQ follows what we refer to as a first in first out principle were abreviated F-I F.O..

If you feel like it I don't know.

So let's imagine the step by step.

Let's start off.

Out start out up here with nothing in the queue.

So we've got two records right here outside the queue.

And we want to add record eight into the queue.

So here we just added a is now sitting in the cube by itself.

And then in this next step we can insert B or add B into the queue.

Now when we attempt to remove a record the first thing that is always going to come out will be record.

So the first record that goes into the queue is also going to be the first one that comes out.

And that's why we call it first in first out.

Now here's the interesting part about QS that's very closely related to what we spoke about just a moment

ago with Howard javascript natively implements a lot of these data structures.

So in an interview setting if a interviewer says to you.

Hey implement a Q for me.

Or if you start working on an algorithm and you realize oh it would be really helpful this year remember

that when we are working with javascript we really don't have such a thing as a rudimentary cue.

We have javascript arrays which are super hyper functional in nature.

They've got a ton of different methods attached to them.

A ton of different ways of interacting with them whereas a queue has just this tiny little API attached

to it.

We really just have the ability to add records in and pull records out.

On the other side.

So again this is the part where in the last video I said that this gets a little bit weird in javascript

when we want to implement a queue.

Usually what we end up doing is taking an array and then restricting the methods that can be used to

enter in to interact with that array.

So if you really think about it a javascript array adding an item to the very front of an array it with

javascript is done by using the unshipped method and then removing something from the end of an array

is done by using the pop method.

So a very common way of implementing a queue would be to do something like this right here.

We might make a queue class like an E.S. 2015 class inside of that class.

We will initialize an empty array.

Now this array has all these different methods associated with it.

It has all the capabilities in the world but to make sure that its really clear that we are producing

a Q and so its something that should be interacting with only as a queue should be we will usually only

expose the unshipped and pop methods outside of the class.

So in other words whenever we make a cue with javascript we usually make an array but we do our best

to hide access to all these methods that belong to the array.

So your immediate question here might be Stephen why in the world would we do that.

Why would we take an array and purposefully kind of handicap it here and remove some of the methods.

Well there's two answers to that.

On the one hand in an interview setting it's kind of obvious if your interviewer says make a cue.

Well we're going to make a Q and we're going to do whatever they say.

The other reason for kind of hiding the functionality of an array in more of a practical setting are

like on a real project maybe imagine for a second you are working on some complicated problem and you

want to make you want to solve the problem with an algorithm using a queue and you realize that if you

use a queue it will be a fantastic algorithm like the best one in the world possible for solving this

problem.

But if you interact with that queue as though it were an array then all some of the performance of that

goes downhill.

So one possible reason to use a queue and try to obfuscate all the other methods that an array has would

be to make sure that if some other engineer came and started looking at your algorithms sometime in

the future they wouldn't go like oh this is an array I could just treat it like an array and reorder

the elements inside of it or remove the first element out of it or whatever it might be.

So in the real world if we want to create a new class.

Yeah we will still use an array behind the scenes and limit access to the methods on it.

And the idea there is that if we make an I.Q. It's because we very specifically want to use a cue and

don't want to treat it like an array.

So there's just one possible example.

OK.

So here's the idea behind the queue.

We are going to make a key from scratch.

We're going to make a cue and we should be able to you create a new one by calling something like this

right here.

We should be able to add a record to the cue by calling some Add method associated to it and then we

should be able to remove records or dequeue records from it by calling some method called Q Don't remove.

So I wanna make sure that in the next video when we start this exercise we'll you know we'll put this

documentation into the actual document that we're going to be working on.

But just to be clear this is essentially what we're going to try to create by making a cue.

OK.

So quick break and we will continue in the next video.
-----------------------------------------------------------------------------------------------------------

59. Implementing a Queue

In the last section we got an introduction to cues.

We're now going to continue by implementing a cue from scratch with javascript.

After we do this we'll then take a look at some different questions that are related to cues.

So let's get started inside of my q directory and my code editor.

I'm going to open up the index database file and I'm going to make sure that I start up my tests as

well.

So over at the command line will do just Q test.

J.S. watch like so and then we're going to have about four tests.

So make sure you have four running.

All right.

So let's take a look at the index dot J.S. fight the description at the top pretty much mirrors everything

we were just saying about cutes.

It is a data structure that has some methods named add and remove if we add a record to the queue.

The queue should store it until that element eventually gets removed.

Now notice that we want to implement a Q as an E.S. 2015 class.

So we should be able to run some code like this right here to actually interact with it.

For example we need to call new queue to produce a queue.

We should be able to call a queue.

Add And then you don't remove.

To get back the element that we just added.

So for this first data structure that we're going to work on we're going to do this one together just

to give you an idea of what a typical implementation in javascript of a very basic data structure like

this would look like on future ones.

Definitely to let you do it on your own but for this first one just to make sure we're on the same page

we'll do it together.

OK.

So inside the queue class right here I mean give myself a little bit of space.

Now the first thing that we need here is something to actually hold data inside of our queue like something

to actually hold these records in order.

And so this is what I was saying before about how and why we need to use an array from javascript.

So here is our Q class.

What we're making right now.

We're going to create an array inside the class and the array is going to be the thing that actually

does the storage of data and all that kind of good stuff.

It's just up to us to implement these add and remove methods.

And he said essentially we're really just going to make sure that they map up to that arrays and shift

and pop methods.

So if this seems like kind of cheating or something like that if it seems like why are we making a queue

when we're really just working with an array here.

Again this is just what we do.

You know sometimes you want to have specifically something with a q API.

And so this is really not totally outside the realm of possibility.

This question really makes a lot more sense if you're working with some more low level languages where

implementing a queue is kind of a necessity.

Anyways let's get to this.

So back inside my code editor we're going to first make sure that whenever we create a queue from scratch

it's like use the new key word on it.

We are going to initialize an array and assign it to the instance of the queue that is created.

And so the only location inside of a class that we have to run some initialization code is in the constructor

method.

If you haven't worked with E.S. 2015 classes before all you really need to know is that whenever we

create a new instance of a class if we define a function called a constructor inside of it that constructor

will automatically be called when we create a new instance.

So inside this constructor we're going to create a new array and assign it as a property to our queue

instance.

So I will say this dot data equals empty array like so now I'm totally making up the name data right

here like this can be anything we want.

It really doesn't matter.

I'm just saying to store actual data.

We will assign our raid to this data property.

Next we're going to add our add method.

So underneath our constructor method will add another method called ADD.

Let's zoom in just a little bit by the way this add method will be called with some record or some piece

of data that needs to be stored inside of our array so we can refer to that simply as no record.

That's really fine.

And then we are going to insert this new record into the underlying array that we are pretending is

our actual queue.

Remember the goal here is to make sure that we add this new piece of data in to the front the front

of this data structure or this array right here.

And so to add something into the start of an array in javascript we can make use of the unshipped method.

So I'll say this dot data dot on shift will pass in the record like so as a very quick aside just to

make sure you're on the same page here with on shift.

If I have an array right here and I call on shift on it's on shift it adds that record to the very start

of the array.

So if I put in here like two three four.

Notice how when I shift something it gets added into the start.

And that's exactly the behavior that we want to have with the queue.

All right so back over here the last thing we do now is implement the Remove method so remember remove

should take whatever is on the opposite side.

So the end of our queue and return it.

So we'll implement remove to get the last record out of an array.

We can use the pop method.

So we'll say this data pop.

And then as usual we will be really sure that we add in the return keyword because remove is supposed

to not only remove that record from the end of the queue but you know obviously we probably want to

return it as well so we can work with that record that we just removed.

All right.

So let's see how our tests are doing.

And that's pretty much it for trespassing.

So does it feel easy to work with javascript.

Yes it does.

You know to be honest here we are relying upon an array for the actual data structure.

And that's really the array that is doing all the heavy lifting.

If we were using a much lower level language making a cue like this would be obviously a little bit

more challenging but with javascript it's pretty darn straightforward.

OK so that's pretty much it for you.

Again the biggest uses of a Q is always going to be in an interview setting.

When your interviewer specifically says to you use a Q to do X Y Z.

So let's look at a question or two that might involve a Q So I'll catch you in the next section.
--------------------------------------------------------------------------------------------------------------
==============================================================================================================

Раздел 18:Underwater Queue Weaving

60. What's a Weave?

Now that we've got a better idea of how to use work let's try a little practice exercise with them.

So inside of my We've directory I'm going to open up both the index file and the queued up G-S file.

So this time around two separate files are then flip on over to my terminal and make sure I'm running

my tests for this exercise.

So we'll run just we've test on J s dash dash watch you know we've got about four tests going.

All right let's see what's going on here.

So this is the first exercise where we are going to be doing two separate things or working between

two separate files.

So the directions at the top of index start us tell you to first flip on over to that.

Q Jay Yes file and follow the directions in there.

So let's go look at that first.

All right here's the key.

Yes file.

And here's the directions that it's telling us to do.

So we're supposed to implement a peak method on this q class Q is supposed to return the last element.

In other words the next one that is about to be removed from the cue without actually removing it.

So that's the key here.

It's like remove but we're not actually removing it.

Peak is supposed to do is exactly what it says.

It allows us to kind of peek at the next element that is about to come out of the cue.

So that's the goal here.

You will take care of this little task first and note that there are a test or two over here that has

to do with peak.

So if we go over here yes.

So here's some tests around peak.

So you can verify and make sure that it's working correctly.

It goes flip back over to the index start geas file now.

So that was Task 1.

Now move on to task to the goal of test 2 is to implement a weave function.

Weave is going to be called with two separate cues as arguments.

And the purpose of the function is to combine them both into one brand new third cue and return it.

This third Q should contain the contents alternating from the first two Qs.

So we've as very aptly named We're going to take you to cues and weave their contents or alternate their

contents together.

Note that those two source cues might be of different lengths.

So you need to make sure that you're not accidentally inserting undefined into that brand new cue that

you are going to make.

So you need to look at the elements that are coming out.

Or maybe peek at the next element that's going to come out and make sure that actually exists before

trying to insert it into that new cue.

Now the last thing here do not try to abuse the fact that the q class is just wrapping an array so do

not access the array directly that is sitting inside of these queue classes only interact with them

using the Add Remove and peek functions.

So if you scroll down a little bit there's a good example right here and then a little bit lower is

the wave function.

So we will be called with these two Qs right here so.

Source one in source.

And you have a require statement in here already for the q class so you can use this to create your

own new Q..

The third one and then combine source 1 in source 2 into the new Q..

That you will create.

Now one thing to be to keep in mind here.

When you create a new queue or the third one that you're going to return from this function.

Make sure you create the queue inside the function itself like so don't create create the queue outside

of the function you want to make sure you create it inside it.

Now just in case the directions are not entirely clear I'll give you a quick diagram here.

So in this diagram we have source Q One and source Q to do.

Keep in mind how Q's work.

They usually flow diagrams from left to right.

So the next element that's about to be ejected from source Q One right here would be you.

So we would take this element stick it into result and then the other source Q to over here.

Stick that in.

Then we alternate back to one two three four.

You get the idea and then just be really clear.

Remember those two Qs might have different lengths assigned to them so if they do have different lengths

we want to make sure that we don't accidentally try to remove elements from an empty queue and stick

it into this new one.

If we try to remove an empty element from this key right here we will end up with undefined inside of

the third Q that we create and we definitely don't want that.

So make sure you are not overpumping or over removing so to speak from one of these Qs.

OK that's pretty much it.

Go ahead and give it a shot.

I'll catch you in the next section where we will go over the solution to his problem.
-----------------------------------------------------------------------------------------------------------------

61. How to Weave

Hopefully you had some success in implementing both the weave and peak functions and this video we're

going to go over the solution to both.

We're going to first start off inside of our Q Jay s file and implement that peak function before we

do.

One quick thing I want to clarify.

You'll notice this note down here while where I said do not access the array inside the queue that was

specifically talking about Part 2 of this task for part 1.

You definitely are able to and can and absolutely should access the array sitting inside the queue.

So for the peek function we are going to work directly with that array.

I do apologize if that was a little bit unclear.

All right.

So inside my weed directory I'm going to find the queue.

Yes file.

So inside of here where you have our class queue I want to add another method called Peke to this thing

that is going to return the last element or essentially the next one that is supposed to be returned.

All right.

So down at the bottom I'll add a new method called peek.

Now first we need to get access to the last element or the next element that is going to be returned

from calling remove on this queue.

So that's essentially the last element inside of our data array to get access to that last element.

We can reference this data at this dot data length minus one like so and then we will return that from

this method.

All right let's check our test over in the terminal and see if we have our tests around peak working

now.

So rerun my tests and it looks like yup the two tests that were written around peak appear to be passing

correctly.

So I think that we're in a good spot.

So now we can move on to the weave function back inside my code editor I'll change back to the index

J.S. file and then I'm going to scroll down to the function.

So I think that the first step here is pretty clear I think that we need to create a new queue that

can store the combined result of source 1 and source 2.

So say Konst Q is new.

Q Next we need to make sure that we somehow iterate through all the different elements inside of source

1 and source 2 without accessing the arrays inside them.

And so that's where the peak function that we just defined on a queue is going to come into play.

I think that we can probably somehow figure out how to iterate or how to run some chunk of code as long

as either source one or source too has an element that is being returned from peak.

Remember if there are no elements left inside of our data array in the queue then the peak function

will probably return undefined.

And so that's a key point that we need to keep in mind.

So I think that to iterate through all the elements in both these queues right here we can probably

use a while loop.

So if we use a while loop we can say that as long as either source one or source two returns a undef

a not undefined value.

That's kind of unclear but a value that is not undefined from their peak methods then we should continue

iterating with this while loop.

So in practice essentially what we want to say is source one peak or source to dot peak like so.

So as long as either one of these is returning a method then we're good to go.

Next inside the while loop itself we're going to add some logic to first take an element out of source

1 and add it to our queue and then take an element out of source to add it to our queue.

The thing to keep in mind here is that we're not quite out of the weeds with making sure that we are

not pushing undefined values into this third queue just yet.

So remember we are saying or here in looking at whether or not we should continue our while loop.

So it's entirely possible that source one could run out of elements but source 2 could still have elements

inside of it and based on the conditions of our while loop right now we don't really have any idea which

one still has elements inside of it that we want to continue to pull out.

So in short we have to check that peak function again on both of these queues and make sure that they

both still have elements inside them before we attempt to take something out and insert it into the

third queue.

So we're going to say if source 1 Don't peek.

So if there's still an element inside there we'll say q add source 1 dot remove like so and then we're

going to repeat the same process for source 2 as well.

So if sourced to speak to dot add source to remove all rights that's looking pretty good.

And don't forget I can't say it enough and all these questions you always want to make sure that you

have some defined return value.

So at the bottom of the function after doing all this combination we will finally return.

Q Let's check our tests and see how we're doing.

And we have for trespassing.

Fantastic.

So this is looking pretty good.

I think we've got a great solution here.

Let's continue in the next video where we're going to move on to our next data structure that is very

closely related to Qs.

So quick break and I'll see you in just a minute.
----------------------------------------------------------------------------------------------------------
==========================================================================================================

Раздел 19:Stack 'Em Up With Stacks

62. Stack Data Structure

We're now going to move on to our next big data structure the next big data structure that we're going

to discuss our stacks.

So in this section we're going to take a look at some diagrams around stacks.

Understand what they are and then we'll get started on a written implementation of a stack.

In general you can think of the stack as being extraordinarily similar to a queue.

There's just a couple items here and there that are slightly different.

So with the stack we are still dealing with an ordered list of records and you can imagine that those

records are living inside of some container which is the actual stack.

Adding a record to an existing stack is referred to as pushing.

So we might say that we are pushing a new record onto a stack when it's time to remove a record or take

it out of the stack.

We would refer to that as popping or popping a record from the stack.

And the big difference between the stack and the queue are the order in which items are added and removed.

So with the queue we had that acronym foe or first in first out with the stack we deal with Thilo or

first in last out.

So look at this diagram format you can imagine here the big white box is our stack.

So if we first push in record a to our stack so the zero here is saying we are going to push record

eight into our stack.

We would then have records inside the stack.

If we then pushed in B B would be conceptually sitting on top of record.

So then the first time that we popped the record or removed a record out of the stack it would always

be B because the first in item is the last one out record day.

Here was the first one in.

And so it's going to be the last one out.

Another way of thinking about it then might make a little bit more sense is to say the last record in

the first record out so deal was the last one.

And so it's the last one to come out.

On the other side again you should really think of a stock as being very similar to A.

We're just making a small change here as far as the ordering of records are being removed from this

data structure.

So in implementation this ends up being very much similar like the code we're going to write to implement

a stack will look very very much the same.

Before we flip on over to our code editor and start on our implementation I want to focus on the three

methods that we're going to implement to create a stack.

So just like we discussed adding a new record to the stack is referring to is referred to by saying

that we are pushing a record.

So we would make a push method on our data structure that would take a record and add it to our stack

to pop method or seeming to pop a record.

We would create a pop method and the idea there is that we are moving an item from the top of the stack.

Now nuda said I put in here quotes for top because in code there really is no top or bottom to the stack.

These are more kinds of conceptual items that we keep in mind.

Finally we can actually implement a peak method which would return just the top record without actually

removing it or popping it off the stack.

So these are the three big methods that we want to think about.

So without further ado because this data structure is so similar to queue I think that will kick off

the implementation in this section no need to split out to a separate section in my code editor.

I'm going to find the stack directory and open up the index js file and then of course I will also start

my tests by running the command.

Just stack slash test dot J us dash dash watch

and we should see about four test passing here.

Very good.

OK.

So the directions here pretty straightforward.

We're going to write methods push pop and peek.

Now keep in mind that we also need to have some type of record keeping structure inside this class.

The stack class to actually hold on to in order our records.

So remember in the javascript world whenever we implement some of these Bayda basic data structures

we sometimes use an array to actually implement the underlying data structure that can contains our

data.

So I kind of expect that you're also going to end up implementing a constructor method on this class

as well.

And initializing an array and assigning it to something like this dot data.

In general I really recommend you go back and look at the code from our CU example because it's going

to be very very similar to that Q class.

There will just be one or two little terms that end up changing.

OK.

So go ahead take a shot.

I'll catch you in the next section and we'll start to look at some solutions.
--------------------------------------------------------------------------------------------------------------

63. Implementing a Stack

Hopefully you had some success implementing the stack data structure in this section we're going to

go through some javascript implementation of a stack.

Now the thing to keep in mind here is that we're still going to be making use of an array to hold the

actual data.

And so we are essentially really just writing some accessor methods to kind of hook this stack class

up to the underlying array.

So with that in mind let's get to it.

I need to get myself a little bit of space here.

And then the first thing I'm going to do is to declare my constructor function because I need to initialize

an array when class stack is instantiated.

I will then use that internal array to manage all the data that gets added and removed from our stack.

So I create my constructor and then inside of your I will initialize an array and assign it to this

dot data like so.

Remember there is absolutely nothing special about assigning this ray to this dot data.

It could be this dot underlying container or this dot my stack or this dot my array whatever you want

it to be.

I'm just arbitrarily calling this thing this dot data.

So that will give us the underlying array that holds our actual data.

Next we're going to put together our push method so that we can push the record onto our stack.

So I will create a new method called Push.

It will accept a record as an argument and then we want to take this record and stick it into our array.

Now of course the arrays have an underlying method or have a method on them called Push that does the

exact same thing that we want to do.

So the push method adds a record to the very last index of an array.

So we'll simply say this data push like so now to make sure that we always get back the last record

or the most recently inserted record whenever we pop from our stack.

We can call the exact same named method on this array as well for our pop method.

So we'll add pop in for this one simply say return this dot data pop.

So if you're familiar with the push and pop methods on an array and I am really assuming that you are

here.

Yeah that's pretty much exactly what haystack is doing for us.

Not a lot of complexity here when it comes to the javascript implementation.

Nonetheless I do want you to kind of have an idea of how these things are put together in the javascript

world and the very last method we have to implement is the peak method.

So we'll add Teec.

And our goal with peak is to return the last record inside of our array without actually removing it.

So we can simply access this data at the last index.

So this data length minus one.

And then we want to make sure that we return that record.

All right.

So really not that bad just four methods four lines of code inside them total.

Let's check our test out to see how they're doing.

And yep we got for trespassing here.

So again whenever we think of a cue in a stack essentially identical except for the order in which we

are adding and removing records and heck I shouldn't even really say adding adding is the same.

The only real difference here is the order in which they get removed when we take them out of our data

structure.

So the two of them are very similar.

And to be honest there are not a tremendous number of interview questions that you might see around

QS or stocks directly.

Usually a lot of questions around user stacks are to say hey do X Y Z operation but you have to use

a queue or do X Y Z operation and you have to use a stack.

And so we'll see a very classic example of the type of interview question you will see with queues and

stacks and the next section.

So let's take a break and tackle that question.

See you in just a minute.
----------------------------------------------------------------------------------------------------------
==========================================================================================================

Раздел 20:Two Become One

64. Queue From Stack Question

In the last section we got a brief view of exactly how a stack works.

We're now going to combine stacks and Qs together and look at the bar none most common interview question

that you're going to see around both of these data structures.

So inside of my code editor I'm going to find the directory marked Q From S and then open up the index

dodgiest file inside there.

As usual we will also flip on over to our terminal and run just Q From ass slash test on J s dash dash

watch to start up our test as well.

And so over here we're going to expect to see about five tests total.

OK let's look at our directions.

So the first thing that you should understand is the that the name of the sexercise Q From S is short

for q from stack.

So the goal of this exercise is to implement a new data structure using two stacks.

So you and I are going to create two separate stacks and we're going to use those to implement a queue.

It's going to be kind of an interesting challenge because it's going to really make sure that you understand

some of the differences behind a Q and A stack.

And it also requires a little bit of problem solving skills.

Now the first thing I want to tell you here is no cheating allowed.

So we're not going to create an array inside the queue class.

If you scroll down a little bit you'll see that I already provided you with an implementation for a

stack.

So this is the same stack that we just put together in the last video.

So you have to create two of these things right here.

Two stacks.

You're going to create two stacks yourself and then you're going to use those to kind of fake the behavior

of a cue.

Let's look at some of the other directions here.

This Q class that we're going to put together this kind of Sudoku or this fake you should add the methods

or implement the methods add remove and peek.

So essentially the three methods that we had added to a cue when we previously put one together.

If you need a reminder on which of those do well of course go back to the cue exercise and take a look

at each of them.

Now there's an example right here.

So just to make sure it's really clear we're going to create or the expectation is that we could use

this class cue that we're going to make.

We should still be able to call Q and Q and we should get a peak from it and remove records as well.

But this time around for the actual storage of records we are not making an array.

You are going to create two separate stacks and somehow manipulate those to imitate exactly how a cube

behaves.

So if I put this in Diagram format very simply this is what we're doing.

Stack one stack to somehow manipulate these things to fit together to simulate a cue.

Now this is a classic example of a question where once you solve at one time or once you see the solution

one time you're going to remember the solution for all eternity.

Another one is classic.

You've either seen it or you haven't questions.

So if you are completely stumped right now if you just can't even possibly imagine how you might approach

this.

Don't sweat it.

At least give it a little shot.

You know maybe put together a diagram and think about how you might do this otherwise.

Continue with me in the next section and we'll take a look at the solution.

So at this point feel free to tackle the solution here.

I'll leave it all up to you and we will meet up.

And the next video and start looking at how to solve it.

So I'll see you in just a minute.
---------------------------------------------------------------------------------------------------

65. Creating a Queue From Stacks

Hopefully you had some success putting our cue from Stack problem together.

Now in tackling this problem you're going to very quickly realize that it's just another one of these

problems where as soon as you see a solution you say Oh OK.

Yeah makes sense.

I'm ready to do this now.

So rather than trying to be clever and very gracefully explaining the solution here we're going to take

a look at a diagram that's going to very directly show you exactly how to address this problem.

And then once you see that I think that a Leipold might click and you say OK that makes sense.

So let's take a look at a couple of diagrams are going to help us understand exactly how to approach

this.

OK.

So remember we are working with two stacks here.

So I have labeled stack A and stack beat stack a stack B follows the route follows the rule of stacks.

Right.

Well of course that makes sense but the rule of a stack is that the first record in is the last record

out.

That's not the behavior we want to hear.

We don't want stacks.

We want to make a cue and the common characteristic of a cue is first in first out.

So that's what we really want to do here.

We can forget the terminology of stacks and cues.

All we really want to do is think of how we can use these two things right here to make a first in first

out principle.

So let's figure this out.

The first method we're going to discuss is at.

So we're going to first figure out how to implement the add method.

So for the add method whenever we add a record we're going to take that record and add it directly to

stack.

We're going to pretend like stack B does not even exist.

So we're going to take this screen record here.

Let's say we want to add it to our overall cue structure.

So we will add it to stack.

Right then we want to add in say record blue and we'll take blue and we'll add it in to stack.

And then for red We'll add it in to stack.

Now remember if we called Pop directly on stack AA the records that we got out would be the reverse

of what we actually want.

So we called Pop on stack.

We would get back red.

That is a first in last out methodology and that is again not what we want to solve this problem we

want first in first out.

So at this point if we called remove or pop or whatever on our kind of synthetic data structure here

my expectation would be to get out green.

So we need to figure out some way of getting green out of this thing.

But remember with the stack we don't have any way of reaching directly to this item at the very bottom

of the stack.

We need to somehow figure out a way to get at this record green right here with only the ability to

remove or add records from the very top of the stack.

So let's look at a diagram to explain the Remove method.

And we're going to figure out exactly how that's going to happen.

So again let's assume that we added in green blue and red to stack.

And now we want to somehow get access to stack to record green right here because if we were to remove

from this thing we should be getting back green because we want to follow this first in first out methodology.

So here's how we're going to do.

This is like you know all this talking I'm doing it all comes down to this.

Here's what we're going to do when we want to get our record out of here.

Are you going to pop records out of stack.

One at a time.

For every record that we pop from Stack.

We are going to push it into stack beat.

So I will pop from a.

That removes it.

I will then take that record and push it into stack beat and so goes down here to the very bottom of

stack B.

I will then iterate through all the remaining records here and when I say iterate keep in mind that

we can't iterate directly through AQ we have to look at or use our peak method to see if there are any

records left that we can manipulate.

So we will peek at the next record.

We will see Yep something's there.

It's blue.

We will then pop it out.

We will push it into stack B.

We will then peek at Stack a again.

We will pop it out.

We will push it into stack B.

We will then peek at Stack a.

One last time.

And when we peek this last time we realize oh ok.

There's no other record here.

Stack is now empty.

So at that point we will then say are the record do we actually want here must be the next record that

is going to come out of stock B.

So all we have to do is pop from Stack B one time and there's the record that we want to actually return

from our data start from our Q data structure.

From this kind of synthetic remove method that we are creating.

So essentially move everything from a Over to be pot from B one time and there is our record.

Now before we just return this record right here there's one more thing we have to do.

We need to make sure that we restore everything back into stock.

To get ready for our next operation because who knows it might be a remove operation again in which

case we will want to move everything over to stack B again.

So before we return Green we will call peak unbe will say is there anything here.

If there is we'll pop it out push it into a we'll call peak on B again if there's anything there we'll

pop it out push it into a we'll call peak on B again we realize there's nothing else here.

And so we're all done ready to now return from the Remove method.

So that's pretty much it.

That's the whole shebang.

Now with that in mind I bet you can kind of guess how the peak method gets put together.

So peak care we're doing essentially the exact same thing.

The only difference is that this time when everything moves over to stack B We are not going to pop

green out of there.

We are only going to peek out of the stack to be so we can soome here.

We'll go through it very quickly if we add in a blue or Sumi green blue red will then pop red over pop

blue over pop green over.

Stack a is now empty so there's nothing else for us here to do.

That means we can color peak unbe.

We can peek at that will peak the first record here.

So that's green.

And then once we've picked it we can then pop everything out of B one at a time and push it back over

to a like so now if this sounds like it's an amazingly inefficient.

The answer is yes of course it's very inefficient but it's an interview question is just made to help

you understand or to show I should say that you understand how cues and stocks work.

That's the whole idea here.

Of course you're totally cracked.

We would never implement this data structure in the real world.

But as you've seen there are many types of inner problems that we end up having to do that have absolutely

no real world implications whatsoever.

So anyways that's a whole separate discussion.

OK.

I think that we've got a better idea of how to put the solution together.

So let's take a quick break right now.

We'll continue in the next section and start working through a written solution to this.

Q From stack problem.

So quick break and I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------

66. More on Queue From Stack

In the last section we spoke about our solution to it.

Q From stack problem in this section we're now going to start to implement that solution.

So inside my index file in the queue for a mass directory I'm going to scroll on down to the class queue.

So this thing right here is where we want to add our functionality.

All right.

I'm going to give myself a little bit of space here.

Now the first thing to recognize and this was something that I didn't really write out in the directions

so this was something for you to kind of figure out on your own.

The first thing to recognize was that we needed to create two stacks.

When ever we create an instance of this Klasky right here.

So inside of our constructor method you check your spelling because I just made a mistake myself so

constructor right here we're going to create two stacks and assign them to this instance of the queue.

So we'll say this first to represent our first stack will be a new stack and then this second will be

new stack as well.

So this right here might have been a little bit unclear.

I kind of you know tested the waters here.

Hopefully you found some some success understanding the had to do this as step one.

So now whenever we create an instance of a cue we will automatically generate two stacks and assign

it to this cue class.

All right.

Now the next thing we're going to do is implement our Add method as we saw just a moment ago looking

at our diagram the add method is really straightforward.

All we're going to do is take the record we're trying to add and we're going to push it into Star-K.

So I'm going to define my add method.

It's going to accept a record.

Now this doesn't have to be called record you can call it record data whatever you want to call it.

I'm just going to call it record.

We're going to take that record right there and we're going to push it into our first stack.

So we'll call this first push and we'll pass in our record like so.

All right.

So now if we created an instance of a Q and called add on it multiple times like let's imagine with

multiple colors here we could add into it green blue and red.

So now after adding those three records if we called remove on our cue structure my expectation would

be that I would get back the record green right here.

So let's now implement every move method.

So this is where the bulk of logic is going to come into play.

So here is remove.

So we want to make sure that we iterate through all of the records inside of stack a for every record

and saké we want to pop it out and push it into stack B.

The next thing to recognize here is that whenever we say iterate through we really only can tell whether

or not there are any remaining records inside of stack.

Through the use of that peak method.

So we're going to do is we're going to call the peak method and so long as it returns a record we will

continue to iterate and continue to push records from a overed to beat.

Now I don't know about you but the first thing that comes to mind when I describe what we're trying

to do there is a WHILE loop.

So we're going to set up a while loop and we're going to continue running that while loop.

So long as this first peak which represents stack right here returns a truth value or returns basically

a value.

So inside of a remove method will say while while this first peak peak as long as this keeps returning

a value right here as long as there's still something for us to operate on we will pop out a record.

So we'll say constructed is this first pop and then we will push it into our second stack.

So this second push and we'll add our record into it.

Now when you look at these two lines of code right here I wrote it this way just to make sure that what

we're doing here is very clear.

But of course this can be easily combined down into one line.

So rather than using this temporary variable of record I'm not going to say that I want to push in this

first pop.

So just take whatever we are popping out of there and immediately push it into the second stack and

then we don't need this extra line of code right here anymore.

So this will iterate through all the records inside of our first stack as long as there is something

to pop out of there.

We will continue to pop out and push every record in order into the second stack.

Now just to make sure it's really clear when this loop right here comes to conclusion when it's all

done.

That means everything has been moved over.

So every record has now been moved over to Sabby.

So like we said before to now somehow get access to or somehow return the record that we really care

about here.

We have to pop out a stack B and that will give us record green.

So right.

I'm going to say Collins record.

This is the record that we actually want to return right here will be this that second pot.

Now remember take note here that we are not immediately returning.

So we're not saying Return to start second pot because we don't want to return yet.

We do want to see a reference to this record right.

We want to save a record to save a reference to it.

But before we return we want to make sure that we restore the state of our stacks here.

So we want to first make sure we pop everything from Stack b back over to saké and that gets us ready

for the next call to the Remove method.

So in Meili underneath that assignment we will do the exact same loop that we did right here.

But this time around we're going to be looking at the records inside of the second stack.

And for every record in there we're going to pop it over to the first stack.

So we'll say while this second notice second right here.

Peek.

So so long as there is a record there.

I want to push that into the first stack and I want to take that from this second pop.

So take every record out of the second stack.

Or not.

Not every record right here to Spickler just one record at a time.

Pop it out and then add it to our first stack.

So this will return us back to the original state.

We'll put everything back into stock.

Once that's all done.

Now we are ready to return a record.

Now we want to return the record variable right here.

So we will return record like so.

OK.

So here's our move method.

That's it for the implementation.

Let's check out our test really quickly.

Well it looks like we still have some we have some passing tests but it looks like our peak method is

still failing the test because we have not yet implemented it.

So just to be clear yeah.

Is a separate method.

We've only added add and remove Now the peak method itself is going to be nearly identical to what we

just did here for a move.

Remember we just discussed that in the last section look at the diagram for peak.

So we're going to put everything over to be again but this time once everything has been moved over

to B we're going to peek at the devil will give us a reference to this record right here and we will

return that reference.

So we're not going to pop this time from the we're just going to peek B after we peek at B We will then

again restore everything back over to stock.

Like so.

All right let's give this a shot.

So we'll define our peak method will say while there are still records in the first stack we need to

take that record.

So this first pop and I want to put that into this second push.

So we've got this second push.

And then inside of a set of parentheses we are calling that thing with this first pop that immediately

beneath it.

This is where we're going to get a reference to the top record inside of second.

So to get a reference to it we're just going to speak from him or we're not going to pop this time we'll

say Konst record equals this second dot peak right here.

This gives us a reference to that green record.

And then finally we'll take everything out of that second stack and move it all back over to the first

stack again.

So while this second peak by the way make sure that you've got parentheses after both the calls right

here.

You don't want to just be calling this second peak without the Prince.

Make sure you got the prince there.

So while we still have records inside of the second stack We'll take every record out there one at a

time and push it into first.

So this first push this second dot pop and then finally at the very bottom will return the reference

to the second record.

So return record like so.

All right let's check our test now and it looks like everything is passing.

All right.

So not that bad.

You know the big challenge here.

Like I said How about just seen the problem one time.

I think that as long as you kind of understand that first part of OK we're going to put everything into

stack a.

And then whenever we want to remove a record we need to pop it all in a stack B and then pop the top

of stack.

B one time that's challenge number one then challenge number two is figuring out how to iterate or kind

of process through all the records in the stack and that's done by using a while loop along with the

peak method right here.

So hopefully this wasn't too bad.

Again this is probably one of the most common interview questions you're going to see with stacks and

cues.

And like I said before.

Yeah.

No practical application but that's the life of interview questions.

So hopefully this was a enjoyable experience.

Let's now continue in the next section.

We're going to start to move on to our next big data structure and this one's going to be a pretty big

doozy.

So let's move on and get started right away.
----------------------------------------------------------------------------------------------------------
==========================================================================================================

Раздел 21:Linked Lists

67. What's a Linked List?

In this video we are going to move on to our next big data structure which is a linked list.

If you are going to make a collection of all the different topics frequently seen in engineering interviews

Honestly I would expect to see linked lists at the top of that collection.

It's a subject that is seen very frequently in engineering interviews.

So with that in mind where he's spending a pretty good amount of time in this course to understand linked

lists and exactly how they work we're going to first start off with a practical definition of what they

are.

Then we'll put together our own custom implementation and then we'll finally tackle a handful of common

interview questions that involve link lists.

So without further ado let's take a look at a handful of diagrams that will help us understand exactly

what linked lists are.

So a linked list is an ordered collection of data.

The collection contains a number of different nodes and so on the screen right here you can see four

separate nodes each node contains some amount of data along with a reference to the next node.

When we put a handful of these nodes together we refer to it as a linked list because it quite literally

is a list of linked nodes will also very frequently refer to this as a chain or a chain of nodes that

are strung together.

The list of nodes that form this chain has an order that is always maintained.

So in other words the order of nodes in a linked list won't suddenly or randomly change unless we specifically

want to change it.

Of course in every linked lists there are always two special nodes.

Now I'm going to move the diagram forward.

We're going to look at some terminology that is commonly involved with the linked list.

So the two special nodes that you'll always see are the head node which is always the very first note

of a linked list and the tail node which is always the very last node the tail node can always be identified

by the fact that it does not have a reference to any other node also knows that every single node that

we're showing here has two discrete parts of it.

It has this kind of data bucket assigned to it.

The data that can be contained in the node can be absolutely anything we want.

So it can be a string as is shown here.

It can be a number an array an object any type of valid javascript value can be contained within one

of these nodes.

The other part of a node is a reference to the next node along the chain.

And so with all this discussion of references you might be wondering exactly what I mean by a reference

in the javascript world.

So without going any further let's flip over to a code notepad very quickly and we're going to put together

a quick implementation of a very small linked list and that will give us a better idea of how these

things work.

So over my code editor and this is very quick.

You don't have to write this code out because we're going to write a few lines of code.

We're going to create two separate nodes of a linked list and then join them together.

So I'm going to create a new variable called Node 1 and assign it an object with a property data that

has value 1 2 3 0 then create a second node they'll refer to as Node 2 this thing will also have a property

called data that will have a value for 5 6.

So I have now created two separate nodes here.

Node 1 and Node 2 they are not linked together in any type of linked list at all to to link them together.

I have to explicitly form a reference between the two of them.

And so I can do that by writing something like Node 1 dot next equals Node 2.

So now if I wanted to figure out what the first node of the chain was it would definitely be Node 1

because node one contains a reference to Node 2.

And so if we look at the diagram over here let's flip over to right here we kind of have a structure

like this where Node 1 is on the left hand side and it has a reference to Node 2 on the right hand side.

Notice that Node 2 does not have a reference to any other node so it must be the tail node of our linked

list.

I want you to also notice the fact that I assigned the data for both of our nodes to a property called

quite literally simply data.

Now there is nothing special about the data property right.

Theres nothing special about the fact I called it data in both the nodes right here.

I could have just as easily called it information or record or banana you know whatever you want to

call it but by convention we usually call it data the reference to the next node was stored on the property

next.

And so just like data the next property here the name of it is completely arbitrary.

We could have called it next node or chain next store chain ref for next ref whatever you want to call

it.

But again by convention we usually call it next.

So by convention we usually make sure that every node has exactly two properties the data property and

the next property when we put together our own custom and 27 of the linked list we're going to make

sure that our nodes have both exactly properties named data and next OK.

Now the last thing I want to mention here about this very quick linked list example is that this is

a very straightforward and simple implementation of the linked list.

This really is linked list right here.

Notice how there's no arcane or special code that I had to write to form a linked list.

No as long as you have some separate pieces of data and then you form some type of connection between

them you can refer to that as being a linked list.

This meets all the rules of a linked list.

All right.

I think that's enough on linked lists for now.

So in the next video we're going to jump immediately into working on our own javascript implementation

of the linked list that might seem like we're getting into it very quickly.

But trust me the easiest way to understand a linked list is to attempt to implement one on your own.

So with that in mind let's continue in the next video.
--------------------------------------------------------------------------------------------------------------

68. Exercise Setup

In the last section we started talking about some of the theory around linked lists in this section

we're going to immediately start diving into our own custom implementation of one.

So inside my code editor I'm going to find my linked list directory.

Now up to this point we've attacked every single question in every folder of this directory or of our

project in the same fashion.

We've always open up the index site js file and then started tests running for tests.

Yes but this particular assignment right here in this particular problem is going to be quite large.

So it is structured a little bit differently from some of the other problems that we have worked on.

Let's first open up the index G-S file inside of here.

You're going to see some very brief directions and notice that it essentially says see the directions

document.

So also inside that linked list folder you'll notice a female document called directions.

Each team out.

Let's open up this document right here inside of our browser and see what exactly is inside of it.

So there's a couple of different ways you can open up that Ishmail documents.

I'm going to open up my file explorer.

I'm going to find the linked list directory here it is and then I'll just double click the directions

HMO file to open it up.

OK.

So this is a document that contains all the different methods that we are going to implement on two

different classes.

The first class is the Node class.

This is going to be a javascript class that is meant to kind of simulate the behavior of a node in a

linked list.

The second class we're going to work on is going to be the linked list class and this is going to act

as a linked list would.

Now the node is going to have the class is going to have very little functionality associated with it.

In general the vast majority of code that we are going to write will be all revolving around the linked

list.

Notice how that beneath either head or here we have a table that describes some of the different things

that we need to work on.

Now the order of functions that are listed in here is the order in which we are going to implement them

throughout this example.

So we're first going to start off with the constructor function and then a function called insert first

and then size get first and so on.

Going all down this list every single function that's listed tells you the arguments that you should

assume that function will be called with the different type of data.

The function should return then some directions about that function and what it's supposed to do.

And then finally on the right hand side there's a quick code snippet illustrating exactly what that

function is supposed to achieve.

We're going to come back to this document in just a little bit.

But before we do there's one other quick thing I want to show you that is very special about this particular

exercise that we're going to work on.

So back inside the linked list directory we're going to find the test.

J.S. file up to this point.

We have mostly ignored our test files but for this one the behavior of the thing is just a little bit

different.

So inside the test file you can scroll through this and you're going to see that there are many many

tests associate with this linked list.

So rather than running all these tests at once I have specifically disabled all but to be executed by

default.

So only these first two Tests right here are going to run by default as we work through the list of

functions in the document that we are just looking at.

We're going to come into this test file and start to enable some of the different tests we can enable

a test by finding the word describe.

So yours describe right here and then immediately after it you're going to see Dot skin.

So this starts right here.

I bet you can guess what it does.

Skip means don't run this test.

So if I wanted to enable the tests for testing a node I can highlight skip right here and then simply

delete it.

So I should see just describe and then open parentheses Syleena I'm now going to save this test file.

So do make sure you delete that dot skip right there for the first describe and then we'll start the

tests up inside of our terminal server at the terminal just like we did previously we will run just

linked list slash test dot genius dash dash watch now when we run this we're going to see a bunch of

output here specifically saying that we are skipping many tests.

And so this is exactly why I set up the test file to skip a whole bunch of tests by default because

if we ran all 23 of those tests you would just see all those failure messages.

It would be really tough to figure out exactly why anything was failing.

So instead we're going to work on one specific function at a time.

And in general we will enable one group of tests at a time get those tests to pass and then move on

to the next set.

So right now we just enabled a test around testing a node instance and you can see that right now that

test is failing.

So we need to go and write some code to make it pass.

OK.

So that's a little bit of an overview of some of the setup that we had to go through for this linked

list exercise.

Let's take a break right now.

We're going to continue in the next section and we're going to start to tackle the first part of this

implementation which is to build out that node class.

So quick break and we'll start that up in the next video.
---------------------------------------------------------------------------------------------------------------------


69. Node Implementation

In the last video we took a look at some of the different materials that are going to be used for this

exercise.

We're now going to get started writing some code to implement our node class API.

Now the node API is going to have just one function associated with it which is the constructor function.

Remember that a node in a linked list essentially just contains some amount of data and a reference

to the next node along the chain.

And so it really has essentially no functionality tied to it.

It's just a little bit little container that contains some amount of data.

To that end let's take a look at some of the documentation here because there is one thing about it

that is a little confusing.

So notice how the arguments to the constructor function are supposed to be some data that the node should

contain and store.

And the second argument which is an optional argument is a reference to another node.

Now here's the thing that's confusing about this.

This second argument right here is supposed to be a reference to the next node along the chain.

Now that might not sound like the weirdest thing but let's put this into diagram format and then I think

you'll understand what's going on.

So we're going to take a look at a diagram that simulates this code example.

Over here on the right so see the code example right here we're going to look at a diagram to follow

exactly what that does.

So first three lines right here.

Sets up something called Node 1 or.

And what we call the node constructor and we pass in some data to store of high.

So the no that constructor inside the node class runs and then assigns to its data property the string

high and then to the next property which is supposed to contain a reference to the next node along the

chain it contains no there is no other node that is pointing to here.

So no other node is currently associated with this chain.

Then immediately after that we declare a second node the second node takes in the string there as the

first argument and then as a second argument it takes in Node 1.

So notice Node 1 right there that says just and it should be node one like so when the constructor runs

with Node 1.

Its going to set up Node 2 and on Node 2 and one is going to be set up as the next property.

And so after all this code right here runs we would imagine that this right here is Node 2.

So going to drag Node 2 over here and its going to end up looking like this.

So the reason this kind of focus on this argument right here is that this second argument sets up the

next node along the chain which is a little bit counterintuitive you might think that its supposed to

set up the node like before it but no it sets up the next node along the chain.

So essentially just take this one right here or this note that were passing in and assign it to the

next property of the node that we are creating.

That's pretty much it.

OK so with that in mind let's flip on over to our code editor now for this one exercise and maybe the

next one or two just to get started on a strong foot.

We're going to do these together and then we will all kind of cut you loose for some of the kind of

later ones.

But for these first few It's really important that we start off on the same footing because the tests

that we are putting together are the tests that are running over this example are expecting some very

specific property names and whatnot.

So I just want to make sure that these first couple exercises or the first couple of functions are put

together very precisely.

All right.

So in the note class we are going to define our constructor function.

Remember this is going to be executed any time we create a new instance of a node.

So we're going to use it to do some initialization of a note.

The note will be called with two properties data and the next node along the chain.

Remember like we just said like we just looked at on the diagram.

This is supposed to be the next node.

The one that comes after the one that we are creating.

So we're going to take that data right there and we are going to assign it to the data property of our

node.

So we'll save this data equals data.

One thing I want to reiterate we just looked at this and the code example just a moment ago but just

to reiterate there's nothing special about calling this data right here.

It's just convention that we usually store any data associated to a node on the data property.

Next we are going to assign the next property of this node.

So we'll say this dot next is next like so.

OK.

So there's one last thing we need to be aware of here and that is the case in which someone does not

pass in a next node and that actually just happened in the code snippet that we're just looking at.

So it is totally fine to create a new node that does not have a node after it's and notice that we did

not pass in a second argument here.

Now again by convention this is entirely a convention thing for the last node on a chain.

We usually set the next to refer to know if there there's no other nodes in the chain.

And we do know rather than undefined in general whenever you see the property undefined it usually has

the connotation of meaning hey this property has never not been set.

Like no developer no engineer has set this property.

But the null value kind of has the connotation of this property has been set and it has been specifically

set to be undefined.

So remember Nolan undefined and Javascript are extremely similar but no kind of has the connotation

of we specifically set this to be nothing at all.

So in the case that someone creates a new node but does not pass in a next node we're going to default

the value of next to be null like so.

So if anyone makes a note but does not pass in a next one to link on we're going to just default to

it and say it should be null.

And so this next will end up being No.

All right so that's our first constructor right here.

That's our first little piece of a linked list.

Let's check out our test really quickly.

If we flip back over here you'll see that the test that was failing is now passing.

So if we scroll up a little bit it will say our test for a node it has the properties data and next

which is great.

OK.

So that is the setup for a node.

Let's take a break right here in the next section we're going to continue by working on the implementation

of our linked list.

And that's where things are going to start to get really interesting.

So quick break and we'll pick it up in the next section.
------------------------------------------------------------------------------------------------------------------

70. Linked List's Constructor

In the last section we put together our node class with its constructor.

Again traditionally a node is a pretty straightforward implementation and it's really this linked list

class.

It's going to have a whole bunch of functionality associated with it.

I'm going to flip back over to my directions each team I'll file.

So we have now put together the Node class API successfully which means we're now going to move on to

the linked list class API.

We'll first start off with the constructor function at the top which we'll use to initialize our linked

list.

So its constructor function is specifically made to initialize the linked list.

Notice the directions right here.

The duction specifically say that we should create the linked list with no head node associated with

it.

So when we call new linked list there should be no nodes associate with it just a completely empty linked

list should be returned the linked list should have one property which is going to be called head.

And that's going to be a reference to the first node of the linked list and by default heads should

be null.

So if we create the list right here and then immediately log out let's dot head no should be returned.

Now the thing that's kind of interesting I think for a lot of beginners when they are starting to look

at this linked list implementation is that when we create the linked list it has only a reference to

the head.

So let's look at a diagram of that and get a better idea of what's going on.

So this is the linked list class that you and I are going to be working with the linked list class is

going to have a bunch of methods associated with it that make working with the linked list very easy.

So methods to say insert a new node or remove a node or search for a node or whatever it might be the

linked list class is going to have exactly one property assigned to it.

So it will have a bunch of functions but there's going to be exactly one property assigned to it and

that will be the head property.

The said property will have a reference to the first node of the linked list.

So in truth the linked list class has no idea about say how many notes belong to the linked list or

what data exists in the linked list.

The linked list class only knows about the first node right here and if it wants to answer any questions

about the linked list itself or the actual data then it needs to crawl over the linked list and say

count up the number of nodes if it wants to know that information.

So the linked list has very little hard information associated with it.

All it really knows is the first note and it's going to be up to you and me when we put together all

these handy methods for working with the linked list to write some code to access first this head node

and then crawl through the linked list and work through it in some meaningful fashion.

So that's where all the difficulty with this linked list is going to come from.

You and I are going to have to write code to access just the head and then work with all the other elements

inside there.

OK.

So with that in mind let's put together our constructor now that we have a better idea of exactly what

the purpose of the linked list class is.

So over it in my code editor I'm going to find my linked list class or give myself a little bit of space

and we're going to define the constructor which I really just can't spell apparently.

So constructor looks good.

Now thinking back to the document right here it says specifically we need to initialize a head property

and by default heads should be null.

So the constructors can be really straightforward.

We're simply going to say this dopehead equals nil as you'll see in practice very shortly a real usage

of the linked list would be to do something like say Konst list because new linked list.

And then we might create a new node and associate it with this list so we could say less dot head equals

new node and maybe the data we want to store in this note is something like 10.

So now our linked list has a head node associated with it.

And now this head right here could have additional nodes linked onto it which we could associate by

making new nodes.

OK so that's pretty much it for our constructor.

Really pretty straightforward.

So let's take a break right here.

I am going to clean up the code right here so let's clean that up.

We're going to pause right now.

By the way there are no more tests that are soci with the construct direct here.

There will be tests for the next method we implement.

So let's break right now.

We'll continue in the next video and start working on one of the more interesting methods around our

linked list.

So I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------------

71. Linked Lists's InsertFirst

Now that we've got our linked list or put together we're going to start thinking about the first method

that we're going to assign to the linked list class before we look at any documentation.

Let's make sure that we enable the test for the method that we are about to write.

So inside my linked list folder I'll find the test not G-S file.

I'm going to scroll down a little bit to the second to describe block which says describe skip and then

we're looking for the words insert first.

So I'm going to highlight the dot skipped part right here.

So here Scott.

And I'm going to delete it.

So it should be simply describe insert first Alden's save the file and then I'm going to flip on over

to the terminal and I'm going to verify that I have one test failing right now and it should be something

about insert first blah blah blah blah blah call I'll now close out my test file.

We will be reopening it in just a bit.

But we don't need it right now.

So let's now go back over to our browser and find our directions.

Each HTML document that's going to give us a little guide on what this insert first method is supposed

to be.

So again the method name that we're going to implement right now is insert first insert first takes

some amount of data as it's only argument.

Remember that data in the context of a linked list can be any type we want.

So it can be a number a string an array an object anything that we want to store in a linked list.

The purpose of insert first is to create a brand new node out of that argument data.

So we're going to create a node out of data right here and then we're going to assign the resulting

node to the head property of our linked list.

So as we saw in the last section when we create a new linked list it starts off completely empty so

we can use this insert first method to sort of initialize the links list and get some initial node inside

of it.

Now the other thing I want to mention here is that this is supposed to be an insert method not an overwrite

method.

So if it turns out that the linked list already has a node associate with the head property we should

not be overwriting that node so we don't want to delete anything here.

We want to add an additional element to it.

So let's take a look at that in diagram form just to make sure it's really clear what's going on.

So I'm going to fix up this diagram a little bit.

So we're going to imagine that you and I create a linked list and it looks like this right here.

So it has one note and nothing else after it.

Then let's imagine that we take the linked list and we call insert first on it and pass in the number

4 5 6.

When we do so we should first create a brand new node.

So let's imagine we create a new node by calling the new node constructor and pass in our piece of data

which is 4 5 6.

We should then break reference between the head and the existing node so we can basically break that

reference.

We will take the new node that we just created we will assign it to the head property of our linked

list and then the most critical step is we need to make sure that we now repaired the reference between

this new node and the old one.

So that's what we're doing here.

We're creating a new node and sticking it at the front of our list.

So now we have two nodes in total.

Again insert first is an insert method.

We are adding something.

We are not overwriting any nodes here.

Now before we think that this might be a really tough challenge.

Let me just remind you about the node constructor that we just put together.

So our existing node constructor right here takes as a first argument some piece of data and then as

a second argument we can pass in some existing node which will be assigned to the next property of the

one that we are creating.

So think about the operation that we just did here with insert.

First we said that we wanted to create a brand new node which was the 4 5 6 right here.

And we wanted its next property to look at the existing node in this chain and then we wanted to update

the head reference.

So that first part everything up to updating the head reference was kind of taken care of already by

our node constructor.

And so I mean to suggest here is that maybe there's not a whole bunch of code that we need to write

to write this insert first method.

OK I would like you to give a shot on this one by yourself.

Remember we just enabled some tests so you can put together the method inside of our linked list class

right here and then you can double check if that tests over in the terminal to make sure that everything

is working the way we expect.

If you get confused or if linked list still seem pretty intimidating.

And honestly I totally expect that they are right now.

Always remember you can just get directly over to the solution in the next video and we will walk through

this together.

So quick break give it a shot and we'll go over the solution in the next video.
---------------------------------------------------------------------------------------------------------

72. Solving Insert First

Hopefully you had some success putting the insert first method together in this section we're going

to go over this solution together.

So I think that we did a pretty good explanation in the last video.

So we'll just jump directly into the solution here.

So in my linked list class I'm going to add another method to it called insert first the insert first

method is going to be called with some data that we want to store inside of our linked list.

And remember I know that specifically because of the directions laid out by the directions file so the

directions file for insert first specifically said the argument to this function was going to be some

data.

Again remember we're not calling insert first with a note.

We are calling it with some data and then it's up to you and me to create a new node.

So back inside of our insert First we will accept an argument of data and then we'll use it to create

a new node.

So of say Konst node equals new node and we definitely want to pass in our data.

Now remember that when we insert a new first node 2 are linked list.

We do not want to overwrite any existing knows that might be there.

So to make sure that we do not accidentally overwrite any note to make sure that we just kind of stuff

this one as being first in the chain.

We can take any existing node that might already exist at this head and pass it as the second argument

to the new node constructor.

So I'll say this dot head right here OK.

So again this part right here is probably rather confusing just might.

I mean in my opinion I think it's confusing.

So I want to do a quick review on why we were able to pass in this head right here.

So up in our constructor for the node remember we had said that it takes a second argument if we pass

in the second argument it will be assigned to the note that we are creating its next property.

So let's go and look at that and diagram form out one more time.

I apologize if it seems like we are repeating here but this is a pretty crucial little step.

So we can imagine that maybe our linked list already has one node right here and we don't want to lose

this existing node.

So we are going to create a new note by calling our no constructor as a first argument will pass in

the data that was passed into our insert first function.

And then as the second argument the argument that gets assigned to this brand new nodes next property

we will pass in the existing node.

So we're going to pass in the existing node as the second argument to the constructor when we do so

it will set up a relationship like this right here.

So the code that we just wrote this right here when we said Konst node equals new node impasse in this

knothead it sets up exactly this relationship right here.

Now the only problem is that this dark head is still looking at the old node.

And remember one thing I also want to point out there is that if no other node exists right here when

we call insert first that's still OK.

Like we can create our new node and the new nodes next value will point at No.

Which is totally fine.

So after we insert the new node we have to repair the head reference.

So the linked list class should no longer be looking at the old node.

It should now be looking at the new one.

So to make sure that works back inside of our insert first function we will update the this data head

reference.

So now this head will be the new node.

Like so now this line right here can be simplified into one line.

Note how we are creating the new node and assigning the value to the variable node.

So that's a totally unnecessary temporary variable right there.

So I'm going to condense this down to one line of code.

We're going to create the new node and then a scient directly to this head and then we can remove that

variable reference and that's all we need right there.

So I'm going save this.

Let's check out our tests in the terminal and see how we're doing.

So the tests are definitely passing.

But again this is kind of a crucial method and I really want to make sure that it's really clear exactly

what's going on here.

So it's one last step and before we do this let me say very quickly if you get what's going on here

and you want to move on to the next video that's fine.

Just skip the rest of this video.

Otherwise stick around and I'm going to do a quick demo with our node class right here in the linked

list class.

OK.

So please right now skip if you're done and you understand what's going on.

Otherwise stick around.

So I'm going to copy both the classes that we just wrote and I'm going to bring them on over to my little

editor over here.

So here is my note in my lengthy list I'm now going to create one node.

So we'll call us 1 node 1 and this will be a new node with the data 5.

I'll then create a linked list implementation or some you linked list instance.

So I'll say conc link is says call it Konst list is New linked list and on the list I'll call insert

first and I'll pass in.

Let's say five if I now print out list you'll see that it has had data of 5 and next to no.

So another way of setting up the list let's see that before we insert the first right here I initialize

the list with this new node one that we had already created.

So maybe I called List dot head equals Node 1.

So that just initialized list with this node 1 assigned to the head.

So this time when we call insert first we now want to make sure that we do not accidentally overwrite

any data.

And you and I just realized I used a value of five in both locations here.

So how about on insert First we call it with 15.

So now if we look at the result you'll see that the head of our list.

So we are printing out list right here.

Here's list here's the print out.

So the head reference points at our node with data of 15 and then its next property points at the node

with a value of 5.

So clearly we had a node associated with the head and when we inserted this new record it took that

old head.

It took the old Node 1 and kind of hijacked it or nested it within itself or created a reference to

it and then the value 15 replaced the old node as the value of head inside the list.

This is one of the things where I can probably talk about it all day.

But you got to play around with the code a little bit or look at some diagrams to really get it.

It's a very visual thing I think but hopefully at this point this insert method is starting to make

a little bit of sense.

So let's now continue on the next section and start working on our next method.

I'll see you there.
---------------------------------------------------------------------------------------------------------------

73. Sizing a List

In the last section we took care of our insert first method and now it's time to move on to the next

one which is the size method.

So this size method is going be pretty interesting because it's going to be our first opportunity to

figure out exactly how we can iterate or walk through a linked list.

So the goal of these size method is to return the number of nodes that are contained in the linked list

that could sample over here is pretty illuminating.

So we can create a new list we can insert 3 records into it at which point time the linked list has

three nodes long.

So if we then call list size it should return the number three.

So let's give this a shot inside my code editor.

We'll first find our test not just file.

I will scroll down to the next describe block.

So around line 31 or so I want to find the described block for size.

And again will take out the DOT script there and then save the file.

Don't forget to save it.

So if I go back to the terminal I should now see one test failing.

Great.

So let's go back over to our linked list class.

So inside of here it's going to be up to you to create a method called science and then to somehow iterate

through our list of nodes and count the number that exist.

Now on this exercise I'm going to very deliberately leave the directions really vague so I'm not going

to tell you anything else I want you to try to give this one a shot using your own knowledge.

Now this is a very challenging exercise I'm really dropping you off the deep end.

So if you feel like you have no idea where to get started that's totally fine.

But I'd like you to at least put in two or three minutes of thought on exactly how you might crawl through

the linked list and count the number of nodes in it.

The one thing I want to remind you about is remember our linked list class instance only ever is allowed

to have a reference to the head node.

So to put the other the size method you're not going to add any code to say insert first to try to keep

a reference to every node that gets added.

So don't try modifying any of the code that's already here.

Or any of the existing methods I should say.

All you want to do is add in this new method called sys and attempt to use that to count up the number

of nodes.

So like I said leaving the directions very vague here I want you to spend just two minutes thinking

about how you might approach this.

And if you get some idea well go ahead and give it a shot.

Otherwise catch in the next section and we'll go through the solution together.
--------------------------------------------------------------------------------------------------------------


74. Solve for Size

In the last section I throw you into the deep end with the size method.

So we're going to write a method that returns the number of nodes in the linked list.

Let's give it a shot.

I mean flip back over to my implementation and I'm going to really add the new size method.

All right.

So this is a rather tricky one.

This is one that's kind of hard for me to show you exactly how it works with diagrams.

So we're going to really just write out the code and we'll talk about how it works.

Now some of the methodology that we're going to use in this method right here to iterate through our

list is going to be used in almost every other method that we write for our linked list.

So we're going to put this thing together this one time and we're going to definitely be doing something

very similar in many other methods.

So if this implementation initially seems a little bit weird Don't sweat it you're going to see the

same thing like six more times to be honest.

So we're going to write out the code and then talk about exactly how it works.

We're going to first initialize a counter variable as the number zero.

So this is going to be the number or the variable that totals up the number of nodes inside of our linked

list.

Next we're going to get a reference directly to the head node of our linked list and we're going to

assign it to a local variable called node.

So say let node equals this dot head.

All right.

Now here's the magic here's the neat part.

We were we are going to say while node and then counter plus plus.

And then finally here's the real magic node equals node dot next.

All right.

So this process right here is something we're going to be using several times throughout the remainder

of our linked list.

So we first get a reference to the first node inside of our link list and then we enter the while loop.

So in this very first evaluation of the while loop like when we first enter into it if the Leafs list

does not have a head node assigned to it then the while loop is going to check to see if node is a truth

your falsie value.

If this start head doesn't exist.

So if there's not a node there right now.

Well then the while loop is going to fail the check right here.

And so it's not going to run any code inside of it.

If a node does exist so if there is a head node then the while loop will enter the body because node

will be a truthy value because it exists inside the body of the While loop.

We will then immediately increment our counter variable because you know we just found one node.

We know that at least one node exists.

And then here's the magic part and the next line of code we're going to look at the current node.

So this is the first one.

Like the head node we will look at its next property and remember the next property will be either another

node or the value null.

And if it's null.

That means that there are no other nodes for us to evaluate.

We will then take either the next node or the value null and assign it to the variable.

Note that we go back up to the While loop check right here and we say is node a truthy value.

In other words is it a actual node where does the falsie value.

Is it the value null.

And so based on that check we either reenter the loop or we exit the loop entirely in that same process

goes on over and over and over again.

So very quickly if we look at this in Diagram format when we enter that for loop or the very first time

we enter it the variable node will be equal to this first know that we have right here what increment

the counter to say yes we have at least one note and then the value of the variable node will be assigned

to this things.

Next property which would be this node right here.

And so the Waialua goes one more time after that we will update the value at the node.

Very well to be this things next property which is now null and then the while loop says no no is a

false value.

We're done here.

And so we stop running the while loop.

So that's the trick.

This is how we are going to iterate through our linked list many times throughout many different methods

inside of this class.

Now one last thing here don't forget whenever we get some variable that we're supposed to return here

make sure we always return it.

So after the while loop I will specifically say return counter like so.

So let's check our tests and see how we're doing.

And yet it looks like our new test is passing.

So I should now have 5 passing tests and just to confirm.

Yeah.

Here we go.

So size successfully returns the number of items in the linked list.

Cool.

So in many of the challenges that come up in a little bit here on any other method where we are trying

to iterate through our list remember this while loop right here because every other method is going

to probably end up using something just like this.

So with that in mind let's take a break and continue in the next video and start working on our next

function.
---------------------------------------------------------------------------------------------------------------

75. Get Over Here, GetFirst!

The next function that we're going to work on is a rather straightforward one.

So we're not going to do a lot of introduction here and we'll do the solution very quickly.

So we want to implement get first.

We're supposed to return a note.

And specifically we want to return the first note of the linked list and just as a quick reminder remember

that head property has a reference to the first note going to list.

So I think you might be able to pretty quickly imagine how this for this get first method might be put

together.

Now before I cut you loose to put together the solution remember to change on over to the test file

we want to now scroll down to the next describe block and we want to remove the dot skip on the Get

First describe.

So you will remove the dot skip and then save the file.

OK.

So go ahead and give a shot on this method.

Get first right here and I'll catch you in the next video.
------------------------------------------------------------------------------------------------------------------------

76. Building GetFirst

Hopefully you had some success with the first method.

We're going to go over a solution very quickly.

In this video like I said in the last video recall that the linked list has a head property assigned

to it that is always supposed to be pointing at the first note of our linked list.

So when you see something that says oh yeah I returned the first note the linked list.

We are essentially saying just return this dot net.

So let's put together the code for that as the next method inside of our class.

I will add in get first and we want to return this dot.

Because this dotted head is always going to be pointing at the very first method.

Or C the very first node in our linked list.

So I will save this.

Let's check our terminal.

And yeah we're now up to six test passing.

So those are pretty quick one.

Let's take a break can come back in the next section.

And we're going to work on one that's a little bit more challenging which is the get last method.

So I'll see you in just a minute.
---------------------------------------------------------------------------------------------------------

77. Find Your Tail with GetLast

In the last section we did a very quick solution to get first.

We're now going to move on to our next method which is called good last.

So the goal of this method is to return the very last node of our linked list and you can see a great

code sample over here on the right hand side.

So if we insert first A and then b remember that we would end up with B being the first node A would

be the second node.

And so if we called Get lost it should return the node with data.

And the thing keep in mind here is that we want to specifically to return the entire node not just the

data property the node we want to return the entire thing.

So the solution to this I want to remind you on exactly how size over here worked.

Remember how this thing worked.

Remember we got a reference to this dot head.

And then while the value of the variable node was truthy we continued iterating through our linked list.

So you can use this technique right here in a very similar fashion to find and return the last node.

Now two things I want to point out here before I cut you loose.

The first thing to recall is that we can always figure out if a node is the last one.

If it is has a next property with the value.

So when a node has the value nil for next that means it is the last one.

The other thing I want to point out regarding this method is that you might need to remember to take

into account the situation in which a linked list has no nodes whatsoever.

So the tests are written to check for this case right here.

So make sure that you do handle the case in which there is no nodes associated with the linked list.

All right so I'm going to cut you loose.

Go ahead and give it a shot.

And I will catch you in the next solution where we will go over a solution together.
------------------------------------------------------------------------------------------------------------------

78. GetLast Implementation

Hopefully you have some success in putting the last method together.

Now one thing that I neglected to say was to make sure that you include the get last tests by deleting

the data skip for that function.

So here's get lost inside of my test out jazz file it's around line 53 or so.

So remember to remove the dot skip on here.

My apologies.

I will definitely try to remember to remove the duck skip in the future so we should be able to verify

that we now have one test failing.

Ok so let's think about a solution here.

Back inside of my index dodgiest file I'm still inside of the linked list class and I'm down towards

the bottom.

You've definitely got a pretty good number of functions in here and we will definitely get many more

before we're done.

So inside of here we're going to define the last method and then recall our goal here is to return the

very last node in our linked list and I had also said that we need to specifically watch out for the

case in which our linked list has no nodes associate with it yet.

So I think that will handle that case right away will handle the case in which we have no nodes.

So to do so we can put together a very simple if statement will say if there is no head element then

just return no right away.

So if there's no node Hey let's get out of here we're done here nothing else.

Otherwise we want to continue inside of the method and do a little bit of work so to iterate through

our linked list and get to the last node.

We're going to use the same iteration technique that we used before on the site's method up here.

So we're going to get a reference to the current node and then we will iterate through the node and

as long as there is one will continue with the While loop.

As soon as we find the very last note and remember we can identify that by the fact that it will have

a null property.

That means we've found the final note and we should return it.

So down inside of get last we'll get the reference to the node by saying Let node equals this dot head.

And then while node exists we'll update 2 node equals node next.

And right before that we will check to see if node next exists.

So if no does not.

Next excuse me a node dot next does not exist.

So if that's not all that means that we must be at the very end right now in which case we should return

the current node like so.

So again we start off with our first note.

We've already checked to see if that one is not defined.

We then enter the for loop because the first time around node will always be defined.

We then look at this nodes next property if it is not defined then we immediately return the current

node.

Otherwise we update the node variable to the next one in our chain and then go through the while loop

again.

So let's check our tests and see how we're doing over here we got 7 test passing.

Awesome.

So this was another one that's going to use this same iteration style to look through a linked list.

Let's now continue in the next section and we'll move on to our next method.
----------------------------------------------------------------------------------------------------------------


79. Clear that List

The next method that we're going to work on in our list is the clear method.

So clear is intended to completely empty out our linked list of any notes.

So essentially we don't want to see any notes whatsoever after calling the clear method.

Now if you think that you need to somehow call like a delete key word or anything like that.

Think of exactly how the linked list knows about the existence of any nodes here.

The linked list only knows that any nodes exist through that head property.

So if we somehow kind of like zero out this had property or something like that then as far as the linked

list is concerned there is no linked list.

There are no nodes.

So this is a problem that is probably much simpler than you might think.

It ends up being a pretty short solution.

So if you think that you need to write a lot of code for this one maybe Think it over a little bit first.

Now before I cut you loose let's again make sure that we get our test running.

So in my test.

J.S. file I will scroll down to line 63 or so and I will remove the dots skip on the clear describe.

So let's save this and quickly verify that we are back to one test failing.

Cool.

Salix good.

All right.

So give this a shot and we'll go over a solution in the next section.
---------------------------------------------------------------------------------------------------------------

80. Clear Solution

Now that you've had some time to work on the clear method let's start going over the solution together.

Remember the key here is to recognize that if we want a linked list to think that all the different

nodes are now empty or destroyed or wherever you want to call it all we really have to do is reassign

this head property to something else.

So inside my code editor I'm going to add a new method called Clear and then in order to clear out the

linked list or to empty out the list of notes here all we really have to do is a sign that had property.

So I'll say this dopehead equals nil.

And now as far as this linked list class is concerned there are no notes as far as linctus class is

concerned.

We cleared out the entire list.

They're gone.

We now have no reference to the list of nodes anymore.

Now in theory maybe that list of nodes is still floating around memory or something like that.

But hey what do we care.

The linked list doesn't think that there's anything left anymore.

So let's check out our tests and yeah we're good.

We're passing here now just to prove it to you.

Not prove it to you per se but I want you to look at the tests that I wrote for the clear method here.

So here is described clear inside of our tests at J.S. file and inside of here.

Take a look at the implementation of this test.

So we insert an element insert insert we insert four elements total right here and then we verify that

there are four nodes inside of it.

We then called Clear and after that as far as the linked list is concerned there are no nodes calling

size returns zero.

So there must be no nodes associate with this linked list.

All right so this one was maybe a little bit deceptively easy.

Well let's now continue in the next section where we're going to tackle one of the slightly harder methods.

So quick break and I'll see you in a minute.
------------------------------------------------------------------------------------------------------------------

81. Where's My Head, RemoveFirst?

We've now taken care of our clear method and it's now time to move on to remove first remove first we

want to remove only the first node of the linked list.

In practice to really think that our linked list class has kind of removed that first node or has somehow

deleted it or how everyone referred to it.

All we really have to do is reassign the lists head property to now look at the second node inside of

our linked list.

So this is another one that might be a little bit on the easier side as far as implementation goes.

So try not to overthink this one too much.

Now just to be really clear here let's take a look at diagram very quickly.

So if we called remove first on this linked list right here what we really want to do is make sure that

head now points at the second note.

So note that the first node is still going to point to the second one here.

But as far as our linked list is concerned this first node is completely invisible.

We don't have any reference to it.

So as far as you and I know it's been deleted and it doesn't exist anymore.

Again you definitely don't want to overthink this problem.

All right.

Before I forget let's check out our test file and remember to delete the dust skip on remove first.

Oh yeah.

This test comment right here reminds me of something I want you to also consider the case in which we

call remove first on a linked list that has no nodes whatsoever.

So just keep that case in mind as well.

All right.

Give it a shot and we'll go over a solution in the next video.
-----------------------------------------------------------------------------------------------------------

82. Building RemoveFirst

Let's take care of our remove first method.

So again our goal here is really to make sure that the head reference will be pointing out the second

node rather than the first one.

So I'll flip on over to my code editor.

Let's find our linked list class.

Again I'm down here at the bottom right underneath our clear method and we'll define our remove first

method.

So the first thing we're going to do is make sure that there is in fact a head node.

So we're going to check to see if there is or is not a head node.

So if this dot head.

So if there is not a node here just go ahead and return we're done nothing else for us to do because

the linked list must be completely empty.

If nothing is assigned to the head now if we get past this if statement then it means it's time for

us to try to remove the first node to remove the first node.

We will very literally just update this dot head to look at the second node and we can get access to

the second node by referencing this dot head dot next.

So remember this hardhead returns a note and a node has a next property that points at the next node

in the chain.

Now there is something very interesting about this solution right here.

And once you think about it for just a little bit imagine the case that we call that removed first method

when there is only one node.

Well everything is going to work the way we expect.

Think about it if there's only one node then the first node must be pointing at the value null.

So when we run this line of code right here when we say get a reference to this start head next which

would be essentially null we'd be saying essentially this start head equals nil.

And that really is what we want to do here.

We're saying Remove the first element and if we remove the first element Well that means that our linked

list is now empty.

And so a head should be pointing at No.

So this solution will work out just fine even if there's only one node in our linked list.

Let's check our tests and see how we're doing.

First I would make sure I saved my file and then we'll check our tests cost.

So we got another test passing.

All right let's move on to the next one.

Let's check the name of the next one.

Next one is remove last.

OK so remove last is going to be one of the more challenging ones I really mean at this time.

So this will be one of the more challenging methods.

So let's take a quick break and tackle this one in the next video.
--------------------------------------------------------------------------------------------------------------

83. Bye-Bye Tail with RemoveLast

In the last section we tackled the remove first method.

Now it's time to move on to remove last remove last is going to remove the last node of the chain or

the last node of the linked list.

So I think that you probably have a pretty good idea of the purpose of this thing.

But before I cut you loose I want to give you a quick tip or two just to make sure it's really clear

exactly what is supposed to happen.

So I have taken the chain that we had before here and I've expanded it and marked it with green blue

and red.

Just to make each node A little bit more visible.

So if we called the remove last method on this linked list class right here I would expect that this

red node right here would just go away like so.

So that's the expectation that's what I want to have happen.

Now I want to give you a quick tip or two on one possible way of approaching this.

Now I'm not saying that this is the only way to do it.

And if you think of another way to approach this problem that's great but I want to give you a tip on

how to approach this.

So one possible way of doing this is to introduce two temporary variables that you're going to declare

inside of this remove last function and we will refer to both these as previous and node.

So these are two temporary variables.

So one way to approach this problem is to say that previous is going to start off looking at the very

first node of our chain and then node will look at the second like so now we're going to iterate through

our linked list.

And for every step through the linked list we're going to move these references forward one node to

the right as soon as we find a node right here that has a next value of NULL then that must mean that

we are at the end of our chain and we should remove the node at node and remember that to remove a node

we need to somehow go to the previous link on a chain and set that links next property to nil.

So that's the purpose of previous is to make sure that we have the reference to the previous node because

otherwise we don't easily have a reference to it.

So let's walk through this step by step and see exactly what would happen.

So we first start off with previous looking at the first note of our chain and the node looking at the

second we check to see if node has a defined node on the next property.

And in this case yes it does.

So we then update the references of both previous So we have advanced this one to the next node right

here and we update the node variable to the next node.

Now we check again to see if node has a defined next property.

And in this case it has a value of NULL.

So that means that node must be pointing at the last node in our chain.

So in order to remove that very last node we have to look back to the previous variable or the previous

node right here and we're going to set this things next property to nil.

So no longer will we be looking at that node right there.

We'll now be looking at Noal which means as far as you and I are concerned from a limitless perspective

the node is some of the linked list is now one node shorter.

All right.

Now let's not forget we need to enable our Tessier.

So back inside my code editor open up my test just file and I'm going to find the described block for

the remove last method and it's online 100 or so.

So we will remove the dots get on this thing.

Now one last thing here.

I know the couple of one last things I've been mentioning here but one last thing I really mean at this

time I do want you to keep in mind that if you use the methodology that I just showed you there's going

to be a couple of edge cases that you need to be aware of.

So for example imagine that we were going to use that algorithm I just described where we initialized

first this previous variable and this node variable.

Well what exactly would happen if our linked list started off with a length of one like so.

So you might need to take that in consideration.

And then I also recommend you take in consideration the case that the linked list is completely empty

as well.

So you need to make sure that you handle both those cases eloquently or at least in some fashion and

ensure that your code doesn't crash.

If you tried to remove the last node on an empty list so the test that we have here are specifically

going to test those cases so you can see in the first test checks to see the remove last method when

it is attempting to remove the last node when the list is empty and the expectation here is that calling

removed last should not throw in there.

Then there's another test that checks to see that the method works correctly when the list has a length

of 1 when the list has a length of 2.

And then when the list has a length of three down here so do make sure you handle those edge cases correctly.

All right go ahead and give us shot in the next video will go through a solution together.

So I'll catch you in just a minute.
---------------------------------------------------------------------------------------------------------------------

84. RemoveLast Implementation

Hopefully you had some success with the remove last method in this video we're going to go over one

possible solution.

So I'm inside my index file.

I'm at my remove first method.

And underneath this thing we will define the new method remove last like so.

All right.

So the first thing we're going to do here is to think about some of the edge cases that we have to deal

with with the given solution.

I laid out in last video so I want to first think about what we should be doing if the list is completely

empty.

So if the list is empty I don't want to attempt to get a reference to the first node or the second one.

I don't want to try to iterate through anything nothing like that.

So as the very first operation going to do I went to check to see if there is not a head node.

So there's not a bad node.

That must mean that our list is empty and I should just immediately return without attempting to do

anything at all.

So let's save this and if we flip on over toward test now you'll see immediately that one of the tests

is now passing.

So here is remove last.

And our goal was to make sure that if the list is empty we shouldn't crash and essentially nothing should

happen at all.

So with that simple statement we've satisfied one check right here.

Now the next thing we're going to do is consider the case in which the list has a length of 1.

So there's only one node.

If there's only one node back over here.

So there's only one node then I don't really need to start up my algorithm at all.

I don't need to get a reference to the second node.

I don't need to try to iterate through anything here.

All I really want to do in that case is remove the last node which in this case would also be the first

one.

So in that case I would want to delete the only know that we have.

And remember we can delete that node by setting this knothead equal to nil and then we would want to

immediately return from the function.

So to check to see if we have a length of one we could call the size method that we had previously defined.

But another easy way of doing it that doesn't rely upon that method would be to look at the head node.

So there is not a node at this dot head dot next.

So this right here this dot dot next would be a reference to our second node.

And then we're saying if there is not some value defined there so there's not some second node there.

That means that we have a list of length 1 and we should remove the head and then immediately return

from this function and not attempt to do anything else.

So I would say this dot head equals nil.

And then we will immediately return.

Now let's check our tests and back over here.

We now have our second test passing.

Very good.

So now we're going to start to write the actual algorithm that we care about.

So this is the algorithm where we are going to set up these two variables right here.

Previous is going to refer to the very first no just start node will refer to the second one.

And then we will iterate through our linked list and for each iteration step we will point these two

temporary variables at the next node along the chain.

And then as soon as we find a node that has a max value of NULL.

That means that we need to remove that current node.

So let's give this a shot.

Well first start off by getting a reference to the first node and the second one.

So say let previous equals this dot head and let node equals this head.

Next now as long as Noad next exists.

So remember that means that there is some next value after note right here there's some additional element

that we need to iterate through.

Then we'll update the value of previous to be the current node and then node will be set to node next.

Now I just kind of went through that very quickly so let's look back at the diagram and explain exactly

what this while loop right here is doing.

So again we initialize previous node.

We've said that like three or four times now at this point we know that very well.

So back over here we checked to see if node dot next is defined.

So is node dot next defined.

Well in this case yes it is right here.

So that means we are going to enter the body of the While loop.

The first thing we do is to update the value of previous to node.

So when that body of the for loop or some of the while loop runs the first time or that first line of

code we all take previous And we will tell it to look at the same node that that node is.

And then we update the reference node to look at the next node.

So now node is going to be looking at the next node.

We then re-entered the for loop or X. We keep saying for loop mean to say while loops so we re-enter

the while loop and we check to see if node next exists.

So in this case no dot next does not exist which means we have hit the end of our chain.

And so we need to make sure that we now delete this last note.

So like we said several times to delete that last node we can go back to the previous node and update

its next property to simply point at null rather than its current value.

So after the while loop will say previous next equals nil.

So we don't really have any if statement here or anything that specifically says hey look we're at the

end of the chain.

We are using this while loop right here to just keep on iterating through and through and through the

linked list until there is no longer a next node.

And as soon as this situation right here or this expression writes evaluates to a false value or is

null that means we are at the end of the list and we can just very easily say previous start next is

not to remove that last element.

All right let's check our test now and see how we're doing.

So back in the terminal all of our tests are now passing.

Awesome.

OK.

So this has been our remove last method.

Let's now continue into the next video where we're going to do one more very very similar method.

Oops maybe not.

Insert last so we need to insert a node at the last or the end of the chain.

So let's take care of that one in the next video.
----------------------------------------------------------------------------------------------------------------

85. A New Tail to Tell with InsertLast

Time to move on to art.

Insert last method.

Now I know that a lot of these methods probably seem very similar to each other but believe me this

is some very good practice around linked lists and making sure that you really understand how to work

with one.

So I know this might seem like all that repetitive but this is some very good practice and I'm very

happy that you're going through it with me.

So let's talk about insert last right here insert last will be called with some data argument we need

to take this data argument create a new node stick data into that node and then insert that at the very

end of our chain.

Hmm.

Let's give you an interesting one.

So let's put this in Diagram format and think about exactly what we need to do.

So to get let's say this new node that we'll call orange right here into the very last entry inside

of our chain.

But we really have to do is get a reference to the current last node and then we will set the current

last node next property to look at this new orange one that we would create.

So in order to insert something at the very end of our linked list we need to make sure that we can

get a reference to the last element.

Now you might be thinking OK let's write another for loop into that same process again.

But in this case I want to remind you that one of the methods that we already put together inside of

our linked list class if we scroll up a little bit we can find it.

So up up up up here we go.

So we already wrote a method called Get last that will return the very last node in our current linked

list.

So when you are in an interview setting if you see some way to reduce some amount of code you've already

authored I highly encourage you to do so.

So this would be a perfect location where in an interview you could either say All right let's iterate

through our linked list and find less node or you could also simply say well let's call the get last

method that we already put together and we will take the last node and add some existing or some additional

node onto it.

So for our solution we're simply going to call get lost we will get the last note on the chain.

We will create our new node which will be this orange one right here and then we'll make sure that the

old last note points to the new one that we've just created.

And that's pretty much going to be it.

Now there is one other thing I want to point out here for this solution.

Don't forget that we need to handle the case in which our linked list is completely empty as well.

So if we call insert last on an empty linked list we need to make sure that we essentially do the right

thing.

So in this case there is no last note here we would need to make sure that we create a node and have

our head property right here.

Point out to you know that we create.

So make sure that you handle both those different cases.

All right let's flip on over to our code editor and not forget to go to our tests.

Just file around line 138 or so I can make sure that I remove the dot Skipp for insert last right here.

All right and let's save that test file.

So we should now see the insert last test failing.

All right.

So go ahead and give us a shot of catch up with you in the next video and we will go over a solution

to the insert last method.
--------------------------------------------------------------------------------------------------------------------

86. Adding InsertLast
In the last section we spoke about adding on the insert last method.

So we're going to create insert last by reusing the get last function to get a reference to the last

note on our chain.

We will then create a new node and attach it on.

We need to also make sure that we handle the case in which our linked list is empty and there is no

last node for us to retrieve.

All right.

So let's get this shot of flip on over to my code editor at the very bottom of our current linked list

class all out on insert last I remember that insert last is going to be called with some data argument

that we are supposed to insert into a new node.

So let's first start off by getting a reference to the last node in our current linked list.

So say conc last equals this dot get last.

So that word tree if the current last node in our list.

Now this is the point at which we need to put in some type of check to see if we have any node at all.

So last right here can be either a defined node or it could be the value null.

If we do not have any nodes inside of our change at all.

So we will distinguish between these two cases by saying if last exists then do something otherwise

do something else and I'm going to add a comment in here just to remind myself if we enter this statement

or this section of the if statement then this means that there are some existing nodes in our chain.

Otherwise if we enter the else case that means the chain is empty.

OK.

Now inside of this first statement we will create our new node and pass in our data to it.

So say new node.

And here's the data.

So this will return our node and we want to make sure that we set the previous node on the chain its

next property to point out to know that we just created.

So we can do this all in one line will say simply last dot next equals new node

then the other thing we need to do is handle the else case right here.

So in the case of the chain is empty there is no last node we have node next property on the last note

update.

So instead whenever we call insert last that means that we probably want to create the node and then

set it to the link list head property because we are inserting the very first note of our chain.

Even though the method is called insert last.

So in this case we would call new node paths in our data but then rather than updating some last node

or anything like that will update this head like so.

All right let's check our tests and see how we're doing.

And yep looks good.

Adds to the end of our list.

Cool.

All right.

So that's pretty much it for some of the easier methods that we're going to work on.

So some of the later ones are we are going to work on now are variations of some of the methods that

we've already put together so you can see that we're going to put together methods like get at which

is supposed to return the node at a specific index remove at and insert at.

So these are all going to be methods that modify or retrieve some data at any possible element or any

possible index along our linked list.

So all these methods right here are going to be kind of variations on what we've already done.

But they're going to really test your knowledge and make sure that you can really understand what is

going along with a linked list.

So let's take a break and start on our get at function in the next video.

------------------------------------------------------------------------------------------------------------

87. Pick Em Out with GetAt

In this video we're going to start tackling our get at method.

So I think you have probably a reasonable idea of what we're trying to do here.

We want to iterate through our linked list and find some element at a given index which we provided

to us as an argument to get at function.

So this right here is going to be the mentors.

Scuse me the index we were trying to retrieve.

Now one very important thing to keep in mind here is that link lists are zero indexed just like arrays.

So the very first element in our linked list would have an index of zero.

So if we said get at with zero being passed into the function that means give me the first node in the

chain after calling get at we would want to make sure that we return the entire node.

So not just the data inside the node but give us the entire node at that particular index.

So in this video I can give you kind of an outline of one possible way of doing this.

Again this is not the only way of tackling this problem.

But this is one possible way that's going to work all the time.

All right.

So here's our linked list.

We're going to imagine that we want to retrieve the node at index 2.

So this would be index 0 index 1 and index 2.

So if we got an argument of 2 into our function that means give me the red node.

Essentially that's what we're trying to find right here.

So as one possible solution here's what we're going to do.

We can start off by creating a node temporary variable or temporary variable called node that will start

off looking at the first node in our chain.

We will then create a counter variable called Zero.

We will set up a while loop and will say if the index that we want is equal to counter then we must

have reached the node we care about and take the current node and return it from the function.

Otherwise advance through to the next node while also incrementing the counter variable.

So this would now be set to 1 because we're now looking at the node at index 1.

We check to see if counter is equal to index.

They still are not.

So we will advance the counter and advance the node that we are pointing at.

Now in this case index and counter are equal to each other which means that we probably want to return

the current node.

So that is again one possible way of handling this.

But if you can think of some other way.

Hey feel free to go for it before we cut you loose.

Remember that we need to enable our tests inside the test not J.S. file.

So inside the test not just file a law around like 150 or so of find the described block for get apt

and we'll delete the skip on there.

And now back inside our terminal we should see the failing test for the good at method right here.

OK.

So go ahead and give this a shot.

All catch up with you in the next video.

And we're going to go through a solution to this together.
--------------------------------------------------------------------------------------------------------------------

88. GetAt Solution
In this video we're going to go through the solution to the get method together.

Now before we start writing any code here there's one or two extra cases I want to tell you about.

I specifically didn't mention these in the last video just to give you the chance to think about them

on your own.

So there are two edge cases that we need to kind of be aware of here.

The first edge case would be the case in which we have no nodes at all.

So maybe we have an empty linked list but maybe some developer calls get at on our linked list.

We need to make sure that we don't accidentally crash here or do anything like that.

So again we can do a simple check to see if we have at least one node and if we do then we could just

go ahead and immediately.

Assuming if we have at least one node we can iterate through.

Otherwise if we don't have the head node then that means we should probably immediately return something

like NULL to say no we can't find that index or can't find that element.

Now the other thing I want to mention here is a possible edge case is if this method is called with

some index that is outside of the realm of our linked list length.

So someone called get at with an index of 12.

Well clearly our linked list is not that long.

So maybe we should handle that case as well.

Now for handling that case we could either call the get size method or just excuse me the size method

before we start doing any iteration and check to see if the size is greater than our index here.

But recall whenever we call size that is going to iterate through our full list of nodes.

So if we call size at the very start and then decide OK they are asking for a valid index we would then

iterate through a list again to find the appropriate node in which case for essentially iterating through

our entire linked list twice which is obviously not the most efficient thing in the world.

So we'll talk about another way of handling the case in which someone asked for an index that's out

of bounds.

Without doing that initial look up of this size.

OK.

So back inside my index dodgiest file at the very bottom of our class we will add on get at member this

we called with some specific index and then just look like we've done on several other methods.

The first thing we'll do is check to see if there is a head node.

So if there is not a head node then just immediately return NULL because we have nothing to iterate

through no more work for us to do.

We're done.

Now if we succeed in this check right here then we will start up our main algorithm.

So remember our algorithm is going to take a node temporary variable that's going to start off looking

at the first note and 8 counter temporary variable.

We're then going to iterate through our list one note at a time and for every step we'll check to see

if counter is equal to index.

If they are not equal then we will advance node on to the next node in the chain and we will also increment

the counter variable.

So I'll set up my counter variable at 0 and my node variable to look at the first node in our chain

which is just knothead.

Next we'll put together our while loop.

So as long as there is a node present as long as node is defined here then there is something for us

to do.

So inside the while loop We'll check to see if counter is equal to the index that we are trying to retrieve.

So if these two numbers right here are equal that means we have found the node at the given index.

We're trying to find.

So if this if statement is entered right here we will immediately return node.

Now if we don't meet this statement right here that means that we have not yet reached the index that

we care about.

And in that case we will want to advance our note along and also increment the counter.

So we'll say counter plus plus.

And then to move along our node reference we'll say the new node is going to be equal to node next.

So remember if no next if we're at the end of the chain and no debt next is null then we will sign no.

2 No.

Right here on the next iteration of the while loop We'll look at the value.

No that's falsie.

And so the while loop will exit right away.

All right.

Now the last thing we need to think about is the case in which we tried to ask for an index that is

out of bounds.

So if we reach the end of our linked list like let's say we go over to this node and we were asking

for index 12 then we would increment or count again we would try to move node onto node next and there

would now be looking at the value.

Which is presumably over here.

So if that happens if we tried to look at a note of Noal before we get this statement right here then

we would just exit the while loop entirely.

And so we exit the while loop.

That means that we were unable to find the correct node.

So if we exit the while loop we can simply say return NULL because hey we couldn't find it.

You asked for an index that we did not retrieve while running the while loop right here.

All right now there's one more thing I want to point out here a little bit of code consolidation that

we can do.

So notice how the check to see whether or not we enter this while loop is to look at the node variable

and node is initialized at this dot head.

So if this knothead is equal to NULL.

We will never enter the while loop and we will immediately return knoll instead.

And that's essentially exactly what this statement up here was already doing.

So in this particular case the statement is actually completely unnecessary because if this head is

not defined node will be a false value.

We will not enter the while loop and we will instead immediately return NULL.

So in this particular case we can safely delete the if statement at the top.

All right.

That looks good.

I'm going to save this file.

And let's see how our tests are doing.

And yet it looks like it is working correctly.

OK.

So that is our solution for the get at method.

Let's move on to our next method.

Remove that which is going to be another fun one in the next video.

So quick break and I'll see you in a minute.
-------------------------------------------------------------------------------------------------------------

89. Remove Anything with RemoveAt

In this section we're going to take a look at the Remove method so that you could guess what this thing

is supposed to do.

We're going to call remove that with some index of the particular node that we want to remove.

And our job is to simply remove that note.

So the first thing to do is to recognize exactly what it would mean to remove a node in the middle of

some given chain.

So in this diagram over here let's say that given this chain we want to remove the element at index

1.

Again recall that the first element inside of a linked list will always have an index of 0.

So this is 0.

This right here would be the element at index 1.

So our goal would be to remove this element to remove that element.

All we really have to do is find the previous node in the chain and update its next reference to now.

Skip over that one.

So we would end up with something that looks a little bit like this.

Now in theory that node might still exist in memory you know might still be there but as far as our

linked list is concerned it doesn't exist anymore because if we were to iterate through our linked list

now we would go from green directly over to Red and completely skip over blue.

Now this problem remove at is going to be loops remove at is going to be a little bit more challenging

because we need to consider many different edge cases.

At this point in time throughout all the methods we've put together we've kind of assumed that a developer

using our linked list class might accidentally make some type of mistake like they might try to insert

a element at an index above what our current index is.

Or they might try to remove the first node in a linked list that is completely empty.

And I want to continue that same kind of logic with this remove add method as well.

So I want to make sure that our linked list is not going to crash if we call remove that.

When say there are no elements inside the linked list or if we say that we want to remove the element

index one but there's only a single element in the linked list.

I want to make sure that we do not crash.

In this case as well.

And if we try to remove the element index 10 when there's only three elements in here I want to make

sure that we also don't crash.

In this case too.

So there's several edge cases that we need to be thinking about now let's check out our test file really

quickly.

So inside the test not just file or find the described block for remove that which is that line 1 67

or so.

And as usual remove the dot skip on their so I notice that there are tests on here to catch many different

edge cases so it doesn't crash if we call remove that on an empty list remove that doesn't crash.

If we pass an index that is out of bounds of the linked list and then it should be able to delete the

first node.

It should be able to delete some middle node and then finally it should also be able to delete the last

node on the linked list.

All these different cases are absolute edge cases.

These are different scenarios that you have to think about with your given solution.

So this really is one that might be a little bit more tricky than it seems at first glance.

Now if you want you can stick around for another moment and I'll give you one possible solution or not

a solution.

I'll give you kind of guidance towards one possible solution.

So here's one way of solving it.

Let's say that we want to remove the node at index 1 our previous remove method that we put together

the one remove last you'll recall we had a pointer to the first node and then the second node.

And then we kind of advanced those along until we found some node that had a reference of no for its

next value.

And you might be thinking that we can use that same type of approach where we have two of these little

pointers pointing out node one in Node 2 and then we advance them along until we find the given index.

Now there's just one little issue with that solution.

And the issue is that it doesn't really handle edge cases very eloquently like it doesn't really handle

the case in which we want to delete the first element very well without you writing a very discrete

if statement to handle that case.

So you could definitely take two references like a reference to some previous element and then some

current element and iterate through the chain.

You can definitely do that.

You just need to be aware that you're going to have to write a lot of code to handle to handle those

cases nightly.

Nicely excuse me.

So here's one possible solution.

One possible solution is to reuse the get at method that we just put together.

So remember we just did get at two seconds ago and that retrieves the element at some particular index.

Now rather than calling get at with the index that we're trying to retrieve we could call get at and

try to retrieve the element right before the given index.

So let's say that we're trying to remove the element at index 1.

We could call it get at with an argument of 0 and that would give us a reference to green right here.

Then we could update the next property on this thing to look over to read like so.

So again just like we spoke about previously reusing methods in an interview setting is the best thing

in the world because it shows that you know about code reuse and you can effectively reuse your code.

And it also allows you to come to solutions that are dramatically more straightforward than other complicated

ones might be.

Now one thing I want to throw out there is that even with this situation right here there are some corner

cases that you have to check because there still will be some corner cases and I'll let you figure those

out and kind of investigate what those might be.

OK.

So go ahead and give it a shot.

Personally I really recommend you try re using the Get at method but it's always up to you if you can

think of a better solution then certainly go for it.

So with that in mind let's take a quick break and talk about a solution in the next video.
-------------------------------------------------------------------------------------------------------------

90. RemoveAt Solution

In this section we're going to talk about one possible solution to the Remove method before we start

writing any code.

I want to identify two very easy to find edge cases that we're going to need to handle.

So the first edge case I want to think about is the case in which we have no nodes in our chain at all.

So we have no nodes.

Then we should immediately return.

And remember we can check to see whether or not we have any nodes by looking at the this property.

Now the second solution or the second edge case that I want to talk about here is the case in which

we are trying to delete the first node.

So the possible solution I laid out at the end of the last video was to reuse that get at method so

we can reuse get at to try to find the node at the index less one less than the one that we're trying

to remove.

So in this case we had said oh yeah let's try to remove the element at index 1.

So even this one right here.

So we could have used get at to find the node right before it.

So what happens however.

Here's the edge case what happens if we are trying to remove the node at index 0.

In this case there is no previous node.

So there's nothing over here.

So we need to make sure that we handle the case in which we are trying to delete the very first element

as well.

So those are two corner cases I can immediately think of.

There is one more corner case but it's only going to kind of become obvious later on through our solution.

So we'll come back to this diagram in just a little bit and talk about what that third corner cases.

All right so back inside my index file I'm going to add on my remove at method which is going to get

called with some argument index.

So this is going to mean the index of the element that we want to get rid of.

So the first thing we'll do is check to see if our list is empty.

So we'll say if there is no head element then just immediately return.

Let's checked our test and see how we're doing over here.

So looks like move out is now passing the first test here which is to not crash on an empty list.

You'll notice that there is another method here that says make sure that you don't crash on an index

out of bounds and it looks like we are passing that one as well but it's only saying it doesn't crash.

Right now we're not really doing anything at all so that test might be passing kind of erroneously at

this point.

Now the next case that will take care of is the case in which we are trying to remove the head element.

So if index is equal to zero if we're trying to remove the very first element the element at index of

0 then we don't want to try to use any fancy algorithm here or anything like that.

We're going to repair that chain or we're going to update the chain very manually.

In this case.

So we'll say this dot head will be this dot head dot next.

So in other words rather than pointing at this first element right here point at the second one in the

chain and that effectively removes the first element.

And remember this will work.

Even if the list only has one element inside of it if there is only one element here the next value

would have been null.

So if we point head at an old that still works the way we expect it to because if we remove the only

elements well then our list is empty and heads should be pointing at all.

All right.

So if we meet this if statement right here we need to also make sure that we meet the return from the

function as well because we don't want to execute any other logic.

And here's where things start to get a little bit more interesting.

So here's where we're going to reuse our get at method.

We're going to you reuse get at to attempt to find the previous node or the one right before the one

that we are trying to remove.

So if we are trying to move the index at one I want to get the element at index 0.

So we'll say conc previous Is this dot get at index minus 1 so noticed the very clear choice of variables

here.

We're saying this is going to be called previous Just to make sure that it's very clear to any reader

that we are finding the previous or the node occurring right before the one that we're trying to remove.

One thing I would really encourage you not to do is to call this something like note because then the

meaning is kind of lost and we have to ask the question OK is this the node we're trying to delete.

Or is this the node right before the one we're trying to delete.

And there's really no ambiguity there.

If we call it previous or something similar to it.

All right so now here's where we start to run into some other corner cases.

The first thing I want to do is to kind of put together the direct solution and then we'll worry about

the corner case we'll see the corner case or the case start to fail on our tests in just a moment but

let's first try to get our stuff working.

So if we found the previous node.

So if we found this one right here we need to make sure that we update the next property to look into

the future.

So I want to make sure that previous dot next looks at previous dot next which will be this one next

which would be this one.

So that's going to be a little bit weird looking.

We're going to say previews start next.

So the next node we should be looking at is the current next dot next.

So this is a confusing line of code just one more time let's look at the diagram very quickly.

So at present when we first run that line of code previous start next is looking at blue.

The one that we want to look at will be previous dot next dot next.

So that's previous dot next dot next.

And we're going to assign that to previous start next.

So that's what's going to leapfrog blue right here.

And make sure that we point directly at red.

All right let's see this and see exactly what happens because I'm not entirely sure that we're going

to get the correct result in all cases.

So if I flip back over here is remove at.

And you can very quickly see that remove at is crashing on an index that is out of bounds.

So here's the third corner case.

This is the case in which we accidentally call remove out on an index that is greater than the total

number of nodes that we have inside of our linked list.

So this to be the case for example in which we try to call remove out with an index of 12 when we only

have three elements here.

So this is going to be a solution or something that we can probably figure out a solution to pretty

easily.

Remember that the get method is wired up to return null.

If we try to find some element that doesn't actually exist inside of our linked list so we can exploit

that to put in a little bit of check of a check to make sure that we are actually retrieving a valid

previous element right here.

So right before we tried to update previous next will say if previous does not exist then just return.

So this right here would handle the case in which we'd just attempted to ask for an index that was out

of the bounds of our linked list.

So let's see how our tests are doing now.

Well it looks like that test is still failing.

So what situation could this be failing it.

Well this is a very very court case.

But let's look back at our diagram and try to think about One More corner case in which this might fail.

OK.

So back to the diagram right here.

Let's imagine that are linked list has three notes.

Exactly as it does right here.

And then let's say maybe we tried to call remove that with an index of three.

So what would happen here.

Remember index zero index 1 index to index three is not.

There's nothing here when we called good at with index minus one that would retrieve the previous element

which would be red.

So in this case when we called Get at it did successfully return an element something does exist here.

However the next element in the chain is null.

So when we tried to call previous next this returns null and when we then call it next on that with

this extra dot next on here we are trying to read the property dot next of undefined and that's where

the error is coming from.

So this is a super edge case in which we are trying to remove the index at the one or the index.

Essentially one larger than the total size of our linked list right here.

So a huge edge case just to be aware of.

So to catch this situation we can add on another statement or another condition to our IF statement

right here to make sure that we have a valid previous node to work on.

So will say if previous was not found or if previous does not have a next note.

So if we were not able to retrieve the note at the given index or if that node is actually the last

one then hey you know what we need to return.

We can't possibly remove the node at the provided index.

So let's save this and now see how we're doing.

So back over at the Turnell Yup looks like we got all test passing.

OK.

So this was you know a method where at first glance it seemed very similar to some of the other ones

that we wrote.

But when you really start to think about it there are several edge cases that we had to consider.

So we did come to a solution which is fantastic.

Now there's just one more method that we're going to work on.

That is kind of a repeat of all the ones that we've already done.

So let's tackle that one in the next section.

It's going to be insert that.

So we'll tackle that in the next section and they'll move on to two additional possible steps here that

are a little bit more advanced.

So quick break and I'll see you in just a moment.

------------------------------------------------------------------------------------------------------------

91. Insert Anywhere with InsertAt
All right this is going to be the last of these simple manipulation methods that we're going to put

together.

So we're going to work on the insert at method insert at will be called with some amount of data and

then an integer index of where this new node should be inserted.

So we want to create a new node and insert it at the provided index.

Now important edge case here.

If the index is out of bounds then we'll want to add the node to the end of our list.

So just a little edge case there.

OK.

I bet you can kind of imagine how this might work.

Let's imagine that we have some list with three elements and we now want to add in a fourth one just

to be clear when we call insert at we're going to be only providing the data field.

So really just this part right here.

But we're going to kind of imagine that we immediately create a new node out of that data inside of

the insert meant insert at method.

Now we want to insert this new node right here at index 2.

So we've got index zero index 1 and index 2.

Now when we call Insert out we are not overwriting anything.

We are simply inserting a record.

So the goal here would be to make sure that this new node gets located at index 2.

That means that the current node that has that index too needs to be shoved on over to the right hand

side like so we should then insert this new node

and then repair all the connections.

So the previous element or the previous node should now point to the new one that we just added and

the new node should point at the previous element that was that index too.

All right.

So let's talk about how we might approach this.

Now there are a couple of edge cases here again we need to remember that the case in which we try to

insert a node in a list that is completely empty.

So let's not forget about that one.

The next case that we might want to consider is the case in which the provided index is completely out

of bounds.

So something like You know we try to call out inducts with 12 if the index is completely out of bounds.

Then we should probably add on the index to the very end of the linked list.

All right so those two edge cases in mind here's one possible way just a general rule of thumb of solving

this we can again use that get at method to get a reference to the previous node in a chain.

So let's say that again we're trying to insert something at index 2.

Like right here we could use the get at method to get a reference to the previous node.

So this one right here.

We will then create the new node we'll make sure that the previous one points to the new one and that

the new one points to the old one.

So really it's not the worst thing in the world.

I bet you can probably figure this one out.

All right before I cut you loose Let's also take a look at some of the tests that we have around this

particular method.

So one side of the test.

J.S. file here.

I'm looking at around lying to 20 or so and we're looking at the insert at block.

So again we're going to take care of the skip here.

And I want to very quickly read through some of the edge cases that will be tested.

So here's one possible edge case.

Insert a new node with data at the index 0 when the list is empty.

So that's one possible edge case.

Another case would be when we tried to insert a new node at index 0.

When the list has elements inside of it.

So that's going to the edge case as well.

And then here's a very typical use case the case in which we tried to insert some data or insert some

new node at some middle index.

And I think there might be one more here.

Yes.

So inserts a new node at the last index.

So this may or may not be in edge cases.

Well I'll let you kind of figure that out.

All right so this is the last big one before you start working on two extra methods that are kind of

like extra credit so to speak.

So give it your best shot and we'll go over the solution to this in the next video.
---------------------------------------------------------------------------------------------------------------------

92. InsertAt Solution

In this video we're going to go over the solution to the insert app method.

I'm inside my index file.

I'm going to give myself a little bit of space here and then will add the insert at method so it will

take arguments data and index and then inside of here we're going to do a little bit of work.

So the first thing I want to do is check the case in which our linked list is currently totally empty.

So this has been a very common theme throughout many of these methods.

I want to make sure that if our list has no elements inside of it then we should create a new element

and point our head property at that new element so inside of insert that will say if this dot head does

not exist.

So note the exclamation right here then this dot head will be a new node with the data that was passed

into our function and then very importantly will want to make sure that we immediately return.

So let's say this and see how our tests are doing back over at the command line.

Here is insert that it looks like we've got a number of different tests here.

So this is now passing our first one where we are trying to insert some data at index 0 when the list

is empty.

So those are pretty easy one.

Next we're going to take care of inserting a new node with data at the zero index when the list does

have some elements.

So just like the previous one when we used get at on our remove at method or Sumi room remove at method

that we just put together a moment ago.

You'll recall that there was an edge case if we tried to insert something at index 0.

If we tried to get the previous element before index 0 Well there's nothing there.

And so if we try using a similar get at index minus one scheme again we'll need to make sure that we

handle the case that we're trying to get at the element of index zero.

So essentially right after this statement will say if the index are trying to insert out is zero then

we're going to take care of this one manually.

So we'll say that the new head.

So this dopehead is going to be a new node with data and then remember the node construct right here

takes a second element or a second argument.

The second argument will be used as the next reference inside the node that is created.

So if we pass in here the current head then we will make a new node that has a next property of the

current head.

And so if we put that into diagram format over here it will look a little something like this we would

call new node to form up this orange thing right here.

We pass in the current head which links it up on the next property.

And the last thing we have to do is to make sure that we update the head of the linked class to look

at this new node that we just created.

And so back over here that's why we assign it to this knothead support index of 0.

Pretty straightforward solution now again will want to make sure that if we caught this case right here

as edge case of index 0 we want to make sure that we immediately return from this as well.

All right now it's on to our last big case the case in which we are at some middle element or no who

knows whatever it might be.

So in this case we're going to want to try to find the previous element or the one right before the

one that we're trying to add for our new node.

So let's imagine that we have index of two here.

That would mean that we want to kind of displace read.

So we're going to try to you call get at with index minus 1 to find the previous node.

So we will say conc previous Is this dot get at index minus 1.

So this will give us the previous note.

We will then create our new node.

And just like we did previously.

Or just like we saw in that previous corner case over here.

When we create this new node we will pass in the current node after previous.

So right now we just have a reference to previous The Current.

Next will be read over here right.

So we're going to create orange right here.

And when we create orange we will pass in red as the second argument to it.

And so that will automatically make sure that orange gets hooked up as that red gets hooked up as orange

is next property.

Now blue over here is still looking at red.

So we've now got two nodes that will be looking out red but we'll fix up that in just a moment.

So back inside my code editor will say conc node.

So it's going to be the new know that we're going to make will be new node it will contain the data

that was passed into our function and then the next node will be previous next.

So again previous right here would have been blue.

Previous is current next property is looking at red and we want orange to paint it red as well.

And so we pass in red as the second argument to form this connection and then the last thing we need

to do is to make sure that previous now looks at the orange node.

And so it's form that connection we can say Previous Next is node like so.

All right let's see how our tests are doing.

OK.

Well it looks like we've got almost everything passing but there's still this one test right here that

is failing.

So the case in which we are trying to insert a new node when the index is out of bounds.

So we saw this previously.

Remember this would be the case in which we tried to call add or insert out excuse me with an index

of something like 12.

So if we called get at with 12 the value nil would be returned.

So let's kind of diagram that out and think about what might happen in that case.

So I'm going to undo a couple of elements here.

Let's move this one back over and I'll bring on a text Sahlmann over here to represent null.

So if we have good index of 12 when we call get at we're going to get no returns.

And so the previous variable will be referencing no.

Now all of our code is going to work.

Nothing's going to crash.

We're going to create our new node and its next property we'll be looking at.

No.

So we can kind of imagine that we are in this type of situation right here.

But the problem is that red is not looking at Orange remember that the directions by the way had said

specifically that if the index was out of bounds that node had to be added to the end of the list.

And that's the case that we're handling right now.

So Orangery point putting it all which is OK that's what we expect it is now going to be the last node

of our list but we need to make sure that red somehow gets updated to point at Orange over here.

So realistically we really need a reference to read.

That's what we really need right now.

So one way of handling this would be when we try to get this started get an index minus one.

We can say if this returns a falsie value right here then instead we want to consider the previous node

to be the last node of our chain.

So let's write that out for a second here watch that we're going to say or this dot get.

Last like so.

So if this function call right here returns a falsie value then we will go into this or case and we

will instead run this line of code right here which is to say Go and get the last node in our chain

so get lost will be assigned to previous.

We will create our new node and the new nodes next property will be previous start next which had been

known as well and then previous done.

Next will be now updated to node.

And so this line right here will make sure that red is now pointing over to orange.

So let's save this file and see how our tests are doing now and we're passing everything.

Awesome.

OK.

This has been one of the harder ones especially thinking about some of the different corner cases here.

So let's now move onto the next video we're going to talk about one little extra topic that I just want

to throw out there is something it's kind of interesting about our linked list implementation.

And then immediately after that we'll talk about this for each and for of loop implementations for our

linked list.

So a quick break and we'll come back in the next video.
------------------------------------------------------------------------------------------------------------------


93. Code Reuse in Linked Lists

Before we move on to the next piece of our linked list implementation there is one kind of interesting

thing that I wanted to point out here that might be relevant in an interview setting.

Let's imagine for a second that your interviewer went through all the same task that we just went through

where they said OK let's build a linked list.

And they said let's make insert first get first get last.

All these kind of good methods.

And then maybe at the very end they said hey let's implement good at remove and insert that.

Well there's kind of a very interesting relationship between get at and get last and get first.

So if is get at it allows us to get some element at a given index and then we have get first which is

always going to return the element at the very first index or the first Delman side of our linked list

and get laughs which will always return the element at the very end of our list.

So when we really think about it writing get first and get last as separate separate implementations

might not have been the best idea in the world.

Here's why.

Rather than writing all these separate insert first insert last remove first remove first last get first

and get last.

We could have just written insert at remove at and get at.

And then provided some appropriate arguments to each of those to manipulate some given index.

So in other words we could have just written these three methods alone and nothing else and that would

have achieved the same effect as writing all of these other ones.

So if you're sitting in an interview and your interviewer says OK let's make a linked list and maybe

you should write a method that retrieves the first element.

Maybe that would be a good time to ask them and say hey are we going to be doing any retrieval of any

other elements because if we are maybe I shouldn't write an insert first method maybe I should instead

write an insert at method that was going to go such an incredibly long distance in an interview setting

to have that kind of forward looking thinking to me to tell your interviewer Hey maybe here's a better

way to put together this solution.

Oh man.

Personally if I was interviewing you that would blow me out of the park.

So is this just an example of something I want to throw out there where if you're in an interview setting

it is totally appropriate to suggest something like Hey I'm rather than writing these very specific

functions.

Maybe we should try to write something a little bit more generic.

Now just to give you a good idea of how this would be put together in practice.

So I've taken our class linked lists and I just condensed all the functions here.

I'm going to uncondemned some so I'm going to unfold it all.

That did not work the way I expected it will do is to talk to you instead.

There we go.

So one possible way of doing this would be to say rather than calling insert first rate here we could

have called this dot insert Act passed in data and then hardcoded a index of zero because index zero

is always going to be the first element.

So let's say this and see if our test will pass.

So save the file and going down here.

Yup.

Tests are still passing and then we can very well continue on through our implementation here.

So in some cases maybe it's a little overkill like in the case of get first right here but hey why not.

So maybe this would be return this dot get at with index of 0.

Looks like we're still passing Get last would be not this long implementation.

I'm not going to beat this one let's say this code commented out instead.

And this might be return this dot get at this dot size minus 1 and that would still be passing.

I think you get the idea here.

So we could very easily go through all these more specific functions and replace them with the much

more generic at functions that we had put together previously.

So again this is just something I want to throw out there as something to keep in mind when you are

in an interview setting.

OK so then mind let's continue the next section where we're where we are going to talk about two additional

topics about linked lists and then we'll move on to some specific interview questions that feature linked

lists.

So quick break and I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------

94. List Traversal Through ForEach

Up to this point in time we've taken a look at a lot of different methods that help us kind of manipulate

single elements or delete or remove elements but always one element at a time in our linked list in

this section we're going to start working on a for each function.

This will allow us to pass in our own custom iterator function that will then be applied to every node

inside of our linked list.

So perhaps the best example of this would be to look at their code example over here on the far right

hand side.

So if we make a list and then we insert 1 2 3 4 in order we should then be able to call list for each

pass in our own custom function right here.

Then in the body of the function we should see this thing getting called four times.

So my inner function right here is me for called four times one for each node in our linked list the

node should be passed in as an argument along with the index of the given node.

So if we iterate through every node on the chain and add 10 to every data field then after running this

line of code right here if we pulled out the first element we should get back a node with data of 11

specifically the number 11 not the string here.

I know those quotes are a little misleading.

Now it's specifically B 11 because we looked at this number one right here and we added 10 to it.

Every other node in the chain should have 10 added to it as well so would be 11 12 13 14.

I just gave you an example of what that very first node would look like.

OK.

So this is a example where I would really like you to give a shot at it on your own.

I can give you a hint or two.

Essentially you're going to be iterating through our linked list and then for every node in the list

you will call the provided function.

So this will be a function that is provided as an argument for each let's not forget to enable our test

as well.

So over in the test file or scroll on down to a line to 75 or so and we'll make sure to take out the

dots skip.

And so you can see in here it's essentially running the same tests that we just saw inside of the example

field.

So we're going to insert one two three four iterate through it.

Add 10 to every element and then just make sure that the totals are the data field of every one of those

numbers was updated correctly.

So go ahead and give this a shot and we'll talk about a solution in the next video.
----------------------------------------------------------------------------------------------------------------

95. Note on Generators
----------------------------------------------------------------------------------------------------------------

96. Brushup on Generators

I'm here on the official documentation for battle we use battle to translate ESX or yes 20:15 code to

compatible S-5 code so that we can run in today's modern browsers Babel has a lot of documentation on

their useful stuff like say destructuring default rest and spread God Letten Collins.

Of course that old standby.

And we start getting into some more interesting stuff that you don't see quite as often on tutorials

about as 20:15 stuff like say iterators and then today's topic which is generators though generators

are definitely something that kind of mysteriously gets skipped out on on a lot of yes 2015 tutorials

for some reason like it a lot of people don't talk about it too much.

I can give you a very good reason why it's because generators are pretty tough to get wrap your head

around.

Even if you read the official documentation here it says generator's simplify iterator authoring using

function start and yield.

OK.

And that's not quite really explaining what's going on with him or even what's going on with this example

right here.

So let's spend a little bit of time to X explore generators and specifically I want to explore generators

around the topic of writing iterators or giving us the ability to iterate through a collection of data.

So let's talk a little bit about generators.

I flip over to a little tool here that I authored to walk through generators.

It kind of works like a REPL but with a little bit of a twist.

So usually with a rebel or a javascript REPL you enter some code on the left hand side and then executes

it and spits out like the Singler result or some similar result on the right hand side.

So this replow of sorts has a little bit of a twist to it.

If I define a function called say increment

and from here I return 1 plus number.

I can now call increment say 10 and I can put multiple calls on here.

You can see that every time I call increment I get a result over on the right hand side.

But now here's the interesting part.

If I start changing the value all the other results stick around and only the number that I change is

going to update on the right hand side.

So I've put in 4000 here in 30 here 9 9 9 there and negative 5 4 4 9 9 whatever at the very top.

And you can see I get the instant update on the right hand side.

And then if I change the return value from 1 to say 1000 all in numbers update on the right hand side

as well.

So basically any statement on the left hand side that returns some printable value will be reflected

on the right hand side as well.

So we're going to using this tool a little bit to walk through generators.

Let's go and get back on topic though defining a generator.

The syntax is a little bit weird definitely dissimilar from any every other bit of syntax ever seen

in javascript before.

So to find a generator we write the function keyword and then a star for some crazy reason here and

then a name for the function the the.

Here it can go either to the left or the function name or to the right of the function keyword.

I've seen a lot of differing opinions on which side it should go on.

So at this point in time go with whatever floats your boat.

Now let's add a little bit of content in here and then talk about what's going on with this generator

and say Konst results equals one plus one.

So we're gonna have just very simple example here.

And this is where things get really weird and say yield result.

So now this is looking pretty strange.

You know first off we've got the star which marks this as a generator.

The sun really said what a generator is of course and we've also got this yield keyword in here as well.

We're going to go ahead and without any real description of what's going on.

Let's see what happens when I say execute this functionality and say Konst generator is numbers I'm

going to execute numbers right here.

So whenever I run numbers it returns a generator object.

By convention you can call this thing generator.

Jan list of numbers again.

I haven't really seen a lot of good convention on what to call this return value.

So the first thing you might be thinking here is not thing.

OK well we're running the function numbers.

Well we are executing one plus one.

And then I don't know something with yields and we're adding 20 to it so I guess maybe the result we

should get here is 22.

So let's see what generator is.

So when I print out generator I get empty object over here.

So I had expectation that we had out of number as a result but looks like we get an object back.

That's definitely strange.

It so we can use this return generator object to manipulate or walk through segments of the coding here.

So I would call generator Dighton next Nelson and we get back a interesting Valley value of two with

a another property of Duyne false.

So this is an object right here that generator doesn't access returning.

So here's what generators are doing.

Here's like you know the big summary of the big buildup when we define a generator we call the generator

and call.

Next on the return value.

We call darte next the code inside the generator is going to execute until a yield statement is found.

That's like the interesting part.

A yield statement is found execution of that function is pots.

So let's take a look at a diagram here and see if that can help us figure out what's going on.

So we've got this function called numbers right here it's the generator when we call Konst Jan equals

numbers so we get some result being assigned to Gen returns a generator object.

So this generator object has the ability to step through the function with the next method.

So we called Gen generator next.

And it caused us to kind of step through the generator called generator value multiple times.

And so the first time we called Next like generator does next it's going to execute everything in the

green code so everything all the way up to the first time that we find a yield state.

Every place a yield statement if we place a value directly off of it after it that value will be returned

from the first call to generator next.

And so that's what we saw here we call generator.

Next we called yield that paused execution and the return was the result was just result.

And that's why we saw a value of two here because we had results one plus one.

And then we yielded results.

Now here's where things start to get really interesting and definitely a little bit less predictable.

I can now call generator dot next a second time to resume by function here.

Resume execution of my generator.

So if I call a generator next again you'll see I end up with no.

And so that's kind of strange why do I have no mole here.

Well try passing a number here and just see what happens.

So I get a pass in 10 and you'll see that now value gets incremented to 30 right here.

So here's the really hard to par really hard part to understand about generators is the part that's

really hard.

The first time I called next generator executes all the way up to the yield statement and then it automatically

returns whatever was yielded.

In this case result the next time I call generator again next if I pass that value that value will be

inserted in place of the yield statement.

So when I make the second call right here this generator doesn't X with 10.

You can kind of imagine that this highlighted portion right you're suddenly magically becomes the value

10.

And so we then return 20 plus 10.

And the result is 30 over here.

OK so that's in practice what generator's do we call next it will run all the way until we have a yield

statement.

We can call next again and then we'll pass the value back into the generator and continue the execution.

So you obviously know nothing at all right.

Well that sounds not very useful at all.

Well let's look at a little bit more complicated examples and then talk a little bit more about what's

going on.

So I'm going to delete all the code that we have right now and I to create another generator called

list outside of here.

I'm going to put a bunch of old statements and it's a yield one to

three four five.

That's got to change the numbers.

So we're going to count up 1 through 5 3 4 5.

Now again I can call a tossed generator list if high yield.

Excuse me if I.

Next.

First I get one.

Because that's the value or what gets yielded by the first yield statement.

I can call a generator next to second time.

That's going to go back into the generator on this line of code and it's going to execute again until

the next yield statement is found.

And the next yield statement returns 2.

And so I get a value of two and I can say generator.

Next again get three and repeat the process so on and so on until I finally get five.

And then at the very end if I have no more yield statements and no return statement either if I call

next again I get done.

True.

Return.

You'll notice that because I did not have an explicit return inside of here I don't get a value on the

very last time.

Very last time I call it.

Now I can keep calling generator.

Next again and again it's just going to keep returning an object that says Done true.

So perhaps that's not I know it's not the worst thing in the world if we keep calling next more frequently

than we need to.

So the idea here is that we can have multiple yield statements inside of a single generator.

So why would we ever want to do this and how does this all kind of tie back to the topic of iterating

or iterating over a collection of data.

Well take a look at it see how things can get really interesting.

I'm going to create a new variable and I call it the same numbers and I'm going to create a for loop.

So I need to save for LET.

Value of generator.

So here's the generator.

And we created a generator which is the return object from calling the generator function.

And now we're going to say let value of generator and for every value that gets spit out of the generator

I'll say numbers not push value.

And then finally after the loop is all done we'll print out numbers.

So you see I get the value 1 2 3 4 5 for numbers right here.

And so this is where generators start to get a little bit more interesting a little bit more useful.

We can iterate over a generator function.

And for every yield statement that we have in here my FOR loop will execute one time.

So I've got five yield statements.

I end up running the body of my FOR loop five times each time the value variable in here is equal to

whatever got yielded out of my generator.

OK.

So you might be seeing this now and thinking OK well all right looks like we can do some amount of iteration

but am I ever going to write like yield 1 2 3 4 5.

Am I ever going to just like you know spit out a billion yield statements.

How is that useful at all.

Why don't I just make an array.

Good question.

Let's expand this example a little bit and see what happens.

I'm going to keep her on the list right now and I'm going to make a separate list which I'm going to

call more numbers and change the name of the first generator just numbers as well.

OK.

So now we've got two generator functions.

And the second one I'm going to yield three yield for Yield 5 and I think that'll do for now.

And then up here inside of the first generator I'm going to change this to 6 and 7 I'm going to make

something that's going to really throw everything into a twist.

I only say yields are more numbers like so than that I'm going to call it.

So again we see this asterisk here now without seeing what's really going to happen here.

What's going on.

I'm now going to create my generator

and then I'll say

make my four loop again my 4 of.

So let values and get some new lines here.

There we go.

So for

less value and this can just be a straight here.

So what value of generator.

And then again I'll say values not push value and they will print out values.

And so now when I print out values you see that we have 1 2 3 4 5 6 7.

So this is just another little feature.

Interesting one that's going to help us with some more iteration if we create two generators we can

nest.

Generators are kind of delegate behavior here.

So we went from yield 1 to and then we said yields star and yields star specifically means.

Hey I'm about to pass you another generator.

The next time that someone calls next on this go into that generator and execute it until we hit a yield

statement.

And so the result is we call numbers first time we call.

Next we get one then two and then we hit the yield the delegates to more numbers so we go into more

numbers.

We get three four five or number says no more yields.

So execution goes back out to six and seven and we get the result 1 3 7.

OK.

So this is still really hard to see where this would ever be useful at all.

Still doesn't feel very useful.

So let's go to a real somewhat practical example still give me pretty theory based but obviously something

needs something in show you can show your friends.

I'm going to use six classes to create a tree class.

And so this will be like a typical computer science tree where we've got a head and then many children

beneath it and create a constructor by default a value of NULL.

And then I can also pass an array of children as well.

I went back.

So then inside of the constructor set the start value equal to value children equal to children.

And then we're going to something very strange very interesting in here.

You to create a generator that is a method on the tree or I should say property on the tree class and

now inside of here I'm going to yield just this stock value.

So let's create a tree this create a tree structure and see what happens in say conc tree equals new

tree.

And the head of the tree will have a value of 1 and then it will give it some children as well.

So the head of the tree will have first a child with a value to the child to have its own child.

The value of four

and then finally will also have a node on the tree with a value of three.

So essentially what we got is where the head has one and has children of two and three and the node

of two has a child of four years.

We got some tree structure going on here.

So I want to write a function that's going to iterate over this tree when it rained over the tree and

collect all the values of the tree into a single array.

And I want to do it in a depth first search fashion.

So I want to go all the way down as deep as I possibly can and then start walking through the trees.

So essentially the result I would expect to see here would be an array of 1 2 4 3.

That's what I expect to see here.

So here's how we're going to tackle this.

I have a generator that right now just yields the value of the head of the tree or you know whichever

node we're operating on here.

So I can call a tree print values next like so and I get back the value of one that's come from the

head on a tree.

I want to iterate through the entire tree I want to go to every node in the tree and step through it.

So here's Oregon to say for let child of this children yield star children dot print values.

OK.

Now we got a little bit of recursive behavior here.

If I call print values if I call this generator on a single node in the tree I will first yield that

nodes value the next time I call next on it I will enter my for loop here.

As we just saw we can delegate to each other generators and so forth.

Each child of this top node of the head node will walk through its children and call print values.

On that note as well.

So this is the big grand finale that everything gets pretty interesting at the very bottom.

Again I'm going to create an empty array of const values and then we'll make a for of loop for value

of tree print values.

Notice I'm just passing in the generator here directly.

I'll save values not post value and at the very end we'll pass out values.

Looks like I got a little bit of a syntax error all the way down here.

The bottom looks like a children's undefined.

My mistake it should be this dot.

Excuse me is just child not children just child like so.

OK so you can see here that we get the result of one two three four.

So again we created a tree.

The very top of the head of the tree was a node a value one that had children of two and three.

And in the note of two also had a child of four.

We called the heads generator of print values and then we iterated over it.

That means that we are now walking into print values and we execute until we hit the first yield statement.

So at the first yield statement we enter the body of the for loop we push on that value to the values

array and then we walk back in to the generator.

We then start iterating over the heads children and for each child of the head we're going to delegate

to that child's print values function.

And so this is going to recurse through all the different nodes and eventually we walk over every node

in the tree.

So there is some practical use if you call walking through a tree.

Practical for generators.

We'll spend a little time in the future to look at some other more practical uses of generators because

even walking through a tree perhaps would be a little easier with some very basic recursions So we'll

try to walk through a couple of more realistic examples in the future as well.

If he's if you've enjoyed this video I encourage you to go to rally coding dot com.

Or you can learn more about the javascript ecosystem.

I have one video released per week and I look forward to sharing a little bit of knowledge with you.
------------------------------------------------------------------------------------------------------------


97. Linked Lists with Iterators

In this video we're going to start to talk about how to get our linked list to work with a four of loop.

Now if you are not familiar with generators or iterators I encourage you to go back to the previous

text lecture where I posted a link to a youtube video I created to help you understand exactly what

generators and iterators are.

Once you watch that video come back here and we'll talk about how to set this thing up.

In the previous video we spoke about the for each helper which we could use to iterate through every

node on the list.

We could then modify or log or do every wanted to every given node.

When we set up the four of helper right here we're essentially doing the exact same thing.

So we're still saying something up that will allow us to iterate through every node in the linked list

but this time around we're going to do that iteration using just a slightly different syntax.

So we're going to enable ourselves to use a form of helper on our linked list whereas previously we

were using the for each function.

So nearly identical functionality here just slightly different syntax that's all.

Now looking at the code sample for the for loop we should be able to insert some number of items into

our linked list and then iterate through each of those nodes by writing a form of loop that iterates

over the list and then every element that we are receiving inside the loop will be one distinct node

and notice this is the entire node that we are getting access to.

It's not just the data property or anything like that.

It is the entire node.

So our goal is going to be to set up a generator function with our form of loop or a linked list to

enable us to use the for loop.

So let's get to it.

Enough talking.

Now this exercise we're going to do together because it is one that's pretty darn complicated and it's

something that I'm just kind of throwing out here in case you were kind of interested in where you might

use a generator in the practical sense.

So I'm inside of my index file.

Here's the for each function and.

Underneath it.

We're going to add on a iterator function.

So we're going gonna say Star and then square braces symbol dot iterator then we'll close out the square

bracket here and add on our parentheses.

So this defines a generator function with the key of symbol dot iterator then sign it here will take

the head node.

So let's head equals this dot head.

Or you let node.

He calls this dot head.

And then we will iterate through our linked list with a while loop.

So we'll say while node and then node equals node next.

And then for every step along the node we will yield the current node.

So yield right here along with a star in the iterator and all this stuff is really only going to make

sense if you watch that previous video or if you have some previous experience with generators in Javascript.

So again I do encourage you to check that stuff out.

So now that we've added this block right here we can now use a for loop to work with our linked list.

Let's flip on over toward testate James file down here around line to ninety five or so.

You'll notice that I already removed the dot Skipp so make sure you remove that.

And it's just the describe with four of loops in this test we can take a quick look at what's going

on here.

We create a new list we insert 4 items and then we use a for loop to iterate through the linked list.

And for every node we add 10 to the data property and then afterwards the test make sure that the numbers

were incremented properly.

Let's look on over to our terminal where we can see the for loop is definitely working here.

So again this was just kind of a quick aside that I thought it would be fun to throw in here just so

you can see a practical example of a generator function along with the iterator as well.

So that's pretty much it for our linked list implementation.

We've gone through linked lists pretty much every possible way I could think of as far as working with

them inserting removing elements all that kind of good stuff.

But at this point we only really know kind of how a linked list works.

We don't really have any idea of where to use it or what type of interview questions we could expect

to see.

So we're going to take a break right now.

When we come back in the next video we're going to start to tackle some different problems that can

be solved very easily by using a linked list and some problems that are going to really challenge your

understanding of linked lists and how they work.

So quick break and we'll start tackling some additional problems in the next video.

=======================================================================================================================

Раздел 22:Find the Midpoint

98. Midpoint of a Linked List

Now that we've seen the ins and outs of linked lists it's time to tackle a couple of interview questions

that you can really expect to see about them.

So in this video we're going to kick off our first question around linked lists and we're also going

to take a look at a problem solving strategy for solving many different types of linked list questions.

So the second half of this video I'm going to show you a very strong problem solving technique to use

with linked lists.

So if you start to skip any content in this video please at least watch the second half.

So you can see that problem solving strategy in action because I can give you a quick explanation of

how it works in this video.

All right.

So inside my code editor I'm going to find the midpoint folder and then I'll open up the index top jazz

file inside of here.

So this is the first question we're going to tackle.

Notice that we're back to working with these functions like we were during the first half the course.

So we're not working with the linked list class anymore.

We got through that thing.

We're now going to go back to some function type questions.

So this midpoint function is going to be called with a linked list.

So a linked list will be provided as an argument to this midpoint function the linked list that's going

to be passed to this thing uses the same implementation as the one that we just put together a second

ago.

So inside the midpoint directory you'll find the linked list dot js file.

And so here is the node implementation and the linked list implementation.

They are identical to what we just put together.

So just to be clear on that.

So here's the directions of midpoint.

Our goal is to return the middle node of the linked list so the node at the very center of that might

sound like it's really easy.

But there are some requirements here.

So specifically we are not allowed to use any type of counter variable and we are not allowed to retrieve

the size of the list.

So don't be thinking that you can call linked list size get the total size divide that by 2 and then

retrieve the center element.

That's not the goal here.

The goal here is to somehow find the middle node of the linked list without knowing its size.

All right.

So we don't know the size.

We have no idea what the size is.

Don't try to access the size.

Let's take a look at this question in Diagram format.

Just to make sure it's really clear.

So we have five elements on the screen here for this linked list.

So the center element or the midpoint or the middle element whatever you want to call it would be red.

It's at the very center of the template.

So I think that's pretty clear.

Now one part that might be a little bit unclear is the second sentence of the directions.

So if there are an even number of elements we want to return the note at the end of the first half of

the list.

So in this example right here there are five elements.

So this is an odd numbered list.

So the very middle element is really obvious.

That's the one right here at the center.

However if we have an even number of elements then things are a little bit more ambiguous.

So here's 6.

And at this point there's really not necessarily a very clearly defined center node here.

Right if we look at the very center we're kind of right here in this gap.

So the directions are saying the directions over here what this end of the first half of list is saying

is take the first half the list and then take the last node in that half and that would be considered

to be the middle element.

If the list has an even number of elements in it.

So if there is an even number you essentially go to the middle and then one less than that is supposed

to be the midpoint.

So hopefully that's clear as well.

OK.

So that's kind of an overview of the question.

We're now going to talk a little bit about the very general problem solving strategy that we're going

to apply to this problem and many other types of linked list related questions.

So we're going to talk about the strategy now.

This is a really important discussion because again you're going to be using this strategy in many different

linked list questions.

This can be used for a lot of different questions around linked lists.

So let's get to it.

I'm going to pull up two little pieces of the diagram right here.

All right.

So let's walk through this.

So here's how we're going to solve this particular question.

We're going to talk about how we're going to solve the midpoint question.

And I think you're going to very quickly see how this strategy can be used on other problems and we

will take a look at some other problems that are going to use this strategy.

So you'll have more than one opportunity to practice it.

So here's what we're going to do to find the center node.

We're going to create two temporary variables.

One is going to be called slow and the other is going to be called fast.

We're going to take all these variables and point them at the first node in our linked list.

And when I say point at I mean just we're going to assign the first node to both these variables right

here.

So essentially we'll say slow equals the first node and fast equals the first node.

That's all after we do that initial assignment we will then start to iterate through our linked list.

So we're going to iterate through every note here.

But here's the interesting part for every step of iteration like every step of a while loop.

That's probably what we're going to use here for every step the while loop we are going to advance this

slow variable forward by one element and then we will advance the fast variable right here forward by

two elements or two notes.

So after the first step through the while loop the two variables will be updated to look at these two

specific nodes right here.

So slow is very aptly named.

We're always going to advance slow by one node at a time.

But fast is going to be getting advanced by two nodes at a time.

Now here's the real trick.

As soon as we advance fast to the next node we will then check to see if the node after one after the

one that it's now pointing at is defined.

And if the node after that is defined so essentially after we advance fast forward we're going to check

to see if the next two nodes exist.

If they do exist that means that everything is good.

And we need to still continue iterating through the list.

But if either of these next ones do not exist then that means fast must be at the end of the linked

list and that we can then consider slow to be at the midpoint.

So let's continue this through and see how this really works in action.

So at this point we're going to say okay the fast mode right here.

Does this have two nodes after it.

Well yes and yes they are.

OK that's great.

So we're now going to advance both of our pointers.

So it's going to move forward by one element.

So it's now plenty at red and fast is going to move forward by two elements.

So one two now we're going to ask the same question again.

Look at the node that fast is pointing at.

So purple right here are both the next and the element after that defined and the words are the next

to nodes defined.

Well in this case no they are not defined and so that means that we must be at the end of the list.

So slow is now pointing at the midpoint because it's moving half as quickly as fast is.

So as soon as fast sees the end that means OK we're at the very end.

Slow has been moving half as fast so it must be at the midpoint.

So that is the general problem solving strategy that we're going to use for a lot of different questions.

We're going to create these two separate variables.

Then we will iterate through our linked list one will move forward at a slow pace of one node per loop

and the other will move forward at a faster pace of two elements per loop and then we can make some

comparison between the two of them and kind of derive some neat information about the linked list from

that.

Now an immediate question you might have might be well what exactly happens if there is an even number

of nodes in the loop like why is you know what exactly happens when there is an even number.

I don't know.

This is something that for me seemed a little bit mysterious.

So just for completion sake I want to go through another iteration of this flow.

But with an even number of nodes and you'll see that whether there are an even or odd number.

This strategy still always works out.

So we're going to start off our loop again both slow and faster go into point at Green.

We're now going to advance slow up by one.

And fast is going to move forward by two.

So one two now we ask does fast node have both elements in front of it defined in this case.

Yes.

So we're going to continue to iterate on so slow is going to move forward one and fast moves forward

one too.

Now we ask are both two elements in front of fast defined.

So we look at one.

Yes it is.

But then after that no nothing else over here is defined.

And that means that we must be at the end of the list so slow must be pointing at the midpoint.

And in this case yup it definitely is.

Remember we had said that if there is an even number of nodes then we go to the midpoint.

You know that kind of gap right here and take that node right before it.

So even if there is an even number of nodes here we still end up getting the correct answer.

OK.

So hopefully that makes a little bit of sense.

I know that seeing it in Diagram format and hearing it with words is really not the same as writing

it out with code.

So I encourage you to take a shot at the solution and then we'll go through a solution to the real problem

together in the next video.

So quick break give me your best shot and we'll hook back up together in the next video.

And one thing I forgot very quickly Don't forget to start your test up with just midpoint test not J.S.

dash dash watch like so.

So don't forget to check your tests.

All right.

So take a shot and I'll see you in just a minute.

----------------------------------------------------------------------------------------------------------------------

99. Midpoint Solution

Hopefully you had some success putting the midpoint function together in this section we're going to

go over a solution remember that we just went over a kind of verbal description of what's going to go

on with our solution in the last video.

So if you skipped the last video I encourage you to go back and watch the discussion about using two

variables to keep track of iteration through the linked list.

So that's exactly what we're going to do here to solve this question.

So here's my midpoint function.

I'm going to open it up and then we're going to define our two variables.

Slow and fast and they're both going to start out looking at the first element in our linked list.

So let's say let's slow is list dot get first.

And just to be clear if you did list dot head here to get the first element that's totally fine no difference

whatsoever.

Absolutely fine.

And then let fast equals less dot get first.

Now when I spoke about exactly how we're going to approach this by saying OK are the next two elements

defined.

Well that's really the case that we're going to use for our while loop to iterate through the list.

So we're going to write a while loop.

And so long as the fast node has a node infirm it defined in a node in front of that defined then we're

going to continue to iterate.

So we will say while the fast node has one defined after it and there is something defined after that

it's all say fast dot next dot next.

So this checks the next node and this one checks the node after that as long as those two situations

are satisfied then we want to continue advancing through our linked list.

So we'll move slow forward by one by saying advanced slow to slow down next.

So slow down next right here would be the next element.

So here is slow.

If it's pointing out red then the next element in the chain would be the current slow value next which

would pass us on to the orange node.

And then for fast we're going to do something very similar will say jump forward by two.

So say fast.

Next Next like so now as soon as fast does not have a node in front of it or a node after that the while

loop will exit and so will then know that slow must be pointing at the midpoint.

And so we will simply return slow after the while loop runs and that's pretty much it.

So kind of a you know deceptively straightforward problem.

This is just another one of all these problems you've been doing.

I know I've said this so often but you know you've either seen these problems before or you haven't.

And so if you've seen this before and you understand the SO in the fast this is like you know what six

seven lines of code.

This is pretty easy.

This is pretty straightforward once you've seen the solution.

But coming up with this in an interview setting is extremely challenging.

And so this is why practicing ahead of time really pays off for interviews.

All right so save this file and see how our tests are doing.

And the up everything is passing.

So that's pretty much it.

Not that bad right.

Like I said we can use this strategy of having two pointers to solve a wide variety of different linked

list questions.

So let's continue the next section where we're going to look at a another linked list related question

that can be solved with this same type of approach.

So a quick break and I'll see you in a minute.

==================================================================================================================


Раздел 23:Circular Lists?

100. Detecting Linked Lists Loops

In this video we're going to take a look at another very common interview question that you'll see very

frequently around linked lists.

This is another question that's going to utilize that kind of two reference system to come to a pretty

straightforward solution.

So let's take a look at this one because again very common to see in an interview setting inside my

code editor I'll find the circular directory.

I'll open up the index file and then before I forget let's also store up our tests at the command line.

So inside my exercises directory I will run just circular test not j s dash dash watch like so and then

we should see about four tests right now.

So yours for Total Recall.

All right let's take a look at this thing.

So circular says given a linked list.

Return true if the list is circular and false.

If it is not so clearly the key word here to understand is the word circular.

So let's talk about what a circular linked list is.

Remember that up to this point in time we've always said that a linked list has a head which is the

very first note of the linked list and the tail and the tail node can be identified because it points

to a value of NULL which means that's the end of the list in a circular linked list.

We do not have a tail node with a circular linked list.

We would have a tail node or a kind of a last node so to speak or what we might imagine to be a last

node that maybe accidentally points out an earlier node within the linked list.

And so this is a diagram of a circular linked list right here circular linked lists are a huge problem

because as you recall from all of our linked list problems we've been working on.

We wrote a ton of four loops that all assumes that they would eventually find a node with a next value

of NULL.

So if there's no element in our linked list that has a next value of NULL then we would end up with

a ton of infinite loops.

So all those lock while loops that we wrote they would all be infinite in nature with a structure like

this because we would iterate from green to blue to red to orange to purple back to red orange purple

red orange purple red orange purple.

Again and again and they're never going to find a value of NULL.

So our job is to write a function that's going to detect this situation right here.

Now the first thing I want to say is that you might be thinking OK well let's iterate through the linked

list and then we will have a counter variable.

And maybe as soon as that variable gets up to like 10000 we'll say oh this is too long.

It must be an infinite list or something like that.

Well unfortunately that's not going to fly in an interview setting.

Right.

We need to say very like a 100 percent confidence we need to be able to say yes this is a linked list

that is circular or no it's not and we can't just assume that if the list is really long then it must

be infinite.

That would not be a good approach.

The other thing that you might immediately think of is that well maybe we could iterate through the

linked list and for every node we could add some property to it something like I don't know a dot visited

flag or something like that to every node and then we can iterate through it and if we ever see a node

with that dot visited property that means we've already been there one time.

Again that's a solution that would probably work.

But you know in general with any data structures like this you never want to be adding additional properties

to a node that's really just not a good approach and something that I really recommend you not do in

an interview setting.

So those are two like simple solutions that people come up with.

Let's talk about what might be seen as the real answer.

You know again this is another one of those problems where you've either seen the solution or you haven't.

And luckily you're here so you get to see the solution.

So again we're going to use two separate pointers and we're going to use them to iterate through our

linked list at different speeds.

So we're going to initialize slow to look at the first node and we're going to initialize fast to look

at the next node.

Now here's how we're going to do.

Again we're going to say if the next two nodes after fast are defined then we're going to enter into

a for loop inside the for loop.

We're going to move fast forward by two notes so fast for now be looking at read.

We will then move slow forward by One-Note so slow is now looking at blue after moving these two notes

forward are these two pointers forward we're then going to do a check we're going to say are slow and

fast looking at the same note in our linked list.

So we're going to do a strict triple equals comparison between the two.

We're going to say are these two variables right here pointing at exactly the same object.

If they are well OK that's can be kind of interesting and we'll talk about what that would mean in just

a second.

Otherwise we're going to continue iterating through the list.

So the next step we will check to see if the next two nodes are defined for fast.

They are.

So we're going to move fast forward by two.

So one two and then we're going to move slow forward by one.

Now again we're going to ask ourselves OK are these two looking at the exact same node and again.

No they are not.

So we're going to iterate again.

We're going to move fast forward again by two notes.

So we go to red.

That's the circular part.

And then we move on to orange.

So here we are pointing at orange.

Now let me get a better arrow here so it doesn't look so crazy.

There we go.

So fast is looking at orange.

And then we're going to move red forward by one as well.

So now slow and fast are both pointing at orange.

We checked to see if slow and fast are pointing at the same note.

In this case they are and because they're pointing at the same node that means that we must have a circular

length list.

So in other words we iterate slow forward by one fast by two at every step of the way we checked to

see if they're looking at the same node if they are within that means we must have a circular list.

If they're not then we continue iterating and we repeat this process until either slow and fast are

looking at the same note or the case in which fast is looking at a value value of NULL again because

remember if purple note right here let's look at an example of that.

So if the purple node was correctly pointing off to knoll you know presumably somewhere over here off

to the right.

Well then when fast was looking at orange or whatever the heck it was looking at right here we would

have we would say OK fast r is the next node knoll or the one after that and all.

And in this case yes it is to forward is no.

So that means that there is an end to the linked list.

And so we would return false.

In that case.

So that's pretty much how the solution works.

Again we make the two separate variables and we advanced them both forward one at one time the other

at two at a time and then we compare the value between the two of them at every step along the way.

So this is going to be another problem where there's really not a lot of code to it.

It's just another one where if you know the solution you can solve it pretty briefly otherwise you're

going to be kind of flailing around for a little bit.

So I encourage you to give this a shot.

We'll continue in the next video and we're going to look at a solution together.
------------------------------------------------------------------------------------------------------------------------

101. Loop Solution

In this video we're going to take a look at the solution to this circular problem.

So inside of the index file of the circular directory Here's the circular function.

Let's open this up and get started.

So remember the idea here is that we're going to create two separate variables and they're both going

to start off by looking at the first element in our linked list.

So the head of the linked list so we'll say let's slow is list stop get first and let fast is list get

first as well.

Again you could have just as easily said list head either one.

Totally fine.

Now we're going to set up our while loop.

Remember we want to iterate through our while loop so long as the next value of Fast and the one after

that are not equal to nil.

Just like we did on the previous problem if fast.

Next a fast dot next dot next are ever equal to null.

That means that this linked list does have an end to it.

And so it is not circular.

So we're going to say while fast next and fast starting next dot next are defined then we want to continue

iterating through our loop.

If this situation is never true.

So if we ever reach a point where one of these returns a false value that means we've hit the end of

the while loop and we will exit it.

So if we ever exit it that means that we must absolutely positively not have a circular linked list.

And so we will immediately return false.

Ok so now inside of here we're going to put a little bit of logic down.

So we'll say fast dot net or excuse me we're going to advance.

I was copying down the line again.

We're going to take our slow variable and move it forward by 1.

So we'll say slow equals slow dot next and then we're going to move our fast variable forward by 2.

So say fast equals fast.

Next next.

Now here's the moment of truth we're now going to look at the nodes that slow and fast are pointing

at.

And we're going to compare them together.

We're going to say if they're the same variable then return true.

We must have a circular linked list.

So if slow is the same object in memory like the exact same object as fast then return true.

One thing I want to point out here is the fact that we did not do something like slow dot data so we're

not comparing the data in these in the linked list nodes because the linked list could very easily have

multiple nodes with the same data inside them.

So what we really want to do here is say is it the identical node.

And in javascript we can compare to see if a reference to an object is identical to another one by using

the equal sign right here.

So this literally says is slow.

Looking at a node that is identical and like the exact same instance in memory as fast.

So if they are well then great we must have a circular length list.

Return true.

OK let's save this file and then we're going to run our tests now.

I accidentally saved the file while we were writing that solution.

And unfortunately I realized just a second ago when I hit save I saved it while we still had a case

for that test where it was an infinite loop.

So you can see that I'm stuck at running right here.

So I'm going to close down that test runner and I get it started back up with just circular test.

Yes.

Just watch

and we'll run our tests again.

And great.

So for trespassing.

So that's pretty much the solution.

Again this is just another one of those problems.

I know I've said this so many times now.

But just another one of the problems where you've either seen the solution or you haven't.

So just remember all these lifeless things you think.

Can I use two separate nodes and walk to the linked list to come to a solution.

Because if you can what is usually going to be something that's pretty straightforward.

OK.

So let's pause right here and continue on to our next challenge in the next video.

==========================================================================================================

Раздел 24:Step Back From the Tail

102. From Last Question

In this video we're going to take a look at one last linked list question to really drive home the idea

of this kind of dual pointer's strategy for solving many different linked list questions inside my code

editor.

I'm going to find the from last folder and inside there.

Open up the index to J.S. file and then of course before I forget because I usually do we'll flip on

over to our terminal and start our tests up with just from last test.

J.S. dash dash watch like so and then we should see about two test passing OK let's take a look at our

directions.

So over in our index file Here's the directions at the top so we're going to be given a linked list

and integer n..

Our goal is to return the element that is an space's from the last node in the list.

One requirement is that we should not attempt to use the size method of the linked list.

So this requirement is here because obviously we could probably think of a very direct solution to maybe

get the length of the length of the linked list or the number of nodes inside of it.

We could then subtract and from that and then call get at on that number.

So there'd be a very straightforward and easy solution.

And obviously with interview questions we're usually trying to find some challenge in a task.

So we're not going to take the easy way out here by just using the size method.

And in fact we're going to try to come up with a solution that does not involve directly counting out

the number of elements in the linked list at all.

So I don't really want to worry about the number of elements in the linked list.

We're going to try to think of some other way to get the nth element from the end.

Now the other thing the directions say here is that we should always assume that and will be less than

the length of the list.

So in other words if we have a linked list of 10 items we don't have to worry about being asked for

the element like 20000 from the last element.

In other words don't worry about overflow here and will always be less than the length of the list.

All right let's take a look at a diagram that's going to help to kind of clarify these directions and

also lay out one possible solution to the problem.

So here's our diagram.

We're going to assume that maybe we get called our function within an equal to 3.

So the first thing to do here is to identify which element we should be returning.

And I'm not talking about with code or anything like that.

I'm talking about you and me looking at the diagram.

Which element should we return.

So if any is equal to 3 we want to return the element that is three spaces from the last.

So here is the last element right here.

We're going to return 1 to 3.

So this is the third element from the final in de-list to give you a more clear example of what this

and right here really means.

Imagine if an equals zero.

And then we said I want the element that is zero spaces from the last element in the list.

So zero spaces from the last element would be the last element.

That's great.

If we then incremented that to one.

Obviously that must mean the next element of purple to it would be orange and 3.

Again obviously that would be red.

So Ed equals three means give me red right here.

OK.

So let's talk about how we can solve this by using this slow and fast strategy.

Now this time around.

Slow and fast is a little bit of a misnomer.

In other words one pointer isn't necessarily going to be moving through the linked list faster than

the other but it's still going to be ahead in the list.

I think as soon as we start talking about the solution it'll make a little bit of sense.

So we're going to start off by taking both of our pointers and we're going to set them both equal to

the first node in the list.

As usual Now step two we're going to take an equals three right here.

So and equals three.

We're going to use that and we're going to say that we're going to advance the fast pointer three spaces

through our linked list.

So in one step like this is going to be kind of a two part solution in step one.

We're going to advance fast forward by three so we're going to say one two and three.

So now fast is pointing at orange in that step.

We didn't touch slow at all.

So we're going to initialize slow and then we're not going to touch it during this first phase after

we complete.

Moving Fast forward by three spaces we're then going to enter the second phase of the solution in the

second phase we're going to advance slow and fast together one at a time.

So both slow and fast will be getting advanced by one index.

This is in direct opposition to how we treated fast previously.

Remember we had previously been moving fast forward two elements at a time.

So this time fast will move forward one element at a time.

So we're going to move forward and move forward.

We're then going to ask ourselves is fast pointing at the last element of our linked list.

In this case no it's not.

So are we going to then move both pointers forward one more time.

So we'll move forward one and we will move forward.

One we're going to again ask if fast is looking at the last element and this time.

Yes it is.

This is the last moment and we can tell that because the next property is pointing at No.

As soon as fast is pointing at the last element then that means that slow must be n elements behind

it.

So slow is now pointing at our answer which is red.

So in practice this is not the worst solution in the world.

Just another one of these things were you got to see the solution in kind of diagram format or just

be told what it is.

And as soon as you have a good idea well it gets a little bit easier to code together.

So let's take a break right here.

I would like you to give a shot at the solution and we'll join back up in just a couple of moments and

put the solution together in code so give it a shot and we'll catch you in a minute.
------------------------------------------------------------------------------------------------------------------

103. From Last Solution

In this video we're going to talk about the solution for the from last problem.

So let's get started right away.

Inside of that from last function I'm going to first create two variables and point them both at the

first element in our linked list.

So I'll say let's slow is listed first and let fast is list dot get first.

Next we are going to advance fast through the linked list and we're going to advance a forward and times.

Now for this part you can either put together a for loop or because we've been using a lot of wild loops

I'm going to use a while loop here so you can use either but I mean use a while loop.

So I will say while and is greater than zero fast is going to be fast dot next.

So this step right here is what's going to actually advance the fast pointer through our linked list

and then immediately after doing that we'll subtract one from 10.

So this will move fast and elements forward

sets.

Phase one we've now gotten fast forward in the linked list.

Now it's time to advance both these pointers forward by one at a time until fast eventually hits the

last node or the tail node.

So we'll say while fast dot next.

So while there's still some next node to visit we're going to advance slow forward by 1 so slow is slow

next and fast is fast.

Next.

And then as soon as fast next no longer exists in the words the instant we hit the end of our chain

that means that slow must be an elements behind.

And so we can immediately return slow with no further work required.

Let's save this and see how our tests are doing.

So back at the Turnell to test passing.

All right.

Not that bad.

So just another one of these problems where the solution is pretty succinct and not a lot of code is

required and it's pretty easy to reason through.

But definitely one that's kind of hard to come up on the fly in an interview.

OK.

So that's been three examples now where we've looked at this common solution or this common strategy

for solving linked list questions.

As you can see this slow and faster kind of this dual point or set up is incredibly useful for a wide

variety of different questions.

So any time you get asked a question about length lists you want to immediately start reaching for this

tool in your toolbox.

Let's take a break now and we'll continue the next video and start looking at our next problem.
======================================================================================================================

Раздел 25:Building a Tree

104. Trees Overview

In this section we're going to move on to our next big data structure.

And this next one is something that I'm kind of excited about I guess is the best word for it because

this next topic is something that is actually kind of useful to know about for front and in back in

development.

So we're going to be talking about trees and you will not believe how often trees come up in software

engineering.

So it's something that you'll see very frequently even with business type you know boring applications

you will see uses of trees.

And I personally have worked at several jobs where I had to use a tree to achieve some given task it

was just the best thing to use.

So in this video in the next couple of videos we're going to get a better idea of what trees are we're

going to learn about some of the different parts of a tree like what they're called and whatnot.

And we'll also get a good idea of what we might sometimes use them for.

Now I want to be really clear right now there are several different types of trees out there.

We're going to first start off by looking at the most basic type of tree and then we'll start to specialize

and look at some of the different types of trees that exist.

So first the most basic one and they'll start to talk about some of their more specialized uses.

So anyways let's get to it.

Let's look at a diagram.

So here is a diagram of a tree.

We're going to see many diagrams that look exactly like this right here.

And I just wanted to show you the structure of it one time without any words or extra arrows around

it.

So let's first start off by trying to label some of the different parts of this tree.

Firstly every box that you see on here can be referred to as a node just like when we were working on

Linked Lists previously a little bit ago a individual node.

So like node 20 appear at the top holds some amount of data.

So just like with the linked list and then it will also hold a reference to all of its children.

A child is any node that is directly underneath a given node.

So in this diagram right here we would say that elements 0 40 and negative 15 are all children of node

20 appear at the top.

Likewise all nodes 0 40 and 15 can refer to no 20 as being their parent.

So we often say that we have a parent child relationship between different nodes on a tree.

Now looking at this little no diagram right here you will notice that it looks awfully similar to a

linked list.

So we've got some amount of data that we might want to maintain at some individual node.

Now this data can be absolutely anything in this diagram I reflected as being numbers but it could be

a string an array an object whatever we need it to be.

And there's many different situations where in a practical use of a tree we would stick different values

in there.

Let's move on.

OK.

Like we just said 20 would be the parent of 0 40 and negative 15 and 0 for the negative 15 could refer

to 20 as their parent.

We also refer to the relationship between nodes at a given level as being siblings.

So in this example nodes 12 and negative 2 can be referred to as siblings.

Negative two and one would also be siblings.

Now one in negative to notice how one has a parent of zero and negative 2 has a period of negative 15.

They are at the same level but we wouldn't necessarily refer to them as being siblings because they

do not share a single common parent one has a parent of zero and negative two has a parent of negative

15 now when you start to see questions about tree data structures one of the most common things that

you're going to be asked or probably the most common operation that you're going to have to learn how

to do is tree traversal.

So whenever you hear the word tree traversal we are talking about iterating through all the different

elements within a tree which is essentially what we just spent all that time with around linked lists

like everything about linked lists was really about iterating through every element in it in some fashion.

And so with trees it's very much a similar thing.

We really care about our ability to iterate through all the different elements within a tree.

Now there are two big ways that we're going to learn about how to iterate through a tree.

And I say two big ways.

I'm talking about the order in which elements we iterate through the tree because when you look at this

you know you can't necessarily neatly point out some distinct order in which you would start to list

all these elements out.

If I told you to count through all the elements here or you just read them aloud I think half the people

watching this video would say OK 20 0 14 15 and then maybe the other half would say something like 20

0 12 negative to 41.

In other words there's not really a distinct order of elements here that you and I could necessarily

agree on to visits in the street.

So we start talking about tree traversal.

There are two distinct ways in which we order the elements and iterate through those elements.

So it's very briefly talk about both those ways because we are going to iterate this and we're going

to spend.

I mean we're going to implement this arena spend a lot of time on tree traversal So right now it can

do a quick taste.

The first one is breadth first traversal.

So with breadth first traversal we iterate at each level of the tree from left to right.

So we would start at the very top or the root of the tree we would visit this node.

We would then go down to the next node and we would start at here.

So we'd start at this level and then we would work our way from left to right.

So we would go 0 40 negative 15.

We would then go down to the next level and we would go from left to right again 12 negative to 1 negative

2.

Now notice that even though 12 negative 2 and 1 do not have a common parent with negative 2 that doesn't

matter we're still going from left to right here.

So we go 12 negative to 1 negative 2.

In other words start at the top level go from left to right go to the next level go from left to right.

Again this is breadth first traversal and we will learn how to implement this type of traversal very

shortly.

Now the next one we're going to talk about is much more challenging for me to show you in Diagram format.

This is really something that's easier to kind of like point out and show you the order but it's one

of those things where you have to understand it yourself or come to terms with that on yourself.

So I'll do my best to describe it but we'll see how it goes.

So with depth first traversal we start at the very top of the tree and then we go down the very left

hand side as far as we can go.

And then as soon as we hit the bottom we go back up to the closest parent and then go back down again.

Now it's words that doesn't really make a lot of sense so let's try to look through the diagram here.

So with depth first traversal we would start at 20.

We would then go down to zero and then negative 12.

So we went from the very top to the very bottom.

We expand the depth of the tree so to speak.

After hitting 12 we then go back up to zero and then we go down to negative 2.

So we're still trying to get down to the bottom of the tree as fast as we can.

We then go back up to zero and then down to 1 after we visited all the children of zero.

We then go back up we see that 40 has been visited so we go down to 40.

We then go back up to 20 and then go to negative 15 and then down to negative 2.

So if I were to write out the order of numbers here it would look a little bit something like this on

the right hand side.

But in general you can kind of imagine if I had a marker and I can draw a shape that goes like all the

way down and then back up and down and then back up and down and then go all the way back up and down

back up and down.

So essentially with depth first traversal we try to get to the bottom of the tree as quickly as possible.

OK.

So again that's the two approaches to traversal we are going to implement them both.

So even if my very short kind of terse descriptions right now aren't clear.

That's totally OK because we are going to really really learn in great detail how to implement both

these.

So let's take a quick break right now.

We're going to continue in the next video.

We're going to start writing some code around trees so I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------------

105. Node Implementation

In this video we're going to start working on our own implementation of a tree data structure inside

my code editor of find the tree directory and then open up the index G-S file inside of there.

And then of course before we forget let's also start our tests up.

So a run just three test J us dash dash watch.

Now when we see the test start to run here you'll notice that some number of the tests are being skipped.

So just like before when we were working on linked lists some number of our tests are being purposely

skipped right now so that you can focus on just this first block of tests right here that are all about

testing a node.

So let's now open up our index file again.

So here we are.

And we'll take a quick glance at some of the directions.

So we've got three steps and we're going to start on obviously start step one at the very top.

So our goal is to create a node class or a class that represents an individual node within our tree.

The constructor function of this class should accept a data property and also create a empty array for

storing children.

Remember a node carries references to all the child nodes underneath it and we usually make use of an

array to store all those references.

Also notice that we are supposed to implement these add and remove methods as well and we'll talk about

exactly what they are going to do in just a moment.

But right now let's just focus on the constructor function.

Now for the Node class this first implementation right here we're going to implement this together.

So rather than have you do your own implementation of it we're going to take care of this one together

just because it's a little bit more challenging and it's kind of esoteric or theoretical how this stuff

puts gets put together but as soon as we put together the node you will then go and give a shot at implementing

the tree on your own.

So just the node we're going to take care of this together and then on it for the tree you'll give that

one a shot on your arm.

So let's get start with the node.

We're going to define our constructor function inside of here.

So constructor and if you look carefully at the directions the constructor says that it should accept

an argument that gets assigned to the data property.

So this would be the argument that represents the data that we want to store at this particular node.

And this can be any type of data string and number array object whatever it is.

So we will accept that as an argument called data and then we will assign it to this data like so now

the next thing we have to do is to initialize an empty array for storing children.

And we're going to assign that to the children property.

So this children equals empty Uren.

All right.

So that wasn't that bad.

Let's keep going.

We're going to continue by talking a little bit about this ad method that we're supposed to put together.

Let's take a look at a quick diagram that can help us understand exactly what it's supposed to be.

So here's a diagram of a two node tree.

So just two notes we've got one parent node which is on the left and then one child node which is on

the right.

Notice how the parent has some data of one to three and a child has some data of 7 8 9 and the parent

has a reference to the child node inside of its children array.

So children are right here contains this node and that's how we kind of implement the hierarchy of our

tree structure.

So the goal of this ad function that we are supposed to implement.

So we're supposed to add this add function.

It will be called with some amount of data.

And then inside that function we're supposed to create a new node and add it to the current nodes children

array.

So you can kind of imagine that if we take this node right here and we called the add method on it and

passed in some string of numbers like say four five six or something like that we should then create

a new node and add that node to this ones children array.

So the final structure would look a little something like this

so we would study the parent node inside of its children an array it would have both the New know that

we just created and the old one.

So when we started thinking about how we were supposed to store this node in the children array really

don't overcomplicate it all we're doing here is creating a new node and then pushing it into the children

array.

That's all that's going on here.

There's nothing more fancy than that.

It's just creating no new node and store it within the children array.

So let's give a shot at the implementation of this ad method.

So back inside my index dot js file I'm going to insert an add method that will be called with some

amount of data.

And then inside of here we'll create a new node saying new node.

We're going to create it with this data.

Then we will take that newly created node and push it into the current nodes children array.

So this children push the know that we just created.

Now much like a lot of the stuff that we saw back on linked lists we are creating this temporary variable

here of node which is a 100 percent not necessary so we can condense this down to just one single statement

by saying this dot children push equals new node with data like so.

And that's it that's all that is required for our Add method.

Let's save this and see how our tests are doing.

So back over here it looks like we now have three test passing and we still have one test failing which

is the test around removing children.

So obviously we saw a little bit of work to do there.

However I do want to just come back to our node class.

One second I want to do one quick review because this is you know the first case of implementation here.

So we initialized our data variable we created an empty array of children.

So every single node has this children array.

So every child can have some number of children.

We can tell which nodes are a child of a given node by just looking at the children array.

So looking back at our diagram over here we would have created some new node and then added two children

or two new nodes to this things.

Children array.

All right let's take a pause right here.

We'll continue in the next video where we're going to start to implement the Remove method on a note

as well.

So quick break and I'll see you in just a moment.

-------------------------------------------------------------------------------------------------------------------

106. More on Nodes

In the last section we started on our note implementation.

We put together the constructor and the add method.

We're now going to move on to the Remove method of a note.

So the goal of the Remove method is take a look at the diagram here.

We're going to call remove which is a method on a node.

So maybe we will call the Remove method on this node right here when we call it.

We're supposed to pass in some data.

So given some data we're going to look at each child element of the current node.

So if we call or move on this right here we're going to look at this node and this one as soon as we

find a node.

When these children once with some data equal to the data that was passed in to remove we're going to

remove that node entirely.

So if we call the Remove method on this node right here and pass in some data of maybe four or five

six we should look at this node right here.

We should see that 4 5 6 is equal to the 4 5 6 that we passed into the Remove method.

And so we will delete that node will then look at the next one will see that it has 7 8 9 that is not

equal to 4 5 6.

And so this one can stay around.

So the add and remove methods are pretty straightforward.

Right we're looking at a single individual node here and trying to manipulate its children the add and

remove methods belong to every node.

So we could have just as easily called add onto this node right here or on to this node.

And essentially you get the idea that's how we can build out our tree structure.

So let's give a shot at this remove method.

Now give me a little more tricky because we're going to have to iterate through a list of records and

somehow remove some elements in it.

So I'm going to define my remove method.

It's going to be called with some amount of data and then inside of here you're going to look through

every child of the current node.

And as soon as we find one that has data equal to this data argument right here we need to somehow remove

it from the array.

So this is going to be a classic case of we're using our array filter helper is going to be very useful.

Now if you don't recall how the filter helper works let's do a very quick example.

Over in code error here.

So we get say Konst A-R our equals 1 to 3 and then if we called our our filter and then we can pass

in a function with it.

So maybe something like element like so and then we need to do some type of boolean checking here or

some type of logic for any element that we really turn true for that element will be maintained in the

output.

Otherwise if you return false then the element will be removed from the array.

So if we did something like return elements equal to 1 then you can see that every element that does

not satisfy this check right here is removed from the array.

Now one thing that's really important to note here is that when we call filter on an array it does not

modify the original array.

So if we call a filter and then print out array it still has 1 2 and 3.

When ever we start to cull filter right here this returns a brand new array.

So we would have to do something like a r r equals and at that point we would have to update this to

be let instead.

So we are reassigning the A R R variable here with the newly filtered array and that's exactly what

we're going to do for our children array.

We're going to filter on children.

We're going to look at every node value and then we're going to reassign the children property.

OK.

So over here remove we'll call this dot children dot filter and for every node in that array will do

some type of check.

So say return no data that is not equal to data.

Just two equals.

So notice in this case we used not equal to because with the filter if we return true that means we

want to keep the element if we return false.

That means we want to remove it.

So I want to return true for every element that is not equal to this data argument if it is truthy.

Then there's I mean if it is falsie you know if we have something that does not or does not equal data

right here well that means that we want to remove it.

All right.

So again this does not modify the underlying children array.

So after doing this filter called we will assign the result to destock children like so.

All right let's check out our tests.

It looks like everything is passing now.

And before we move on I want to show you the test file that we were just working on because it's going

to give you a little bit more context on exactly how we can assemble a tree out of this node class right

here.

So instead of my tree folder I can open up the test file.

Then inside of here I'll scroll on down to the node can add children test right here.

So in this example you can see that we are creating a new node with some data.

A We then add on some element b so n now has one child and that child is a node with data b.

We can then make an assertion about the number of children that and has or we can access that child

directly by looking at the children array and getting the first element out of it and then we can say

look at the children that that element has.

So this would be the children of node be right here and this test is just asserting to make sure that

no baby doesn't end up with any children because we didn't actually add any in this case.

All right.

So that's our node implementation.

We're now going to take a quick break and when we come back we're going to start working on the tree

class right here.

The tree class is where things start to get really interesting.

So this is where we're going to actually start to traverse our tree in some fashion and try to make

use of the actual structure.

So let's do a quick break.

We'll come back to the next video and start to tackle the tree class.
-----------------------------------------------------------------------------------------------------------

107. Tree Implementation

We've now finished step one and it's time to move on to Step Two where we're going to try eight create

our tree class.

Now before we start doing any implementation here I want to open up the test file inside of my tree

directory.

We're going to scroll down a little bit and enable the next set of tests in here.

So around like 32 or so we should find the skip statement for the tree.

So I'm going to delete dot skip save the file.

And now back to my terminal I should see an additional three tests that are failing.

OK.

So we definitely got the tests running.

Let's go back to our index start G-S file and read up on the next step here.

So step number two says create the tree class inside the tree constructor we should initialize a root

property to No.

So let's take a look at a diagram to kind of explain what the purpose of the tree class is supposed

to be here.

So here's the tree class.

We're going to assign a root property to it.

This root property is going to contain a reference to the absolute head of our tree or the root of our

tree.

This is essentially doing the same type of setup that we did over with our linked list as well.

So you will recall with our linked lists we have the linked list class that had a red head reference

that pointed out the very first node on our linked list.

So we're doing exactly the same thing here.

We've got the tree class and it's going to point to the root node.

Now also part of the tree class are going to be our two traverse methods which remember are going to

be the methods to iterate through every node on the tree either in a depth first search fashion or a

breath first search fashion.

So we'll first start off with implementing the tree class and it will start worrying about the two traverse

methods that we're going to put together.

So back in my code editor I'm going to scroll on down to the tree class right here.

Now the implementation this is going to be rather straightforward.

So we're going to call We're going to define the constructor function and we're going to initialize

the this root property to be null.

So when we first create a tree it's going to start off with an empty root property and that's it.

Nothing else in here to do.

So an example of using the tree class in the wild might be to do something like say conc node would

be a new node with some amount of data.

Then to create a tree and then we would manually update the root property of the tree like so.

So now the tree thinks that its root node is the node we just created.

All right and I am going to clean up this code right here.

Now one thing that you'll notice about this tree implementation is that we did not add on.

And we're not saying that we're going to add on any type of insert or remove methods to this thing like

we had done previously with the linked list.

The reason for that is that with the linked list the linked list class was really in charge of all the

elements inside the linked list.

Yes the linked list had references to each subsequent element where each node had references to each

subsequent element.

But if we called add or remove on that thing on the linked list it was more or less kind of obvious

how we wanted to operate on the linked list.

But in the case of a tree whenever we start to want to add or remove elements from it we have to very

precisely specify which node we want to be adding or removing elements from.

And so in the context of a tree usually we associate manipulating the tree in some fashion like these.

Add and Remove methods with an actual note because it doesn't quite you know it's kind of hard to envision

how we might call add or move on a tree like if we call add which node are we trying to add this new

node to.

Right.

It doesn't quite make as much sense.

And so that's why we took this different approach this time around with add and remove.

OK.

We got our constructor put together.

Now we're going to start working on our two traverse methods.

The breadth first search and the depth first search these are going to take some amount of time to set

up and explain.

So let's take a pause right now.

We'll come back in the next video and have a lot of time to set up and give you a good description of

exactly how you can put these methods together.

So quick break and I'll see you in just a second.
----------------------------------------------------------------------------------------------------------------


108. Traverse By Breadth

Now we have got some initial implementation of our tree class we're going to move on to implementing

the traverse and the breadth first and traverse in a depth first fashion throughout the tree.

Now notice the directions here.

They say that for both of these traversal methods we should be accepting a function as an argument that

gets called with each element in the tree.

So let's take a look at the diagram that's going to clarify this second step right here and exactly

what's supposed to happen.

So given some tree on the left hand side if we call the Traverse dot the function we should be able

to pass in a function and that inner function right there will then be called with every node within

the tree.

So for example if we ran this function right here on this tree we would take every node and increment

its data property by 10.

So 20 would become 30 0 would become 10 40 would become 50 and so on.

You get the idea.

So make sure that when you start to work on these two traverse functions right here make sure you accept

a function that gets called with every node in the tree.

Now the next thing I want to do is give you a quick reminder on the differences between a breadth first

and a depth first traversal of our tree.

So with a breadth first traversal.

And that's going to be the first one that we're going to work on by the way.

We start off by iterating at each level of our tree.

So we start off at the very top.

We then iterate through all the items directly underneath that and then all the children directly underneath

that from left to right.

Remember that with a depth first traversal.

We start off at the very root and then we try to hit the bottom of the tree as quickly as possible.

So we go from 20 to 0 to 12 then back up to negative to then back down to get to 1 and then down to

40 negative 15 and negative 2.

Now some very early question that you might have might be.

Stephen why do we really care about the order in which we visit nodes in a tree.

What's the difference what.

Who cares which way we go.

Well I want to give you very quickly a practical example of why we would care about the order in which

we visit nodes in a tree.

So let's take a look at 8 organization chart.

So here's an org chart as it's referred to an org chart shows all the different positions at a given

company in order of their hierarchy.

So at the very top of this tree we have the CEO who is the boss of everyone then the CEO might have

three people who report to them.

A CTO was the chief technical officer a Chief Marketing Officer and a chief operating officer.

And then each of those people have other employees who report to them.

So as you can see it's essentially a hierarchy of all the different positions in a company.

Now let's imagine that you work at this company and maybe your boss comes to you and says Hey given

this tree right here I want you to print out all the employees or all the positions in our company in

order of their position.

So you would be expected to print out a list of the CEO and then the CTO then the CMO the CEO.

Oh and then go down to the V.P. of engineering V.P. of infrastructure and so on.

You get the idea.

So that would be an example of a breath first traversal of our tree.

We want to start at the very top with the most important person and then go down through order of just

slightly decreasing importance from there.

Now just so you know this actually is a common interview question.

You might be asked Hey given a tree of positions print out every position in order of importance or

a kind of hierarchy in the organization there's also a very common very common variation on this problem.

But essentially the same thing would be given a hierarchy of military positions.

So maybe at the very top as a general and then underneath them are some colonels and some lieutenants

or captains underneath there.

And given that military ranking or that military hierarchy print out the position of every person in

relative order.

So that's why we might care about a breath first traversal through our tree.

OK so last thing before I cut you loose.

Remember this is a problem that you're going to work on by yourself.

I want to give you one possible way of solving this problem or it's kind of a general algorithm that

you can use.

So let's talk about how we might solve or put together the breadth traversal.

So here's the algorithm algorithm.

This is the general way of doing it.

And of course this is not the only way.

So definitely not the only way it's just one possible way.

I do find this to be the easiest to approach and the easiest to remember however.

So I do recommend you give this one a shot.

So with the breadth first traversal through our tree the general idea is that we create an empty array

and then we immediately take the root node from our tree and we stick that into the array at the very

start.

We then start iterating through this array and we say while the array has some elements in it and that's

a key word.

By the way to keep in mind while while there's still some element in our array take out the very last

element so take it out or simply not the very last moment but the very first element to take out the

very first which in this case is 20 retrieve.

All of this nodes children and stick all those children into the array.

So in that case we would say look at all the children of 20 and that would be these three nodes right

here.

So we would take these three nodes and we would stick them all into the array like so.

We then would call our function that is provided to the Traverse method with this note.

So remember that step right there is talking about this inner function that gets passed as an argument

to the Traverse method.

So at some point in time we do have to call that function.

So that would be the time which we call it.

So we call that function with our no 20 right here.

And then we essentially throw that Nodaway because we've already processed it then we again say look

at our array and if there are still elements inside of it then go through another iteration pull out

the first element take any of its children and stick it in to the end of the array.

So we would then take all of zeros children which are these right here and we would stick them all to

the end of the array.

We then call our past function or that it Rayder function with this note and then we'd throw it away

we'd then say if the phrase still has any elements inside of it pull out the first element take its

children stick it into the end of the array then call the iterator function with that.

And I think you get the idea.

We then take out the next one take this one's children stick them into the end of the array.

So now be way over here.

Call the iterator function with this node and then throw it away.

So you get the idea that's how we would approach this with a breath first search.

Now as I was walking through that algorithm you may have noticed that the order in which we end up processing

these nodes starts at the very top and then goes to the next level we would go through 0 40 negative

15 and then we would go to the next level and go through there.

And so that is a classic breadth first traversal through our tree.

OK.

So that again is just one possible way of doing it.

In general this solution if you condense it down to as few lines of code as possible will be not that

many lines of code.

So if you feel like you have to write dozens and dozens of lines of code to iterate through a tree.

Well you know maybe come back here and take a look at this possible solution by using an array again

because this is a solution that generally doesn't require you know that much code.

Now before I let you loose one last thing I want to do just to kind of set you on the right path down

side of our tree class right here.

I just want to set up the Traverse breadth first function with you.

So we should be setting up traverse breadth first and this will be called with some function and this

function right here is what we want to call every node in the tree with.

OK.

So go ahead and give this a shot.

Again you're doing only the Traverse breadth first algorithm right here.

So give it a shot.

We'll come back together in the next video and we'll start on a solution.

So I'll see you in just a minute.
------------------------------------------------------------------------------------------------------------

109. Solving for Breadth-First Traversal

In this section we're going to look at the solution to the Traverse breadth first algorithm.

So remember we just spoke about the way in which we would approach this.

So we're going to create some array.

We're going to manually stick the first element into that array and then we're going to set up a while

loop to say as long as this array has some element in it take out the first element take all of its

children and stick those all into the array like so.

So let's give this thing a shot over inside my tree class I'll find the Traverse breadth first method

will then take the very top node or the root node out of our tree and we'll stick it into a brand new

array.

So we can do all that inside with just one line of code.

So we'll say Konst or is this root like so.

So that will give us some element with our root node within our array right here and now we can start

to iterate over this array.

So I going to set up a while loop and say while the array has something in it.

So in other words as long as array length is a truth value.

So as soon as our array is empty as soon as it has a length of zero that means there's nothing else

for us to do.

We're all done then inside of here.

We're going to take the first element out of the array.

So we're going to literally remove it from the right.

We're not just getting a reference to it.

We're going to take it out so that the array over time will be decreased in size.

So we'll say conc node will be array.

Or a r r dot shift.

Remember the shift method right here is a base array method that is included on all javascript arrays.

The shift method will take out the first element of the array.

So this does kind of require some knowledge of the shift method right here.

Then we're going to immediately take all of this nodes children and push them into our array.

So we'll say.

Push and I want to take all the children from node right here and add them or something not Q But a

r r r r push.

And we want to add in all the children from the node.

Now the important thing to keep in mind is that we cannot say simply node children because no doubt

children is an array.

So if we push an array into an array we would then have a nested array.

It would look something like you know this right here which is not what we want.

We don't want to have nested arrays.

We want to make sure we take all the nodes out of the children array and then add them into a r.

So there's two possible ways of doing this.

The first possible way would be to write a for loop where we would iterate through no dot children.

So that might look something like 4 let node of node children are seemy we should be some like child

and we could say A-R don't push child.

So that would be one possible solution to take every child out of no doubt children and add them to

the array.

Another possible solution that has very few lines of code would be to use the E.S. 2015 spread operator

so we can say simply dot dot dot no dot children and this has the exact same function as the for loop

that we just saw.

So in other words take every element out of this array right here and push them into array.

So the spread operator specifically right here is going to make sure that we are not attempting to push

in the entire like array structure.

We're saying take all the elements out of there and push them one by one into array so you can use either

the for loop or the dot dot dot operator right here.

Personally I prefer the dot dot dot because obviously it's far less code.

Get that will take all of node's children and add them into our array so that they are waiting to be

processed.

So after our first loop through there let's kind of trace through the first loop just one more time.

So we start off with just note 20 which is the root node.

We then take that thing out we take all of twenty's children which are going to be zero 40 and negative

15 oops too many copy pasted and we push those all in to the array one at a time.

So again remember these should not be in their own little separate array.

They are all individual elements within the array we had created.

So now we can take no twenty right here and pass it in to our iterator function which was provided as

an argument to traverse breadth first.

So a call then with the current node that we're looking at and that's pretty much it.

Believe it or not it's like I said not very many lines of code here for this solution so let's save

this file and see how our tests are doing.

Back over at the terminal I've got six test passing now and if I scroll up a little bit it looks like

the test for breadth first traversal is passing cool.

So that's pretty much it.

Let's take a break right now.

We'll continue in the next section and we'll start talking about our approach for a depth first traversal.

So a quick break we'll tackle that in the next video.
----------------------------------------------------------------------------------------------------------------

110. Depth First Traversal

In the last section we put together our breadth first traversal.

We're now going to move on to talking about how we would approach the depth first traversal.

So first let's do just one quick reminder.

I know we've looked at this diagram several times now.

So we would start off at the very top we would go down the left hand side to the bottom as quickly as

possible and then we would loop back up and down up and down up and down up and down.

Now I've got some really good news for you especially if the solution we just went over made some sense.

So the good news is that to traverse through a tree in a depth first order is remarkably similar.

As far as the code goes to how we approach the breadth first.

So that's why I showed you that particular method by using an array is because to do either the breadth

first or the depth first are nearly identical.

So let's talk about how we would iterate through a tree in a depth first fashion.

All right OK.

So again we've got our array over here and every step of this thing is going to be remarkably similar

except for one little difference.

So let's talk about what that is.

So we're going to start off again by making an array and immediately taking the root node and sticking

that into an array will then enter a wire loop and again so long as this array has some number of elements

inside of it will take out the first element and then we'll take this elements children.

So again that will be zero 40 and negative 15 and we will stick those all into the array.

We'll pass this node to our iterator function and that will essentially throw it away.

Next we take out the next node.

So here's the next node.

Now we take this things children which are 12 negative 2 and 1.

And now here's the difference here is exactly how depth first is different than breadth first remember

with breadth first.

We took these children right here and we added them on to the end of the array.

We just saw two seconds ago.

Remember we called Push right here push adds elements to the end of the array.

But with a depth first search rather than adding these children to the end we are going to add them

to the start.

So they're are going to be added on to the very start of the array like so.

So remember we're still operating on zero right here.

So we'll call our iterator function with 0 and then we throw that note away.

We then take out the first element from our array which in this case would be 12.

And so you can very quickly see the pattern that we have here.

We go from the roots down to the left side down the left side.

We say does this thing have any children.

In this case no it does not.

So we pass it to our iterator function and then throw it away.

We then take out the first note again.

That's negative too.

This has no children.

We pass it to the iterator throw it away.

We take out one.

This has no children.

We pass into the iterator function tore it away 40 take it out patented rater throw it away.

15.

This one does have a child as negative too.

So we will put that into our array at the very start.

In this case it's empty so it doesn't make a big difference but still we put at the very start of the

array.

We pass this to the iterator function or away negative 2 out iterator function.

Throw it away.

So that's pretty much it.

The only difference between breadth first and depth first when we are using this array to hold elements

is whether or not we are adding elements or adding children to the start or the end of the array.

So in general that's something that is pretty darn straightforward and easy to remember even if this

is your first time looking at it maybe it looks a little bit intimidating.

But believe me I am really confident you can remember the difference here.

Remember if you're ever in an interview setting all you really have to do is remember OK I need to make

some type of array and then iterate through children.

And if you draw this out in diagram form I'm really confident that you could pretty quickly come up

with the solution either with the breadth first or depth first solutions.

OK.

So that's how we're going to solve the depth first traversal.

So back inside our index file let's add on the method traverse depth first it's called with some function.

And again I'm going to let you take a shot at this one.

So remember this solution is going to look remarkably similar to what we just did right here.

There's just going to be that one key difference which is exactly where we add the children into our

array.

So go ahead and give it a shot and I'll meet up with you in the next video.
-----------------------------------------------------------------------------------------------------------------

111. Solving for Depth-First Traversal

In this video we're going to look at the solution to the depth first traversal problem.

Remember this is going to be very similar to the breath first.

Like I just mentioned.

So let's just dive right in and bang this thing out.

So the first step is going to be to create an array that contains only the root node.

So this dot right we will then iterate over this array and as long as there is still some element in

it we will continue to iterate.

So perfect to use for that would be a while loop.

So say while array still has some length while it still has some element in it we want to continue to

iterate.

We'll first start off by taking in the first element of the array.

So remember we can take out the first element by calling shift.

We will then take that nodes children and add it on to the front of the array.

Now again you can do this either by a for loop to iterate through each element or you can use those

dot dot dot operator.

So we're going to say array and then to add elements to the front of this thing we call on shift.

So again on shift is a builtin array method.

This is one that you don't see use terribly often but do be aware of it.

Unshipped will take an element and add it onto the front of the array so we'll then say dot dot dot

no dot children.

So take every element in this children array and add them all into array.

Then we need to make sure that we call our argument function with know that we're currently considering.

So we'll say F-in node like so.

And that's pretty much it.

So we can save this file right here.

Let's check our tests out.

And now we have everything passing.

So both the breadth first traversal and the depth first traversal code.

OK.

So again that's breadth first and depth first traversal absolute core elements for every single tree

problem you're going to see.

So no matter what problem you're working on chances are you're going to need to know how to remember

exactly how to traverse through a tree and a breath first or a depth first fashion.

Now many questions you're going to end up getting around trees are going to generally require you to

make a decision on whether you want to iterate through it in a breath first or depth first fashion.

So let's take a break right here.

We're going to continue in the next video.

I'm going to start looking at a couple of different problems that require you to either traverse through

a tree and a breadth first or a depth first fashion.

So let's start to tackle those in the next video.
--------------------------------------------------------------------------------------------------------
========================================================================================================

Раздел 26:Tree Width with Level Width


112. Level Width Declaration


In this video we're going to take a look at a question that's going to require you to really understand

how breadth first traversal works.

So inside my code editor I'm going to find the level with folder and then open up the index file and

then as usual will also flip on over to our terminal will do just level with test not just dash dash

watch.

Now I think we have about three tests or so.

OK.

Three tests Yeah.

All right let's go back over and read the directions here.

The directions say given the root node of a tree we want to return an array where each element is the

width of the tree at a given level.

While these directions aren't the most helpful thing in the world so let's take a look at the code example

here.

So here's the sample tree.

This would be a tree that you and I are given.

Notice how it has that element up top three children underneath that.

And then two of those children have one element as children.

So the example here for this given example we would return an array of 1 3 2.

So let's talk about exactly where this race is coming from.

Notice how the first level of the tree.

So the very first level the root level has exactly one node in it.

So the first element in our answer array would be one because it has a width of one at the first level.

We would then move down to the next level level to level two has three notes one two three.

And so in our answer array we would place three at index 2 and then moving on to level 3.

So here's the third level.

There are two nodes here.

And so the next index in our array would contain two again each of these values are dis are telling

us the width of the tree or the number of nodes at a particular level.

And then the index of each value is telling us the level that we are describing.

So Level 1 Level 2 level 3 corresponds to index 1 index to index three in the array.

So hopefully that makes sense.

All right.

Hopefully that is not the worst thing in the world.

So let's now talk about two particular things.

I first want to throw out one kind of caution note here one thing that you just need to be aware of

and we'll talk about.

One possible way of solving this.

So the first kind of caution note I want to share with you here is notes that the directions say given

the root node of a tree.

So we are working with a node here and in fact if you look at the project directory for level with you'll

see the node J.S. file inside of here.

And so this is an individual node that we're working with.

We're not working with the tree class anymore.

We're not accessing the tree class.

There is no tree class.

All we are working with is the Node class.

And this note as values data and children just like it did previously.

So that's what root is root is a node.

Just keep that in mind.

Now as far as the solution goes the instant in any tree related question the instant you see the word

with Anytime you see with you immediately want you start thinking about a breath first traversal of

our tree.

And that's exactly what we're going to do to solve this question.

So let's kind of think about how we can use breadth first traversal to get the width of each level here.

Now I'm going to give you one possible solution to this problem.

This is just one possible solution.

There could be more.

You know give it your own shot if you want to try to come up with your own solution or if you have a

thought on how to address this I'm going to show you one possible way of doing this.

So for our solution here we're going to maintain two separate arrays and one is going to be called counters

counters will be the array that holds the actual width of our tree at each level.

So counter's right here would be the array that we eventually want to return from our array or it's

me from our function then we're also going to have the array and this rhetoric here is going to serve

the purpose of that kind of buffer or that kind of queue that we're going to use to iterate through

our tree in a breadth first fashion just in the same way as we did a moment ago.

Now when we start to implement this question you might be thinking OK we're going to reuse that exact

same traverse breadth first function that we did previously but that's not quite the case here.

Instead we are going to iterate through our tree in a fashion very similar to breadth first traversal

but we're going to rewrite all that iteration logic and we're going to add a couple of steps here and

there.

So any type of tree problem that you run into in an interview very frequently you're not going to be

using some pre-built traversal function instead you're going to have to write a function that will traverse

through the tree and do some work during that traversal.

And that's exactly what's going to happen here.

So we're going to write some code to traverse through the tree and at some points in time we're going

to do some extra little bit of work.

All right.

So let's give this a shot.

So the first thing we're going to do before we start doing any iteration is to create this starter array

right here just like we did previously.

It's going to contain the root node.

And then we're also going to insert some random token in here some number string.

It could be Noal whatever you want it to be just some kind of pointer or kind of note to ourselves.

And so in my case I'm going to use a string of s.

So this is going to be not a node.

Remember 20 is going to be a node.

This is going to be simply a character they'll call s and this can be absolutely anything could be de-value

know it could be a straight number that's not know it could be a string totally up to you.

You'll see what its purpose in just a second.

So before we start any while loop or anything like that we're going to create our base array and put

the first node.

And this kind of stopper variable in there we will also initialize the counter's variable or give you

the counter's array and give it a starting index or a starting value of zero.

So the first element encounters will be zero.

OK.

Now we're going to enter into our loop and we will come and discuss and walk to a loop and think about

what's going to happen inside of it.

So inside of our loop we're going to take out the value 20.

So the very first node just like we did previously.

We will then take any elements or any children that 20 has and we will add them to our array at the

very end just like we did before.

I'm going to move things over just a little bit myself a little bit of space.

OK after adding 20 or all the children of 20 into our array we're going to increment the first counter

right here by 1.

So that's going to say OK.

The very first level of our tree.

We had one element.

So we were one element wide.

So we've processed 20.

We've done everything we need to do 20.

So we'll throw it out to the sides here.

Next we will pop out the next value from the array.

And this time we're going to get this kind of stopper value and that's why I called it s right here.

It's kind of like a stock or kind of like an end of line character.

So we're going to say that any time we see this end of line value right here that must mean that we've

hit the end of some level in our tree and we need to now start to assume that we are processing values

on the next level.

So any time we see the value s right here we're going to do two things.

We're going to take the value s and put it back at the very end of our array because anytime we see

s as the next value in here that means we are have we have processed an entire level.

We just processed everything on this level right here.

So we have taken all the children from the elements in this row right here and we inserted it into the

array.

And so everything after the last note that is currently in the array must be the formation of the next

level.

So in this case we have zero for the negative 15.

That is everything out of this level right here.

So there's nothing else to be processed.

So we will stick s at the end to signify that is the end of this current level.

So step one just to reiterate as soon as we saw that we had s we would take s and stick it back onto

the end of our array and then the other thing that we're going to do is add on a zero to the end of

our counter's array.

The purpose of adding on the zero right here is again to signify that we are now moving on to the next

level of our counter of our tree.

And so we're going to start attributing all the notes that we see from now on to this new last counter

in here.

So we then re-entered our while loop we take out zero.

We see that it is a regular node we checked to see if zero has any children and it does.

So we're going to take all those children and then stick them onto the end of the array over here after

X

after taking all of its children and inserting them into the array will then go up to our counters array

will find the very last value in there and we will increment it by one and then we'll throw that thing

away.

Next we take out 40 40 has no children.

So we will just increment our current counter or the last value inside of counters by one and we'll

throw the note away.

We take out negative 15.

We add its children to our array.

So we would take this negative two right here and add it onto the array.

We would then increment our counter variable by 1.

So we're now up to 3 and then we throw 15 away.

Now we move on to the next value.

Again we find æsir.

And so anytime we find s We're going to throw s to the end of our array and then we create a new entry

in our counters array and initialize it to zero.

We re-enter the while loop.

We take out the 12 right here.

12 has no children so we increment counters.

We throw 12 away.

We take out negative 2 and has no children.

So it increment counters we take out one.

It has no children.

So we increment counters.

And I think Sirius is going we take out negative 2 and we increment counters.

So it's now to 4.

Now at the very last step of our for loop or smell or Waialua here and this is something it's really

critical we need to consider the very last condition here.

So he said that every single time that we see the value s we take out s and we added into the end of

our array.

However if that is always the rule 100 percent of the time then we would very quickly enter into an

infinite loop because we've said that every single time we take out as we add it to the end of the array.

And remember when we did our breath first traversal algorithm we said as long as there is an element

in our array we should continue iterating through it.

And so that would just very directly lead to an infinite loop.

We keep on taking this out and putting it back and taking it out putting it back in.

So for our breath first algorithm this time around maybe we don't want to be only considering the array's

length right here.

Maybe we want to make sure that as long as there is more than one element in the array we should continue

iterating.

Because think about it any time there's only one element the last element should always be yes.

So there's only one element.

Well that means that we actually don't really have anything else to iterate through.

Now the one thing I'll caution you against is only checking to see if the first element is X here and

then using that to decide whether or not we can should continue iterating.

So if we only check to see if x is the first element and then decide to say OK X is the first element

stop.

Well we would never touch the case in which there is some value after it.

So in short if you see that there's only a length of one in array then chances are only S is in there

and we should probably stop iterating Now as soon as we finish iterating through the array.

We then have our counters array right here which has been maintaining the width of our tree.

And so notice the final arguments are the final values we get in here.

The first level right here has a value of 1.

So that's definitely the width.

Then we have one to three elements at the next level.

We have three right there and we have one two three four elements at the next level.

So we have four there as well.

So that's pretty much it.

That is one possible solution.

One possible way of approaching this problem.

So if you can think of another way of tackling this they certainly go for it.

But this is just a way that I think builds very nicely on the breadth first traversal algorithm that

we were just looking at.

So let's take a break right here.

I would really encourage you to give this problem a shot.

You know try it out on your own.

Make sure that you can really come up with the solution.

And in the next video we'll go over the solution together.

So give it a shot and I'll see you in just a minute.

----------------------------------------------------------------------------------------------------------------------

113. Measuring Level Width

In this video we're going to tackle the solution to the level with problem.

So remember this is going to have a lot of code that looks very similar to a breadth first traversal

but at certain locations we're going to decide to do some extra amount of work.

And this is a very common thing to do in all type of tree problems.

Very frequently you will be implementing a depth first or breadth first traversal but you will add in

some extra code to execute at some given steps along the way.

So let's get to it now.

We went through a very long solution in the last video so we're going to kind of you know go pretty

quickly here rather than reiterate a lot of all the different steps here.

But I might refer back to the diagram once or twice.

So step one and I will show this in the diagram.

Step one will be to create a counter's array that's going to hold the width of our tree at each level

and we're going to initialize the first value in there as 0.

And then we're also going to create this array that's going to hold kind of the buffer or all the working

elements or the queue that we are waiting to process in our tree.

And we're going to make sure that we initialize it with values from the first node of the tree or the

root node of the tree.

And whatever our stopper value here is remember the stopper value here.

It doesn't have to be asked I just totally made that up.

It could also be null.

It can be undefined absolutely whatever it just needs to be some value that we can recognize as symbolizing

that we hit the end of a row.

Now the string S is totally OK because remember 20 Here is a note.

So 20 is actually on the data property of the node.

So even if we had some node that contains the character s we would be totally fine because this is the

characteris.

This is a node that contains data of apps.

All right.

So then let's get to it.

We'll say Konst array will be our root node.

And again I'm going to use the character as here just to stay consistent.

And then we will also initialize that counter's array which is going to hold the widths along our tree.

Now you could have just as easily call this thing with.

Maybe that would have been all bit more clear as to what its purposes but you know the word withs is

really easy to misspell.

I think I kind of like counter's nice and simple.

So now we're going to iterate through our array right here.

But as soon as we write the bounds here member we had previously said as long as there is still an element

in array we want to continue iterating But when we get down to the very very very last cases after we

have processed everything the last element in the array will be s.

And in that case we don't want to take the thing out and then put it right back in.

We want to say if S is the only thing left in here then.

Get me out of here.

I don't want to do anything else.

So we're going to say while a re adult length is greater than 1.

So as long as there's more than one thing in here that means that there must be some more amount of

work for us to do.

Now inside the while loop will pull off the next working element with shift and then there's two considerations

that we want to make here are two different conditions that we want to process.

The first will be the case in which we pull out the value S..

So if we pull out as we want to increment or assume we want we want to add a new index to our counter

or a new element to our counters variable because as means we've hit a new row and then we also want

to add s back to the very end of our array.

So if we know that we're now looking at is the character s if that is our stopper character then take

our counter's variable and push on a new element of zero.

In other words counter's needs to be informed that we are now going to start processing another row

and then the other thing we need to do is array.

Push.

Yes.

So put that thing back at the end of the array.

Now the other case that we need to handle is the case in which node is an actual node like you know

the no 20 right here.

So if we are working with an actual node then we want to make sure that we take all of its children

and stick them into the end of our array.

And because we have visited a legitimate node here we want to make sure that we also increment the last

value in our counter's index so if we are not working with the character s if we are working with the

character Noad or at least to me an actual note here that we want to push all of that things children

no children into our array.

And then we also want to make sure that we increment the last value inside of counters.

So say counters at counters dot length minus 1 plus plus like so so find the very last elements inside

of counters increment it by one.

Remember that the last element Encounter's represents the current level of our tree that we are working

on at this point.

All right.

Just one last step here after the while loop.

So after we have processed everything we need to make sure that we never forget to return the thing

that we actually care about which is the counter's array.

So let's save this and check our tests see how we're doing and we're pasan.

So that's pretty much it.

Again I've said it twice now I'll say it one more time.

When ever we start working on problems related to trees we are usually going to have to end up implementing

either a depth first or breadth first traversal manually.

So very rarely will we be able to really do any type of very generic iterator function here.

I think you probably could have this problem but very frequently we'll have to do some extra stuff.

Stop skimming extra stuff along the way.

So this is just one postes way of solving this but is one that is very easy to remember because we're

building on that very straightforward a rather simplistic way of iterating through our tree in a breath

first fashion.

So let's now continue into the next video and start working on our next problem.
------------------------------------------------------------------------------------------------------------------
==================================================================================================================

Раздел 27:My Best Friend, Binary Search
Trees

114. What's a Binary Search Tree?


In the last couple of videos we've been looking at generic trees and up to this point.

We said that every single node in the tree can have an unlimited number of children underneath it.

So for example the root node in this tree has three children.

And then this node right here of value zero can have three children underneath that we've also said

several times that we can stick absolutely any data that we want to into any node of our tree.

We're now going to start to look at a another type of tree that is going to more closely validate or

place more stringent requirements on not only the number of children that can have but also the value

that a child can have as well.

So let's take a look at this new type of tree.

So it's going to be called a binary search tree with a binary search tree.

Every node can have at most two children.

We usually refer to these two children by their position relative to the parent.

So for example for the root node we have one node to the left and one node to the right.

We would thus called a node on the left the left node and the one over here the right node makes sense

right.

Not that bad.

Now not only do we restrict the number of children that a binary search tree node can have but we also

start to restrict or start to validate the value of every node in the structure.

In this particular case right here you can very quickly notice that every single value to the left of

a parent node seems to have a value less than the parent.

So for example the root node in this case has a value of 10 and then the value to the left has a value

of zero.

The same is true of this node as well.

So to the left we have negative 1 which is less than zero.

And to the right we have a value of 5 which is greater than zero.

And then even down here with say 20 we have 20 in the parent the left node has a value of 17 which is

less than 20 and the right note has a value of ninety nine which is greater than 20.

So we can really come up with a diagram that looks like this for any given node in our structure.

So this represents a node right here rather than referring to the children of a node as a big array

called children because we only have at most two child nodes.

We usually assign them to properties called Left and Right which corresponds to the left node and the

right note of course.

We also place these validation requirements on the values inside of those left and right notes as well.

So the value of this parent node this current note that we're looking at right here must be greater

than the value of the left nodes value.

And then the value for the right node must be less than or some greater than the current node with binary

search trees.

You'll frequently call the value or the data stored within the node.

Other types of terms than what we've been using as well.

So you'll sometimes see this the data stored within the node itself.

You'll frequently see it referred to as a key you might see or referred to as a value but for the purposes

of this course we're going to continue to call it data just to stay consistent.

Now one of the big challenges around binary search trees are one of the questions that you can probably

be expected to most frequently have to answer in an interview setting is exactly how to add new nodes

into an existing binary search tree.

So let's say for example we have the given tree right here and then we call add on the root node all

the way up top and we want to add in a new value of negative 20.

It would then be up to you and me to write some code to figure out exactly how to take this new value

of negative 20 right here and somehow added into an appropriate location within the tree.

So the general algorithm for this is pretty straightforward at least from a verbal perspective like

talking through it.

So to add in the value of negative 20 we would start off at the root node and we would say is negative

20 less than 10 Yes it is.

So we're going to go to the left hand side we then say is negative 20 less than zero again.

Yes it is.

So move to left outside and then we say is negative 20 less than negative 1.

And again yes it is.

So we would allocate negative 20 right here.

Now the last thing that I want to mention about binary search trees is the actual naming of the tree

as well.

So we are going to be talking about binary search trees.

Now specifically the term search in there that places the requirement on the values to the left and

right of the parent node.

We can just as easily and this is a thing in the computer science world as well.

So this is another completely valid data structure.

We could also have simply a binary tree a binary tree is a normal tree that just has two nodes underneath

each parent.

So with a binary tree we no longer have the requirement of making sure that the values on the left are

less than the parent value and that the values on the right are greater than the parent value.

So for example if we replaced five right here with like 9 9 9 we would no longer have a valid binary

search tree but we would have a valid binary tree because every node in here has at most two children.

So that's just one thing to keep in mind.

Now in an interview setting.

One thing that you'll want to do very frugally whenever you think you're being asked about binary search

trees is to really try to get an answer to the question very quickly whether or not you are working

with a binary search tree very commonly.

Your interviewer might expect you to kind of deduce whether or not you're working with a binary search

tree or not and also some types of algorithms will behave slightly differently whether you have a binary

search tree or just a normal binary tree.

One other common interview question that we might see as well is to be asked to validate a binary search

tree.

So maybe you are given a tree that looks like this right here and you have to run some code on it and

validate whether or not it is well-formed in this particular case where every node has two children

and every node to the left of its parent is less than the value of the parent and every node to the

right is greater than the value the parent in this case.

Yes we have a valid binary search tree but if you were given a tree that looks like this where there

was some value out of place you would then be expected to somehow find this mistake right here and say

no it looks like this is not a valid binary search tree.

OK.

So that's a little bit on binary search trees.

Again it all comes really down to understanding how to insert new nodes into a tree.

So we're going to continue the next video where we're going to start working on our own implementation

of a binary search tree and it's really going to focus on our ability to add in new data or new records

to it.

So a quick break and we'll continue that in the next video.
----------------------------------------------------------------------------------------------------------------

115. Binary Search Tree Implementation

In this section we're going to take a look at implementing our own binary search tree.

Now putting together your own binary search tree is not the most challenging thing in the world after

we have just looked at doing a lot of trailer related stuff.

So we're going to get through this pretty quickly.

Let's get started inside of my BSD directory which stands for binary search tree.

I will open up the index file and then of course will also start up our tests with just BSEE test.

J Yes.

Dash dash watch you know we should have just two tests at this point.

One is already passing.

So we have to get the other one to work correctly.

So let's take a look at our index dodgiest file.

So our goal here is to put together this node class.

There's two sets of directions.

So step one is going to be to set up the node constructor.

Notice that the constructor should initialize values data left and right so left and right will be references

to child nodes and data will of course handle some data that is provided as an argument to the constructor.

So let's put this one together right now because it's going to be rather straightforward.

So inside the node class will set up the constructor.

It will take in some amount of data and then we will sign that to this dot data.

We're also going to initialize the left and the right values as well and explicitly set them to nil.

So this dot left is null and this Starbright is null as well.

And so these two lines right here are going to make it really clear to you and me or other future developers

that this particular node does not have any children to look at.

We can start looking at step 2.

So for step 2 we want to implement the insert method on this node class as well.

So we're not going to make a separate binary search tree class or anything like that.

We're going to implement insert on this particular note.

So this should accept an argument data and then it should somehow insert a new node at the appropriate

location in our binary search tree.

So remember when we take in this argument data we have to first create that node.

So we do have to make a node there and then we have to create or zoomie assign that node at the appropriate

location.

Now there is one or two tips I want to give you here.

This is a problem I would like you to kind of give a shot at without a lot of input from me because

we have been looking at a decent amount of tree stuff already but I will tell you that the previous

method that we took made use of where we had been iterating through with a queue of sorts and we use

that while loop when we were doing our depth first and our breadth first searches those while they can

be used in this particular case.

There's actually a different way of doing insertion that is used much more frequently with binary search

trees and that is recursion.

So one way that we could possibly put this together let's say that we are again trying to add in a value

of negative 20 we can call insert on the root node up here and inside that root node we can look at

the value of the current node.

So like this dot data and then we can look at the value of the data that is coming into the function.

If the incoming value is less than the current data value so less than 10 then we should somehow figure

out how to kind of pass this node off to the one or this new value off to the node on the left hand

side.

Then inside of there we should do the same comparison.

And if it's less then we should pass it off to the left hand side and then for this last node right

here we should probably have some type of check to recognize that there is no further left hand node

available here.

And so we should probably create a new node and then assign it to the left property.

So in short I recommend that you try giving a recursion.

Recursion a a shot here and in general I think that there's probably going to be four cases that you're

going to worry about the first case or the first two cases will be the case in which the current node

has a node already signed to the left and the right and the other two cases will be the case in which

you have reached the bottom of the tree and you now need to insert this new value somewhere.

So for those two cases you're going to check to see if the left node or the right note is not defined

and then assign the value at the correct location.

So again I want you to kind of take this one on by yourself a little bit give it a shot and we'll join

back up in the next video and go through a solution.

So I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------

116. BST Insertion

In this video we're going to walk through the solution to the insert method of the Node class.

Well first get started by setting up the method itself.

So I expect to call insert with some amount of data to insert into our tree.

Now we're going to use a recursive solution here.

So we're going to start off at the root node and then if we are not able to insert some new data at

the root node we'll then start to recurse through different nodes in the tree.

So again for example on the value negative 20 right here if we passed that to 10 then we need to decide

one of four things.

There's one of four things that's going to be true.

First if negative 20 is less than 10 and it is we need to see if there is a value already assigned or

node already assigned to the left property here.

If there is then we should take the negative 20 and pass it off to that node.

Otherwise we should create a new node and assign it to the left value.

So let's take care of that check to start back inside of my code editor.

We're going to say if the incoming data value is less then this data and there is already something

assigned out to left property then I don't want to do anything else with this.

I want to delegate the insertion of this new piece of data off to the lefthander code.

Know that already exists to the left hand side on my tree.

So to do so we'll call this doc left.

Remember this is a reference to the node that is on the left hand side.

So it is an instance of the Node class so to recur to recurse through this to make sure that we tell

this left node to take care of inserting this piece of data we'll call insert on that and pass in our

data.

Next we'll handle the other case the case in which this data is greater than data.

But we do not yet have a left node.

So if data is less then this data then we want to create a new node and assign it to the current nodes

left property.

So that will handle the case in which we eventually recurse down to this negative one down here for

negative 1.

We will notice that the left hand side has no value assigned to it.

So that node will fail the left check right here and in that case we'll want to create a new node and

assign it to the dot left so else if data is less than this the data is less than this data then we

will say this.

Left is a new node that's going to contain data like so.

OK.

So that essentially handles the left hand side and we're now going to repeat the exact same thing for

the right hand side of our tree as well.

So on the right hand side let's say that we're working with the value of negative to 120 over here we

want to look at the right hand side of every node.

And along the right hand side we want to see if a node already exists there.

If it does we'll pass this new value off to the insert method.

On that note.

Otherwise we will create a new node and assign it to the right property.

So back inside the insert method we're still going to chain on some else if statements here.

So we're now going to check to see if data is greater than this data and if there's already a right

hand node assigned.

So if there's already something there then we're going to delegate the insertion of this new piece of

data off to that right hand note.

So we'll say this right.

Insert data and then the final case we need to worry about here will say.

Else if data is greater than this dot data.

So this will handle the case in which there is not no node available in the right hand side.

So in this case we'll assign to this start write a new node that contains data like so.

All right let's check our test out and see how we're doing.

So back at the test runner it looks like we are able to insert nodes correctly.

So that's pretty much it for inserting nodes onto a binary search tree.

Again this is probably one of the core questions that you might end up seeing around binary search trees

but there are a couple of other common questions that you might see as well.

So let's continue in the next section and we'll take a look at one or two other common questions you

can expect around binary search trees.

So I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------

117. Do You Contain This?

Now that we have the ability to insert a new record into our binary search tree we're going to move

on to our next method which is going to be the contains method you can think of contains as essentially

being a search through our tree.

So we are going to accept some data argument and then we're going to find a node in the tree with the

same value and we're going to return the entire node if we don't find a node in the tree with the same

value then we're supposed to return nil.

So let's take a look at a diagram that's going to help clarify this question so we can imagine that

we have a tree like this right here and maybe we want to find a node with value 3 so that would be this

node right here.

Just a couple of sections ago we did take a look at some different ways of traversing through a tree.

So you will recall that we looked at a breadth first traversal and a depth first traversal before we

start thinking that we're going to want to use one of those methods to get to the tree.

I want to remind you about a very special property of binary search trees.

Remember we've got the root node at the top and we've said several times that every single value in

our tree to the left should be less than this node value up here and everything to the right will be

greater than this value up here.

So when we start thinking about a depth first or a breadth first traversal those two methods of iteration

kind of go out the window and here's why.

If we're looking for the value 3 right here then we know for a fact that our node should be somewhere

to the left of our root node up here.

So we should never ever attempt to go down the right hand side of our entire tree.

So it's a binary search tree although we can still kind of theoretically traverse through the tree with

breadth first or depth first search.

Usually we're going to end up doing a comparison at every node in the tree and we're going to say is

the node value that we're looking for less than the current one.

Yes it is.

OK go to the left and then we will repeat that question until we eventually line up at the node we're

looking for.

So essentially we're going to say is 10 less than three.

No it's not 10 is greater than 3 so we're going to move to left five is greater than three.

So we're going to move to the left.

0 is less than three.

So move to the right and then at this node right here we'll ask if three is equal to three.

And of course it is.

So we would return this node right here.

So I would like you to give a shot at this question.

Go ahead and give it a shot.

Do the best you can.

I highly recommend you try a recursive approach to this question.

So go ahead and give it a shot.

We'll come back in the next video and we'll walk through the implementation together.
-----------------------------------------------------------------------------------------------------------

118. Solving Contains

In class video we spoke very briefly about the contains method of the note class.

So are we going to recurse through our tree and every single node we're going to decide whether the

value we are looking for is less than or Great less than her or greater than the current note we're

looking at.

And then depending on the answer to that question were either going to recurse down to left or the right

hand side of our tree.

So let's go back over to our node class.

I mean just scrolling down to the bottom and I'm going to add on a contains method and then we're going

to expect this contains method will be called with some data argument.

So the first thing we're going to do for a given node is check to see if the node has data equal to

this data argument.

So I'll say if this data is equal to data then return this and we're specifically returning this year

because remember we want to return the entire node.

Now assuming that the current no does not contain the current value will start to recurse through our

tree.

So we'll say if this time data.

So if the current node has a value less than the data argument that would be a case in which we want

to move to the right hand side of our tree.

But we also need to consider the case that we might not have a node to the right hand side.

So after making this comparison right here we'll also verify that there is a node on the right hand

side of this current node and we can do that by simply saying this doc writes If that is the case.

So if we need to progress down to the right hand side then we can recurse down by saying this dot right

dot contains data and that will note we'll repeat the same exact process.

Now remember with recursion we do have to make sure that we return any recursive function call because

if this function call right here ends up returning a value then the overall function call needs to return

it as well.

So put a return statement right for it.

This will handle recursion down to the right hand side will next do the same exact thing but for the

left hand side.

So we can say Elle's if this data is greater than data that would be the case in which we need to move

to the left and there is a node to the left then return this dot left.

It contains data.

Again we're going to recurse down to the left hand side.

If this function call ends up returning a value we'll make sure that we return it back from the overall

function call.

The last thing we need to think about here is the case in which some data argument does not exist inside

of our tree.

In that case we would miss this statement right here.

We would possibly miss this if statement.

And so if everything fails then at the very end we're going to end up returning NULL.

Let's save this and check our test to see how we're doing.

So flip back over and we've now got those two additional tests for checking contains working great.

Let's continue in the next video and work on our next exercise.

=========================================================================================================

Раздел 28:Validating a Binary Search Tree

119. How to Validate a Binary Search Tree

In this video we're going to take a look at one of the most common interview questions that you can

probably be expected to see asked about binary search trees.

Now unfortunately this is also a pretty challenging problem.

So in this video I'm going to lay out a couple of general pointers.

And then you should give the problem a shot.

And we'll take a look at the solution as usual.

But on this one if you don't come up with any progression pretty quickly.

Don't sweat it.

Just take a look at the solution.

Again this is a rather challenging one but it is a problem that you should definitely know how to do.

All right.

So inside of my project directory or my code editor I'm going to find the validate directory and then

I'll open up the index file inside there and then as usual we'll also flip on over to the terminal and

run just validate but dash dash watch like the how we should see two tests running right now yet to

total.

All right.

So let's look at the directions here and see what's going on.

So we're going to given a single node out of a binary search tree.

Presumably this is going to be the root node.

Our job is to validate the binary search tree.

In other words we want to make sure that every nodes Left-Hand child has a value that is less than the

parent and every righthand child is greater than the parent.

Now at first glance this might look like a rather easy question and it might look very similar to the

insert method that we were just working on.

You might be thinking OK well you know we can just recurse through the binary search tree and we'll

check every value against something else Saturno make sure that every child is on the left hand side

is less than the current nodes value.

Make sure every child on the right hand side is less than the current knows value and that's pretty

much it.

Well unfortunately it's going to be a little bit more challenging than that.

And let me show you why.

So when we were just working on our insert question we saw that we could look at each individual node

and we can do a simple comparison to say Ghaemi we're trying to insert 15 here we'll start off at 10

15 is greater than 10.

So we would move to the right 15 is greater than 12 so we moved to the right.

Fifteen is less than 20.

So move to the left and then 15 is less than 17 so we again move to the left and for the insert question

you know that wasn't the worst thing in the world.

We were able to simply iterate through and only ever consider that current node like just this note

and we didn't have to worry about anything else but remember the point of this question is to validate

a binary search tree.

So we kind of have to assume that there might be something very wrong with the search tree that we are

being passed.

So let me give you an example of how a binary search tree might be very wrong.

Maybe we would take this 15 and maybe for some crazy reason it would end up over here on the right hand

side of negative 1 now this kind of poses a problem.

And here's why.

When we were putting together insert We were only ever looking at this one current note and we said

OK is this value greater than or less than the current note.

In this case you and I could look at this and say OK 15 is greater than negative 1 so hey 15 is on the

right hand side.

It's you know in the correct location.

However it's not actually in the correct location.

When we consider the overall structure of the tree.

So it's on the right hand side of negative one.

You know definitely in the right spot here but it's not in the correct location.

Looking at the whole tree.

Remember one of the properties of binary search trees.

We have the root node up here at the very top and we said many times that the child elements to the

root node anything on the left should be less than anything on the right should be greater then.

But by extension that same exact rule also applies to the left and right children as well.

So notice how children of 10 anything on the right hand side should always be greater than the root

node.

So everything on the right hand side is greater than the root note.

And in theory everything on the left hand side should be less than the root node.

However in this case we have 15 which is greater than 10.

So 15 is violating the rules of a binary search tree not only because of the root node appear at the

top but also because of the zero right here 15 is to the left of the zero.

See if we go we traveled from zero to the left hand side.

That means that it's on the incorrect side relative to both 0 and 10.

So that's the real issue here.

We are picking up this net this 15 value on the completely wrong side of the binary search tree.

And the reason that's kind of a pain is that it means that our simple method that we just use for insert

where we just look at the current node and then say OK is this less than or equal to the current one

doesn't really carry well over to this whole kind of validate thing.

So that's a big challenge.

You know that's why this one is hard.

We have to consider not only the immediate parent node but essentially everything above that as well.

All right let's take a pause right here and then we'll talk about one possible solution to this and

I'll capital is to work on the problem on your own a little bit.

So quick break and then we'll talk about solution in the next video.

----------------------------------------------------------------------------------------------------------------

120. More on Validation

In this section we're going to talk about one possible solution to the validate binary search tree function.

Now this is a rather challenging function.

So in this video I'll give you a quick overview then I'll give you a break to put together a possible

solution and then we'll go over the solution together in the following video.

So let's give this a shot.

We're going to talk through one possible way of doing this by using recursion.

Now as usual this is not the only way of solving this problem but it's one that is relatively easy to

keep in your head and remember.

All right.

So let's talk about it.

We're going to start off at the very top note up here.

We're going to recurse through our entire tree structure.

But as we recurse through we're going to be carrying along some additional function arguments.

So every time that we recurse and we call the validate function on a given note again we're going to

pass along these min and max values and we'll talk about what they are as we start to walk through this

thing.

So we start off at the root note there's really not a lot to do with the root node nothing at all.

Where you can always assume that the root node can be any value it wants to be.

It's only the value the nodes underneath it that determine whether or not we have a valid binary search

tree so we are going to assume that we move from the root node down to the left hand side.

Now remember any node to the left of this root node must be less than the root nodes value.

So as soon as we move to the left that means that the maximum value that you and I can ever expect to

see from this point on is always going to be the parent nodes value of 10.

So we are going to make this additional function argument that we're going to pass along when we recurse

through our tree.

We're going to give it a value of 10 because everything from this point on should always be less than

10 so we then end up at node 0 right here.

We compared the value of this node to our maximum value and we make sure that zero is less than the

max.

And in this case it is.

So we're good to go.

We're then going to progress back down left again.

So we're going to go to the left hand node when we move to the left.

We are now setting a new maximum value because remember everything to the left of this node must be

less than zero.

So now our max as we move down to this node right here will be updated to zero if we ever find a value

that is greater than zero.

That means that something is really wrong.

So we now move down to this node negative one right here.

We look at the children of negative 1.

Now it doesn't have a left hand side.

So we don't need to worry about that.

But we do need to worry about the right hand side.

So we move down to the right hand side when we do so remember any time we move to the right we are saying

that every child of this node right here must be greater than negative 1.

So when we make that move down we're going to update this in value to now the negative one.

So everything to the right hand side must always be greater than negative one.

In other words we now have a minimum of negative one.

So we get to 15 right here.

And when we get to 15 something interesting happens at this point we have very clearly said that any

number at this node right here must be greater than negative 1 but less than zero.

So we compare these two minima the minimum and maximum right here to evaluate 15.

Clearly doesn't match up.

It is greater than both these numbers right here.

So it violates the maximum bound.

And so that means that we do not have a valid binary search tree.

OK so that's the general strategy here.

But obviously the implementation is not the easiest thing in the world.

So when I give you this verbal description maybe being told oh yeah we've got this idea of a minimum

and maximum and we carry it down.

Maybe that makes a lot of sense or a little bit of sense I guess but when you actually think about how

to convert this into code well life gets a little bit more challenging.

So at this point I would like you to give a shot at this problem.

Do the best you can.

You know put some thought into it.

Do the best you can.

If you don't have any success totally fine.

Again this is a rather challenging problem.

So if you don't have any success that's fine.

Continue on to the next video and we'll take a look at the written solution together.

So I'll see you there.
------------------------------------------------------------------------------------------------------------------

121. Solution to Validation

In this section we're going to go over the written solution to the validate function.

Like I said at the end of the last video this is a rather challenging problem especially because it

makes the use of recursion but we'll go through it nice and slow and hopefully make sense of every step

along the way.

So I give myself a little bit of space here and we'll get started.

So as we had said whenever we are calling the validate function we are going to use this function right

here to recurse through every node of our tree.

So this validate function is going to end up being called many times as we attempt to validate the tree.

Now as we recurse through and we call validate over and over and over again we want to somehow pass

some information to each subsequent call along the tree.

So like we had said during the first step going from the root node right here down to the left hand

side we want to make sure that the next node or the zero node right here understands that the maximum

value that it should see should be 10 remember.

So when we go from 10 right here down to zero.

The absolute greatest value that we should expect to see from any node in this set right here should

be 10.

So in order to communicate these minimum and maximum to each recursive or subsequent function call to

validate we're going to add on to additional arguments to the function.

We're going to add on an argument to reflect the minimum from this point on.

And the maximum values from this point on.

So there's minimax are going to be these two variables right here.

Now it's really important to recognize that min and max can potentially change at any given stage during

recursion.

So any time we move to the left we're going to expect to see the max value to update in any time we

move to the right.

We're going to expect to see the minimum value update.

Now the next thing we need to keep in mind as we start thinking about this argument list right here

is what happens the very first time we start to recurse through our structure.

So in other words as soon as we start going from the root node down to the left hand side we have said

several times at this point that we'll update the value of Max.

However we haven't said anything about the value of men.

Any time we move to the left we don't get an update at all.

So I think that maybe we should default the values of min and max and make sure they have some reasonable

defaults so that we can look at those values and understand whether or not we have updated them yet

because in the case that we move from 10 down to left right here it actually is kind of important to

make sure that we understand like you and I we understand that we have not yet set a minimum value for

anything on this side the tree yet when we start looking at zero.

So in order to make sure that's clear we're going to default the value of men to null and Max to nil.

So now we move from here to here.

We will have a max set but men will be set to nil.

And so we will know you and I will know that we should not attempt to apply any type of minimum value

to zero yet.

OK.

So that's step one.

Hopefully that's not too bad.

Now step number two we're going to immediately start to inspect the value at the current node that we

are iterating over and compare its value to the min and max arguments that are being passed in.

Now we've not yet added any logic to actually specify what these values should be.

We're going to do that in a little bit but I think you can agree with me that at some point in time

we need to do the actual comparison of the current notes value to men.

And Max you know that needs we need to do a comparison at some point.

And so that's what we're going to do right now.

So will first handle the case in which we move to the left hand side of a given node and remember whenever

we moved to the left we are really concerned about the max value.

So if Max is not equal to no.

So this would handle the case in which we have not yet set a max bound and no data is greater than Max.

So if we have a max value and for some reason the current node is out of bounds of that value then something

is definitely wrong with our tree and we should probably immediately return false and then we're going

to do the exact same thing with the min value as well.

So we're going to say if men is not know and if the current nodes data value is for some reason less

than the absolute floor that we should expect to see here then we need to also return false like self

Okay.

So at this point with just this code right here we at least have something to call and compare the current

node's value that's good but we do not have anything yet to actually initialize or set not initialize

x.

Excuse me but anything to set the minimum and maximum values and then we also do not yet have anything

to actually recurse through our structure so to actually do the recursion we're going to add on to more

if statements.

So in each of these statements we're going to consider a movement to the left hand side and the movement

to the right hand side.

So let's do going to the left first.

So if there is a node to the left of the current node says Give me a check to see if there's anything

there to see if it's not null.

So if there's something there and in this next part is the part that's going to really kind of head

tough to wrap your head around but just bear with me if calling validate with the node on the left and

some minimum value and then a maximum value of the current nodes data if this right here returns false.

So if this right here returns false we are going to flip it with the exclamation and that will turn

into a true value.

So in other words if there's a node on the left and calling validate with the node on the left with

these new bounds right here returns false then something really went wrong.

And again we need to return false.

All right let's do the counter.

Or the opposite side of this where we handle the right hand side and then we'll be able to kind of talk

about what exactly this is doing right here.

So we're going to also write out the right hand side we'll say if no don't write.

And if the opposite of validate So if calling validate reader results in some false value.

No dot right no dot data.

And Max.

And then inside of here again we'll put return false and then the last thing I want to do and we'll

talk about the entire solution if everything if all these if statements all line up OK then we will

return true instead.

OK.

So let's talk about what's going on here.

So hopefully you're with me on these if statements right here.

Right.

These aren't the worst thing in the world.

And where things start to really go out the window is on these to validate function calls.

So the first thing that I think is pretty obvious is that the validate function calls right here and

right here inside these if statements are what caused the actual recursion to occur.

That part makes sense.

Now let's talk about what's going to happen if we run through this tree right here with those recursive

function calls.

And specifically let's just start off at the very top and walk through this code.

So I think that the best way to do this is maybe something like this.

I don't know let's try it yeah this will work.

OK.

So we're going to call validate with the root node of 10 up here.

So we come into our function with the node we do not yet have a minimum or maximum set because minimum

and maximum are currently set to No.

We skipped both these if statements like I said previously for the top node for the root node.

There's really no validation to really the root node can have any value in really just going to accept

it as being OK.

So for the root node nothing really happens.

It's these two statements where things start to get a little bit interesting.

So we're going to first say OK is there a note to the left hand side of the root node.

And the answer is yes we have no there with the value of zero.

So we then call validate with the node on the left with a minimum of no.

So remember mine is still no right now but it gets a maximum of node data.

So we call validate with the left node a minimum of NULL and a max of 10.

So let's now go down into node zero with those arguments.

So we now have node for zero minhas still no.

But Max is 10.

So at this point Max is no longer null.

So we say is no data greater than max or greater than 10 for node and 0 right here.

No that's not true.

So we do not try to enter the return false case.

Is still equal the all.

So we skipped past that statement and then we come down to these two statements again.

Now just for the sake of kind of getting through this diagram let's assume that this is the entire binary

search tree right here.

And so let's assume that 0 has no left or right properties defined so left right here the left check

fails.

We don't enter that statement.

The right check fails and we don't enter that statement.

And so we were turned true remember that when we return true.

That was for the initial validate function call right here.

So when we were still in node 0 we called validate passing in node 0.

So when we called validate that call resulted in true.

So we flipped true to false and we did not satisfy the if statement for node 0 or no 10 at the top.

We then go down for the original node 10 we're still we're back into that function call it No 10 and

we start looking at the right hand node we again call validate with no dot right.

So we pass in 12.

We now set a minimum of 10 and the maximum is still null.

Remember the max is no because we had only set the max when we progress down the left hand side the

treat when we progressed on the right hand side initially.

We have not yet set a maximum value.

So we go down to the right hand side over here.

So let's go back up to the top.

We now have a node for 12.

Our minimum is 10 and our max is no max is null so we don't care about that.

I mean is not.

No.

So we make sure that 12 is some me the current nodes value is.

Gee whiz Oh man I'm getting myself mixed up here.

OK my mistake.

We set out and we set a minimum of 10 and we checked to see if the current node's value is less than

men.

Yes that is correct.

So we checked to see if 12 is less than 10.

It is not.

So we do not enter the statement.

Yes there we go.

So then we go back down here the no 12 does not have any left or right nodes.

So we go to return true.

Remember that now kicks us back up to the original no 10 we say true an opposite of true because we

are the exclamation that turns into false.

So we do not enter the statement and eventually we finally hit the return TRUE statement at the bottom.

All right.

I know that discussion that descriptive what goes on is kind of nasty but hopefully this makes at least

a little bit of sense.

So the real key here is that every step along the way we update the maximum value if we are trying to

move to the left and we update the minimum value.

If we are trying to move to the right and then we progress through the tree and if any node ever starts

to return a value of false we then enter into this false case right here and then that kind of cascade

is back up and we eventually return false from the entire stack of recursive function calls.

Now lesing I want to do is check out our test.

It looks like they are passing here.

So I think you can agree with me that this is a nasty little bit of recursion and it's one of the things

that is kind of an maybe not kind of but very challenging to come up with on your own.

But as soon as you see the solution it's kind of like yeah ok I guess I can take that.

So hopefully in the interview setting you can at least tried to you know discuss or talk your way through

what is supposed to happen here and then eventually get a solution up on the board.

So this is definitely a tougher one.

But like I said it is probably one of the more challenging problems that you can expect to see especially

around binary search trees which are only occasionally asked in interviews or at least from what I've

seen and what I've collected in a lot of research on com questions.

So we at least have a better idea of what's going on with this solution right here.

So let's take a break and move on to our next question in the next section.
=================================================================================================================

Раздел 29:Back to Javascript - Events

122. What's an Eventing System?

In this video we're going to take a look at a question that is going to test your understanding of basic

javascript concepts.

So inside of my code editor I'll find the events directory.

I'll open up the index file and the example dot H.T. mail file as well.

Now I want to start my tests really quickly.

And I also want to open up this example that HTL file inside of our browser because we're going to use

it for a little bit of a demonstration in my terminal.

I will open up that each HTML file by running open events example dot each symbol.

Notice that if you are in Windows you probably will get an error when you try to run this command right

here which is totally fine.

All you have to do is open up your file explore and open the example.

Each html file in your browser.

That's all I'm trying to do right now.

So here's the HMO file.

I'm going to open up my javascript console and we'll come back to this in just a moment.

First let's look back to the terminal and make sure that our tests are running with just events test

not just.

Dash dash watch and we've got about five test failing right now.

All right.

So we're all done with this setup.

Now it's time to figure out what were actually being asked here.

So if I go back to the index file in my code editor we can read the directions.

Our goal is to create an event team library out of this events class nonevents class should have methods

like on trigger and off.

And then you'll notice that those three methods are already defined for us on the class with a little

bit of documentation around each one.

This event's class right here is meant to serve as a simple eventing library if you have spent any amount

of time with javascript.

I can just about guarantee you that you've probably used a is a implementation of an events library

already.

So have you ever called a method like on and used it to register some type of click handler or a callback

or whatever it might be you have worked with any Vence library.

So our goal in this question is to put together our own custom eventing library before we get too hung

up on the implementation around any of these methods just to make sure that the idea behind this eventing

library is really clear.

I want to give you an example of how this event stuff works by looking at a quick example in our browser.

So I'm going to change on over to the example dot age female file inside of here.

You'll notice that there is a script tag for Jay queery.

We've got an H1 tag a button tag and a script tag the query library has an internal eventing library

set up inside of it and we use that internally venting library to set up different DOM event handlers

like say a click handler.

So again just to make sure that you and I are on the same page with how eventing libraries work I want

to do a little bit of practice here and set up an event handler on our button right here so that whenever

someone clicks on the button we should cancel something out to the terminal We'll then take a look at

one or two other methods just to make sure that you're really clear on exactly how this eventing stuff

works.

So if you're not familiar with Jay query that's totally fine.

We'll walk through it step by step.

We'll first write a selector to get a reference to the button right here.

So we'll say button like so and then you set up a click event handler we can say dot on passing a string

of click and then a callback function to execute inside the callback function call out on a concert

log of Hello.

Let's save this file and then test it out.

Inside the browser.

So back inside the browser I will refresh the page and then click on the button and you'll see if we

get the console log of Hello.

Well all right.

That's not bad.

Clearly if we call on and then pass in the name of some specific event our callback function will be

invoked whenever this event occurs.

Now something that you might not know immediately about.

Jay queery we can actually manually trigger events.

So we are not limited to actually having to click on a button we can manually trigger events at any

time we wish.

So for example I could again select the button and then I could manually trigger an event called Click.

Now will save this file again and then flip over to a browser.

And when I refresh the page you'll notice that the text Hello automatically appears.

So not only can we register events but we can also trigger them ourselves.

And then the final method that I want to show you here is the off method.

So if we select the button again we can do the register or kind of delete all these event handlers that

we've been that that we've been setting up by calling them off and passing in the event name that we

want to disable.

Now we save this and refresh the browser again we get the initial console log of hello from where we

triggered it.

But now if we click the button over here nothing happens because we turn that event off.

Now the very last thing I want to show you is just to make sure it's really really clear.

Let's conc along that initial event handler but in the second one I'm going to change the text to there.

So we're going to cancel log out there like so now we've refreshed in the browser again you'll notice

both of those callback functions are executed.

All right.

So I know I spent a pretty good amount of time talking about this basic J.A.G. stuff but hopefully it

starts to expose some of the patterns that we expect to see around and eventing library.

Namely we should be able to register an event with a given event name.

In this case click we should be able to register multiple different event handlers with one event name.

So in both these cases we registered two different callbacks to the click event name we should be able

to trigger manually all these different event handlers by calling trigger and passing in the event name

they want to trigger.

And then finally we should also be able to disable all the callbacks that are associated with a single

event name by calling off and passing in the given event name.

So essentially we want to set up our own custom event library that behaves in the exact same way as

this does to reiterate we don't really care about sending up any event handlers on a button.

You know there's no click events here.

All we really want to do is have the ability to register some event handler manually trigger it and

then turn them off.

And so that's exactly what we're trying to accomplish with this event's class right here.

I want the ability to register an event trigger it and then turned it off and there's nothing having

to do with click events or anything like that so no need to worry about the dom or buttons or anything.

All right.

So hopefully our goal here is pretty clear.

Let's take a break right now.

We'll come back in the next section.

And I want to lay out a few tips for you on exactly how you can approach this problem.
-------------------------------------------------------------------------------------------------------------

123. A Tip on Events

In the last section we spoke about the events class before you get started on writing out any implementation.

I want to give you one quick tip here.

So notice that whenever we call the on method we pass in any event name and a callback.

And it's really important to remember that we should be able to call the method multiple times with

the same event name and register multiple callbacks to the same event name.

Clearly we're going to need some type of storage mechanism in the class to somehow relate an event name

to a list of different callbacks.

So personally I would really recommend that you consider putting in a constructor method and maybe in

that constructor you initialize some data storage mechanism here.

So it could be an array an object something whatever it needs to be in order to relate some event name

or some multiple list of events to a multiple or two multiple callbacks or a list of callbacks.

Let's take a look at one possible data structure that would probably serve this very nicely.

So I'm going to pull up a diagram really quick.

All right here we go.

So I'm going to suggest that maybe we create a plain javascript object where the keys of the object

are all the different event names that have been registered with our events library.

And then the values for each of these keys could be an array that contains all the different callbacks

that we should call.

Then whenever one of these events are triggered we can iterate through the list of callbacks and trigger

each one in line.

So again this is one possible way of doing this not necessarily the only way but it's a pretty straightforward

way.

I recommend you give a shot.

So back inside of our constructor again we could say that this event is equal to an empty object.

And then you will spend a little bit of time in on trigger and off to figure out how to manipulate and

add events to the events object.

So at this point I'd like you to give a shot at the solution and we'll talk about one possible solution

or go through the actual written implementation in the next video.

So I'll see you in just a minute.

-----------------------------------------------------------------------------------------------------------------------

124. Events Solution

In this section we're going to take a look at the solution to the event's problem.

In the last video I told you that you could use a empty object right here to store all the different

events that get registered with our events library.

Let's first start off by working on the on method.

So in the method will be given an event name as a string and a callback to invoke when ever that event

is triggered.

So I get myself a little bit of space here and then we'll start putting this together.

So I want to take this event name and added as a key to the events object.

Now that's pretty straightforward.

We can reference something like this dog events at event name like so we want to make sure that this

will contain a value of an array and if it contains an array we should take this callback right here

and add the callback to the array.

However we also need to consider the case in which this might be the first event that is added to the

event's object for the particular.

If that's the case then there's probably no array here already and we'll need to create a new array.

So I think that we could use a simple IF statement for that we could say if some value already exists

at this dot events at event name then there must already be an array there that we added and so we can

take this callback and push this callback into that array.

So we'll save this dot events at event name.

Push callback like so.

Otherwise if there's no value at this place in the object then we must need to initialize a brand new

array and add are our callback to it.

So else this datt events that event name is going to be an empty array that contains only callback like

so.

So now either way whether this is the first time we're seeing this event or we've seen this event multiple

times before we will be creating a new array in adding the callback to it.

Look at it that's a good start.

Now this is really the biggest challenge right here is just understanding this part.

The other two steps on here are pretty straightforward.

So let's give those a shot right now.

Well first take care of trigger.

So with Trigger we're given some event name we can look at our events object at this event named key

right here.

And for every callback in that array we can immediately call it.

So let's right first an if statement to see if an array exists at the given key inside of our events

object.

So if this does events at event name exists.

So if there is a value defined there then we'll iterate through that array.

And for that we can use a simple for loop just like we've used many times in this course so far.

So we'll say for let Colback which I'll abbreviate as Seabee of this dot events at event name go ahead

and call the callback.

And that's pretty much it.

So as long as there is some value there ready for us to iterate over iterate over it and execute every

callback in that array.

Now when I save this file right now with the on and trigger methods defined we be able to go back to

our tests running in the terminal and see much of them passing at this point.

So we've got four passing.

There's just one that is still failing and that one test that's remaining is all about the off statement

down here.

So for AWST we want to make sure that we deregister or remove all the existing events inside of our

events object that corresponds with the given event name.

Now there's two simple ways of approaching this.

We could either do something where we maybe set that give an event name equal to a empty array here.

Alternatively we could just attempt to delete that entire property off the object.

And that's the approach that I kind of recommend here.

So rather than saying oh well this Dodd event site event name will be equal to an empty array that still

leaves this empty array here that we're not making any use of whatsoever.

And so another way of approaching this would be to use the delete keyword so we could say delete this

study events at event name like so and that lawyer will remove that entire key and the value that exists

there or that entire array of callbacks.

All right so let's save this and see how we're doing now.

And so we've got all five test passing.

Awesome.

All right so the event's library is a simple little problem but it is the most common problem that I've

probably seen personally in interviews I've been asked this question many times myself and it is a good

question because it does kind of test your knowledge of these basic javascript concepts.

For some libraries that you are probably already making use of right now on a daily basis.

So it is a pretty good question in that regard.

All right so that's good on this question.

Let's take a break and then move on to the next section.
============================================================================================================