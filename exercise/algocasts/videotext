Раздел 1:Get Started Here! 
1. How to Get Help

Hello and welcome.

We're going to get started with the course in just a moment but before we do I want to tell you how

you can get help if you get stuck at any point during this course.

So there's three great ways to reach out to me.

The first is to post on the course discussion boards.

I usually check the Course discussion about once a day on Monday through Friday so I'll do my best to

get back to you as soon as possible if anything comes up.

The next best way to reach out to me is to send me a direct message on you to me.

I'm usually very good about responding to these requests and usually better about that than with the

Course Q&A.

Finally you can reach out to me via Twitter.

And here's my handle listed right here.

Twitter is a great way to reach out to me with short questions but if it's anything technical related

I usually recommend either posting on the course discussion or send me a PM because obviously with Twitter

we've got that character limit that makes technical discussions a little bit more challenging.

All right.

So that's the three ways to get help if you ever get stuck during this course.

Let's pause right now and we'll start talking about our first technical topic in the next video so I'll

see you in just a minute.
----------------------------------------------------------------------------------------------------------

2. The All Important Coding Interview

Before we dive into any technical content we are going to discuss some important items regarding interviews

and white board questions.

I want to put you in a certain frame of mind of how you should approach interviews and interview questions

so let's get to it.

We'll start off by looking at a couple of different diagrams.

First I want to show you a quick timeline of the general job seeking process at any given company getting

an offer from a company is really split into two different phases the contact phase in the interview

phase contact phase is when you try to get in contact with a living breathing human at a company and

this might take the form of talking to a recruiter getting a referral from a friend or submitting your

resume through some online form.

Now this part at the top isn't too bad.

You know right now there's a pretty good amount of demand for software engineers.

And so after some amount of time of sending out your resume talking to recruiters.

Eventually you will get through this phase.

What comes after the contact phase is much more interesting.

So after you make this initial contact you move on to the interview phase the interview phase consists

of phone screens take home coding assignments and on site interviews.

This is the real make or break part the part that decides whether or not you're going to get an offer

with these two phases in mind.

I want to now ask you a question.

So during each of these two phases What is the average company looking to evaluate in you.

Well I've got a couple of thoughts about that.

I think that the average company is evaluating a couple different qualities in you during each of these

two phases.

So during the initial contact phase the company kind of wants to get a general idea of who you are.

So what work experience do you have.

Do you have any interesting side projects.

Are you friends with many people at the company during the second phase.

However during the interview phase there are some distinctly different qualities that a company really

wants to evaluate once you meet and interview in person they are going to try to decide whether or not

you're a good culture fit like whether your personality is going to mesh well with other people at that

company.

But much much more importantly than that it's during this interview phase that a company is going to

attempt to evaluate whether or not you are an effective coder or a good engineer.

So what's the point of this.

I'm sure you know you've already gotten a good idea of how companies hire people.

But the point here is I want to really make sure that it's clear that of all these different qualities

out of everything that a company is doing to evaluate you there is exactly one make or break quality

that you can improve.

Right now today.

And that is your ability to code your ability to answer a coding interview questions is the single most

important quality that you are going to be judged on during the interview process.

I personally have seen many people apply and get accepted to companies like Google Facebook Amazon and

many of them had little work experience no side projects no social contacts.

They might not be the nicest person in the world.

Maybe they didn't have the best culture fit but they could code and they could answer whiteboard questions

effectively.

And that is going to override every other quality during the interview process.

So the big takeaway here is that just by being here in this course watching this video right now you're

making a great move because you are are on the path to improving one of the most critical and easily

improvable areas for getting a great job.

And I hope that doesnt sound like too much of a marketing statement on my part but really I want you

to understand that there is nothing that gives you bang for your buck in the job seeking world.

Like being good at coding interviews.

So with all of this in mind let's continue in the next section and start to break down exactly how you

can get better at coding questions.
---------------------------------------------------------------------------------------------------------------------------

3. Getting Better at Coding
Questions

In an interview setting interviewers have three big tools to evaluate your coding ability.

First they can assign you a take home project which is something that you would usually do on your own

time and then submit to the company looking to hire you.

Second your interviewer can sit down next to you at a computer and the two of you can do a little bit

of pair programming.

Usually this peer programming focuses on a more practical use of skills rather than algorithms or theoretical

questions.

Third and what you will see most frequently at large companies like Google or Facebook is whiteboarding.

So the term whiteboarding is a reference to standing at a whiteboard or a chalkboard and writing out

some code to satisfy your interviewers questions whiteboard interviews have traditionally been seen

as kind of confrontational and certainly very nerve wracking as well.

Nonetheless it really is the tool of preference for many large companies.

And like we just mentioned the last video whiteboarding really is the easiest area for you to get better

at.

So the natural question to ask here is how do we get better at whiteboard questions.

If this is how we get hired if doing well Whiteford questions is how we get hired at a job.

How do we get better at doing them.

And the answer there might be a little bit disappointing is of course practice practice practice nonstop

practice.

There's no magic pill that you can take.

There's no secret.

One time exercise that is going to turn you into a pro at Whiteford interview questions all you can

do is practice.

Let me tell you a little bit about why practice is so important for interview questions by showing you

two extremely common interview questions.

So we're going to look at two very calm questions and we're going to kind of break them down a little

bit.

And I think you're going to find this a little bit interesting.

So the first one that we're going to look at is the classic fizz buzz problem.

If you've never seen it before this buzz is an extremely common interview question that requires you

to print out all the numbers between 1 and 100.

If a printed number is divisible by three divisible by three excuse me you should print out the string

fizz and if the number is divisible by 5 then you should print out the string buzz and then there's

one other case on here as well not super important.

This is considered to be one of the easiest interview questions around but people still fail this question

all the time in interviews.

So why is that.

Is it that lots of people are just really bad at programming.

Well in my opinion the reason that so many people fail at a supposedly easy question is that it's not

really an easy question at all.

My personal belief is that this is a moderately difficult one that has a little trick to it but once

you see that trick once you know what that trick is the problem becomes amazingly simple and amazingly

straightforward.

So I don't think that this is an inherently easy question.

It's that as soon as you know the trick it becomes incredibly simple.

And that is repeated with so many interview questions so many programming candidates who get interviewed

are not sitting there in a boat like a programming genius an interview because they get every question

right.

It's because they have done enough questions on their own time.

They've done enough practice to know the little trick that is required to solve each question.

The more problems you practice and the more problems you solve the better off you will be at knowing

these little tricks as they come up.

So see one other great example of this.

This kind of phenomenon.

So here is another amazingly common interview question.

This is a question that I've been asked myself so many times in interviews and I have seen it asked

at companies I've worked at as well.

One company I worked on particular asked every single candidate this question.

So I've seen this question asked many times and I've seen it answered many times as well.

So this is a question about the Fibonacci series and this question.

You're supposed to print out a specific number from the Fibonacci series.

Now it's not really important to understand what the Fibonacci series is just yet.

I kind of want to have just or commentary about what's going on around this question.

In most interviews an interviewer will ask the candidate to solve this problem with a recursive solution.

So here's the recursive solution down here.

Now I'm going to level with you.

And be really honest here.

I have seen amazingly few candidates over the years who have sat down and come up with this recursive

solution on the fly.

Like in other words nobody is really being asked this question.

For the first time in an interview and giving this as a solution I'm 100 percent convinced of that.

Instead every last one of these candidates who ever get this question right has always practiced this

exact question in the past.

They memorize this very short solution right here and then.

Hey soon as you get answer ask this question.

Great here's this like three line solution right here.

So the more you practice these problems the more likely it is that you'll be asked a problem that you

have already seen.

Of course if you have been in their interview and came up with a solution on the fly you know if that

has happened to you in the past that's great.

You know I'm not saying that it's impossible and doesn't happen for people to figure this out on the

fly.

I'm just saying that the bulk of my experience.

Most people who solve this question have seen it before and most people who have not seen it usually

fail the question which is certainly not good.

OK so hopefully at this point it's clear why solving problems nonstop really is the best way to get

better at technical interviews.

So let's continue with the next video where we're going to start to discuss how problems in this course

are laid out.

So quick break and I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------
=============================================================================================================



Раздел 2:A Touch of Setup

5. Environment Setup

Now that we have a good sense of why it is so important to practice coding problems will well now to

continue by doing a little bit of environment setup in this section we'll be cleaning a get help repot

that contains all the exercises and problems that we'll be working on throughout this course.

So let's get to it.

I mean the first change on over to my browser and I'm going to navigate to get hub dot com slash Stephen

Greider slash algo casse and I'll paste the link right here just to make sure it's nice and legible

for you.

I also put this link in the last lecture as text so you can always go back there and copy the link as

well.

OK so once I'm at this page I need to find the green button on the right hand side that says clone or

download a click it and then you can either download this entire repo as a zip file or clone it with

get.

In my case I can go ahead and clone it with get by copying the link right here.

So I copy the link.

I'm going to change back over to my terminal and then I will clone the repository by writing get clone

and then that link next will change into that directory that was just created.

And that's pretty much it.

Now there is one little dependency that we have to install here.

We're going to first install the dependency in this section and then we'll talk about what it does in

the next video.

So still at my command line I'm going to run the command sudo NPM install Dashti just now really important

if you're on Windows you don't need sudo right here.

So if you are on Windows go back over to the very left hand side and you'll delete that sudo only if

you're on Windows.

Otherwise go ahead and run the command.

You'll be prompted for your system password.

You can go ahead and give it and then run the command.

All right so this is going to take a couple of minutes to install.

So let's wait for it to finish and continue in the next section.
---------------------------------------------------------------------------------------------------------------


6. Repo Test Setup
In the last section we installed a get repo that contain all the exercises and programs they'll be working

through inside this course and then we install the just command line tool with NPM.

Let's now take a look at the contents of this repo.

And we'll also discuss what that geste program is for.

So I'm going to start up my code editor inside this directory that we just cloned and we'll take a look

at some of the files and folders inside of it.

OK.

So inside of here you'll notice two folders right here.

You might notice one or two more folders.

After I have gone through income and recension records all the content of this course.

But what you and I are really concerned with right now is this exercises directory.

So we open up the exercises folder you'll see a number of some folders inside of that.

Now for you you're probably going to see many more folders inside of here for me as I'm recording this

course.

I decided to just keep a minimal number of folders inside of you at any given one time.

So it's easier for you to understand where I'm working inside of the directory structure inside of each

of these folders you'll find both the index start ups and a test dot js file.

So the idea behind these different folders is that each one represents a specific problem that we're

going to work on.

All the code that you and I are going to write to solve the problem will go into the index not just

file of each respective problem and then some code to test our solution has been already written for

us inside of the test.

JS file.

So if I could open up test not genius you'll see some number of tests inside of here.

So that just command line tool that we just installed is a test runner that we're going to use to evaluate

all these different tests for each of these different exercises.

Let's now flip back over to the command line tool and just kind of see how it works.

So back in my command line I'm going to change into the exercises directory and then I'm going to run

the just command.

So I'll simply run just like so now when we run just it's going to automatically attempt to execute

every last test inside of this repository for us.

So we'll see something that says like hey here's some number of tests that might have passed in some

number that might have failed.

Now we are not going to want to really run all the tests for all the exercises every single time.

Instead we're going to usually be running one set of tests.

In other words just a set of tests for one specific problem that we're working on in order to run one

batch of tests.

We're going to modify how we run that just command slightly.

So here's what we're going to do.

Let's imagine that we want to run the tests for this fib exercise right here to run just the test for

this fib exercise.

We'll run the command just fed slash test drive J us and then slash slash or seen dash dash watch.

Like so.

So in other words you will write out the test file for just the exercise that we're trying to run.

Now in general throughout the course as we are working on each and every different one of these exercises

I will be showing you how to write the command.

So you don't need to necessarily memorize this command right here or be sure to show you over time how

we are going to run it again and again and again just to give you a good reminder.

So we now run this command.

You'll see that we are running only with tests related to that fib problem.

So I see now just six Tests being passed ran six Tests executed because there are six tests inside of

this test file for the fifth exercise.

Now just some other quick things to understand.

Whenever you change any of the code inside the project structure these tests will automatically rerun

for us.

But if for some reason you want to rerun them manually you can press the Enter key on your keyboard

and that will rerun all these tests once you're done running all the tests for a particular exercise.

And you're ready to run to move on to the next one.

You can always Press Control C on your keyboard and that will stop the test runner.

So if I press control C that will stop the test runner like so and then of course I can always start

them back up and then exit out again by pressing Control-C again.

OK.

So that's pretty much it.

This is our testing setup we're going to be using it throughout the course for each of the different

problems so we end up working on.

So the good thing about this test setup is that if you ever decide you want to deviate from the course

and just solve all these problems on your own or maybe come back later on and practice the problems

on your own then hey fantastic you've got a bunch of tests here to make sure you're doing the correct

work.

So now that we have our development setup all put together let's continue on the next section and get

started on our first practice problem.
--------------------------------------------------------------------------------------------------------
========================================================================================================




Раздел 3:String Reversal

8. First Question! Reverse String.
Now that we've set up our repo and we have a better idea how to run tests.

Let's get started with our first problem.

So the first question that we're going to tackle here is the one marked as reverse string is going to

open up that folder and then open up the index G-S file inside of it.

Now before we talk about this question too much I want to start up my tests for this particular question.

So back in my terminal I'm going to make sure that I'm inside of my exercises directory if I list out

all my files and folders inside of here I should see the reverse string problem listed.

Now to start my tests or run just reverse string slash test G-S then dash dash watch like so so a run

this and that will start up our tests and the first time they run I should see two test failing and

at least one test is passing which is great.

So you're going to work out this question and then as you start to solve it or whenever you think you

have a solution come back over to your terminal and make sure that all three tests are passing.

This is a nice kind of mild.

First question to start off with.

So hopefully we'll get kind of a knack around the pattern of writing a little code and then coming back

and checking out the tests.

All right now let's check out the question itself.

So inside of my reverse string index dot G-S file you'll see the directions list at the top.

Now essentially all we really want to do here is take a string that is provided as an argument as TR

short for string.

Reverse it and then return it from the function.

And the last part is really important.

Don't forget to return the string that gets reversed.

Very important.

So inside of this function body right here you're going to write in your solution.

Save the file and then whenever the file is saved you should see your tests rerun and repeat until you

see these things pass.

Now in this particular case I'm going to very purposely not give you a lot of direction on this question.

I want you to kind of dive in head first into this particular question but on future questions we will

talk a lot about pre-amble and different possibilities to solve it and all that kind of good stuff.

So just on the first one I want to just dive in headfirst.

Give it your best try.

One thing keep in mind is that if you ever start to get frustrated on the question please please please

just stop working on it and watch the solution especially when you're first getting started with practicing

interview questions.

It's really really important to make sure that you don't end up getting to know a little bit frustrated

when you're first getting started.

It's all about just seeing a lot of questions very quickly so you can start to get a handle on the types

of questions that you'll be asked.

So again if you are spending a lot of time on this question or any other one we work on just take a

break watch this solution and then give it another shot and I'll remind you this several times as we

go through the course.

OK.

So I'll leave this up to you.

Or catching the next section and we'll go and walk over the solution.
------------------------------------------------------------------------------------------------------------------

9. String Reversal, Solution #1
OK hopefully you had some success with this problem in this section we're going to walk through one

possible solution.

Now the first solution that we're gonna start off with is by far the easiest one.

However it's also not necessarily the most obvious one.

So this one requires a little bit of trivia knowledge of javascript in general.

So rather than going and writing out the solution right away I want to show you a little bit of documentation.

And as soon as you see this documentation you might have an auto type moment.

So let's take a look.

So inside my browser I'm going to open up the documentation for a re prototype reverse reverse is a

built in function that is included with all versions of javascript.

I should say most recent versions the reverse function right here will reverse all of the elements within

a given array and you can very easily see with the documentation right here.

We have one two three.

The reverse method is called on it and then a contains three to one instead.

Now this is very important to note here.

A method that belongs to all arrays.

But we were passed a string.

So in order to use this very easy very simple straightforward solution right here we need to make sure

that we are working with an array not a string.

Fortunately we can use a little method to convert our string into an array called the reverse method

on it and then turn it back into a string.

So if we put this into a kind of flow diagram Here's what we get.

So we're going to take in that SDR short for string arguments we're going to turn it into an array we'll

call reverse on it will join that array back into a string and then return the result.

So let's give this a shot.

Back inside my code editor I'm going to take this as TR short for String argument and we'll turn it

into an array.

So I'll say Konst A R R I like to abbreviate array as simply a r r.

By the way I will call string dot split and pass in an empty string.

So when we call split and pass in an empty string it takes the provided string and turns it into an

array with every element in that array consisting of a different character from the string.

So right here with a r r we're now working with a ray of characters we can call a r r dot reverse that

will flip or reverse all the elements within the array.

And then finally we can join it all back together again by calling a r r join in passing in an empty

string as well.

So this will join all those elements back into a string and then finally we'll make sure we return the

result.

So I can put my return keyword in here.

So let's save this.

Check our test and see how we're doing so save the file.

I'll check on my terminal.

It looks like all of our tests are successfully passing.

Cool.

So like I said this was a solution that kind of relied on a little bit of trivia.

Now it's entirely possible that you took a different solution.

So we're still going to cover two other possible solutions one that uses a for loop and another that

uses an array helper.

I do really recommend you check out these other two solutions that we're going to take a look at because

both them you might be required to give one of these other solutions your interviewer might say hey

don't cheat and use that reverse helper.

So we will look at two other solutions that take care of this process manually before we go however

I want to point out that we can do a little bit of code cleanup to make this function a little bit more

concise than it is.

Notice how right now we split our string into an array and assign it to this variable.

We then call reverse on it and then we join it back together.

So in fact we don't really need to make use of this temporary variable right here.

We could simply call reverse on the result of this expression and then call join on the results of that.

So let's look at that alternate solution that's just going to kind of clean up our code here a little

bit.

So I'm going to delete everything and I will return as TR dot split.

So that's going to give us our character or our array of characters we'll call reverse on that which

will reverse all the elements within that array and then we will join it all back together like so now

when I save the file.

I have a built in little code formatter so you'll notice that my formatter automatically splits it out

to a couple of lines here but it's all 100 percent equivalent to the code we just were looking at a

second ago.

So I'll save this file and if I go back over to my terminal again it looks like the tests are still

passing great.

So this is one possible solution.

Let's pause right now.

Continue in the next section and look at another possible solution.
-----------------------------------------------------------------------------------------------------------

10. String Reversal, Solution #2
In the last section we put together one very straightforward solution for reversing a string.

Now it's entirely possible that your interviewer might say hey don't use the reverse helper because

obviously if you know this thing exists it really makes the question quite easy and quite straightforward.

So in this section we're going to look at an alternative solution that's a little bit more manual work.

OK.

Now just to keep a record of all of my solutions as we go through I am going to copy this down to the

bottom of the file and comment out our first solution just to keep a record of all the different solutions

we come up with.

And I'm going to delete the contents of the reverse function.

OK.

So let's talk about the second solution.

The second solution is going to make use of a for loop.

So we're going to create an empty string and we'll call that thing maybe reversed.

I think that's a reasonable name for it then we're going to iterate through the string that was provided

and for each character in that string will take that character and add it to the start of the reversed

string.

After we iterate through the entire string we'll then return the variable reversed.

So essentially we're going to make an empty string.

We're going to take each character out of the original string and stick it into the new one.

One at a time.

And because we are adding the new characters because we're adding each character to the start of reversed

the reversed variable contain the reversed string.

So let's see what this solution looks like.

All right.

So back at our code editor We'll start off by declaring a temporary variable that we'll call reversed

and also sign it an empty string.

So this is the string that we're going to kind of assemble over time as we iterate through the string

variable right here.

OK so now we need a for loop.

One thing I want to mention about for loops in general and I'm going to tell you this many times throughout

this course wherever possible I really recommend you avoid writing for loops in the kind of very classic

syntax.

In other words the for loop syntax that looks like var i equal to zero.

I less than string length.

Plus plus.

So I really recommend you try to avoid for loops like this right here.

And the reason for that is that there are so many tiny little spots inside of here that you can very

easily make a mistake or make a typo for example maybe you accidentally flip the less then sign right

here.

Maybe you actually accidentally flip it the other way maybe rather than looking at string length maybe

you accidentally looked at reversed length maybe instead of semi colons you put in commas instead which

is honest to God something that I accidentally did on an interview one time.

So whenever you use you use this long form for loop you're just introducing many different locations

where you can accidentally make a little typo.

So for us throughout this course where ever possible we're not going to use this classic for loop.

Instead we're going to use a new syntax for four loops that was introduced with as 2015 called the four

of syntax.

So let's write the code for it and see what it looks like.

I'll say for lead character of S.

TR So that's the string that we got passed in as an argument.

Then in the body of the loop we'll say reversed equals character plus reversed.

Then at the bottom we will return reversed.

OK so let's talk about what's going on here.

So again this is a new syntax for for loops we say for a variable declaration.

So I'm creating a temporary variable that is redeclare.

Every single time through this loop of character than we say of.

And then the iterable object that we want to iterate through.

So in this case we are iterating through all of the characters of the string variable right here.

So we're going to iterate through each character of string one by one and set each character equal to

this temporary variable character.

We then take that character added on to the start of the string reversed and then after the entire four

loop we return the string reversed.

So again in general I really recommend you make use of this new and improved loops syntax rather than

attempting to write out the full for loop by herself.

Now there are several questions out there and I should say actually many questions out there where you

can use this syntax because maybe rather than iterating through every single element inside of a string

or an array or something maybe you want to iterate through every third element or iterate through every

fifth and there are Interview questions that require that type of logic.

And so if you are confronted with needing to loop through every so many elements within the array Well

then you do have to go back to using a for loop or even a while loop for that matter.

However as much as possible I do encourage you to try this new and improved syntax.

OK let's save this and see how we're doing a flip back over to our terminal and it looks like we're

still passing here as well.

So this has been a second solution.

This one's a little bit more manual and something that I would probably expect to be asked in a interview

question.

You know I would really kind of expect that any competent interviewer might say oh yeah don't use reverse.

That's just too easy.

All right.

So this one is a little bit more complicated.

Let's continue in the next section and we're going to look at one more possible solution.

So quick break and I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------

11. String Reversal, Solution #3
We have now put together two possible solutions to the string reversal problem.

Now I do want to look at one third solution you might be sitting there thinking Stephen do we really

need a third solution.

You know aren't the two we have good enough.

Well to be honest throughout this course I want to usually show you multiple solutions to the same problem

because inevitably first some people one type of solution is going to stick.

And another one will not.

In addition as we look at these solutions I'm going to usually be showing you some of the more complicated

ways of solving a problem.

Now sometimes you do want to use a slightly more complicated way just because it might show your interviewer

that you kind of know what you're talking about.

So this last solution is going to use a very complicated little array helper but it's also going to

make it very evident to your interviewer that you really know how to reverse a string.

So let's give this last solution a shot.

I'm going to start off by copying the second solution down to the bottom the file and commenting it

out and then I'll delete the function body for our solution right here.

So here's what we're going to do.

We're going to take our string.

We're going to turn it into an array by calling the Split function on it.

And then we're going to use the reduce helper.

So the reduce helper is a method helper that was included with.

Yes 5.1.

We'll take a look at how it's used in just a second.

So first turn this thing into an array by calling string split with an empty string like so and it will

set up the reduce helper function.

Reduce is used to take all the different values with an array and condense them all down to one singular

value which is essentially exactly what we're trying to do here.

We want to take all the values within this array that we just created and condensed them down to a single

string value.

Reduce takes two separate arguments.

The first one is going to be an arrow function that'll set up like so and then the second argument is

going to be a starting initial value for our function which I'm going to pass in an empty string like

so.

Now whenever reduce runs it's going to take this starting argument.

It's going to pass it into this arrow function has the first argument and then whatever gets returned

from that inner function will be then used as the starting argument for every successive run of the

function.

In total the function runs one time for every element within the array right here.

So in other words we can really picture that this first value for the first argument that has passed

introduce is are reversed string.

So I will receive it as an argument named reversed.

Then the second argument is the element or the character that we are currently operating on out of our

array.

And I'll receive that as an argument called character then the logic inside this function ends up being

the exact same thing that it was with our FOR loop solution.

So we're going to take our character that we're operating on right now.

We will add it to the total reverse string or the string that represents the reversed string that we

were past and then return the result.

So I will say return character plus reversed like so.

So this reduced call will yield a string that has the reversed form of the string that was passed down.

So the last thing we have to do is make sure that we return the results.

It's going to get my return key word in there like so.

All right.

So let's look at our tests.

Looks like everything is still passing.

Fantastic.

So this is definitely a solution that would work.

The last thing that would probably do here is to kind of simplify some of the syntax a little bit by

using some knowledge of iOS 6.

Again this is little improvement that is not necessary but something that might kind of impress your

interviewer just to show that yes you are familiar with.

Yes 2015 and understand the differences in syntax.

So one way that I could condense this function call write your down a little bit is to remove both the

return statement and the curly braces.

So I would remove the return statement.

I would remove the curly braces there's the other curly brace and then I also don't need the semi colon

here anymore.

Finally having the full word reversed in character is you know a little bit long here.

So I might choose to replace these variable names with simply Rev and char like so.

That's 100 percent you know up to you style preference but it's something that I think still conveys

their meaning but really condenses down the line.

All right.

So looking at this as a one line solution it's still not quite as brief as the reverse function call

with that first solution we did.

But I think it's certainly a little bit more condensed down than the second solution where we use the

for loop.

So again any three of these solutions works A-okay 100 percent just fine.

And of course there are other solutions out there that we didn't even cover many different ways to solve

this problem.

However if I want to really wow my interviewer or at least make them think that I understood some advanced

array helpers like say The reduce helper then this is likely a solution I would go with right here.

OK.

So this is our first problem.

We've gone through hopefully three different solutions.

Wasn't too tiring.

Like I said in general I want to show you multiple solutions just so you see different ways of solving

a problem.

So hopefully this first problem went along.

OK let's continue in the next section and start working on our next question.
---------------------------------------------------------------------------------------------------------------

12. Debugger Statements
We've now looked at three possible solutions to the reverse string function.

Now as you were working on your own solution here you might have noticed that it was kind of hard to

debug your work.

In other words the function that you put together you might have noticed that it's kind of tough to

figure out whether or not you're doing the right thing until all the tests are passing over here and

these tests aren't the most effective thing for helping you arrive at the solution or develop a solution.

They're really more about making sure you did the right thing.

So in the section I want to give you a quick little tool that you can use to very easily debug your

work and this tool.

I'm going to show you can be used not only on this reverse string function you can use it anywhere inside

the course so the tool that we're going to use is a regular debugger statement.

If you've never used debuggers before that's totally fine.

We'll take a look at exactly how they're put together.

So let's imagine for a second that maybe we want to pause execution of our code inside this function

so that we can inspect some variable inside of here to do so we can place a debugger statement like

so.

So now any time the javascript interpreter executes this line of code it will pause in execution and

we can take that opportunity to inspect some of the different variables that are floating around our

program.

This makes it extremely useful for debugging or essentially developing our solution to make sure that

we can actually catch this debugger right here whenever we place a debugger statement like this.

We do have to manually call the function.

So right now we are defining the function and then to merely export it.

If you want to use a debugger make sure that you call the function.

So I'll call it right after afterwards right after we define it.

I mean I'll call it with a string of SDF.

So now if we run this function in debugger mode or if we run this file we will pause an execution right

here and then we can inspect a couple different variables and just kind of see what's going on.

So let's figure out exactly how that works.

I'm going to flip on over to my terminal.

I'm going to kill my test by pressing Control-C and then going to change into my reverse string directory.

Reverse string and then I'm going to execute that file that function that we were just working on in

debugger mode and I can do that by writing Noad inspect index G-S like so now when I do so you're going

to see some information pop up.

It says that we have a debugger listening and it's attached to our running process.

You'll then see some little snippet of code right here and then we get kind of a prompt right.

You're asking us what we want to do.

So we just launched that file in debugger mode the instant it started up inside of our console right

here.

It paused in execution on the very first line of our file.

So right now nothing is running.

It's just saying hey I'm ready to start to inspect your code to tell this inspector to continue executing

our code.

We can write Khant short or continue or you can write just simply see and then hit enter.

So now the debugger started to or I should say the interpreter executed our file line by line until

it found a debugger statement.

Once it got to the debugger statement it paused in execution and it's now saying hey if you want to

you you can inspect some of the variables that are floating around inside this function.

Now let's imagine that we wanted to look at the argument right here of SDR or string.

You can't you cannot just put in TR right here to actually inspect a variable.

We have to enter a REPL mode REPL being short for read at it something something.

Whatever it is.

So will run the command Ruppel that'll kick us into an actual javascript console right here where we

can start to inspect variables that exist inside of our codebase.

So I could look at the variable string and it returns to me.

Ok here is what you're what that the value of that variable is.

And then if I wanted to I could always start to say copy over some code like I'll copy this expression

right here.

I can paste it right here.

And I see.

OK.

Looks like that did in fact reverse the string properly so you can use this entire REPL and debug all

D.C.M. debugger thing to very easily audit your code base and just kind of develop it on the fly and

get a sense of exactly how the data inside of your function is working.

So this is a tool that I highly recommend you give a shot with on some future solutions.

You know definitely give us a shot.

Obviously you can't always do this in an interview setting but as you're practicing these problems this

is extremely useful to use.

Just to give you a slightly better example of why this would be useful.

Let's look at a slightly different implementation of this.

So by the way to exit the REPL I can that's not the REPL I can hit Control C that kicks me back to debug

mode and then to you execution of my file I can hit C and enter again.

And in this case there was no other debugger statement inside my code base.

So it just quit.

And I can hit Control C again to completely exit the debugger.

So to get a better example of this I'm going to remove the debugger statement we had placed.

I'm going to take this last implementation of reverse that we had put together.

I'm going to cut it.

I'm going to move it to the bottom of the file and comments it out.

And I want to take that earlier solution we had put together with a for loop.

So I'm going to uncomment this thing.

I'm going to cut it and then I'll paste it above the reverse function call like so.

And then let's say that maybe something appears to be going wrong inside of our For loop right here.

So maybe after we start to concatenate the string together let's put a debugger statement right here

and this will allow us to inspect all the different variables inside the for loop and figure out exactly

what's going on there.

So again I can go over to my Turnell.

All right.

Node inspect index.

Yes.

Again I get kicked into debug mode.

We are poznań execution on the first line of the file all run.

See to continue execution of our code until we get to the debugger statement.

So here's the debugger statement and now I can enter the REPL and start to inspect some of the variables.

At this point in time.

So possible variables that I might want to look at would be a B character string or reversed.

You know anything in here.

So we could look at reversed.

OK there's what Reversed is when to look at character.

What character is and string like so.

Now notice how this is a for loop.

So the body of the for loop will be executed many times in a row.

So if I want to I could press control Control-C to leave the REPL.

I can continue execution again.

And now I just got paused again at the second iteration through the for loop and if I hit C again there's

the third time.

And then the fourth time.

So I can enter Ruppel again.

I can look at the reverse string.

And now it's the entire reverse string.

And of course I can look at characters well and now it's the last character that we were iterating over

which in this case is at so do be aware that if you place a debugger statement somewhere inside of a

for loop or a foreach or a map statement or whatever it will be called multiple times and you'll have

to use that C command to skip through it multiple times.

OK so I think that you've got a reasonable idea of the debugger here.

Again you can use it throughout the course on any problem we are working on.

To get a better idea of how your code is working I'll show you a diagram in just a second to remind

you of some of the steps you need to go through to set up the debugger.

Just keep in mind that when you are all done with the debugger you will want to remove the debugger

statement and then also remove the manual function call.

Down here we have to add that manual function call.

The one that we just had a second ago because if we don't call the function manually then when we start

to inspect this file there's nothing that actually invokes the reverse function inside of here.

So if we just if we ran the debugger on this file as is nothing actually invokes the reverse function.

So even if we had a debugger inside of here it would never get caught because we're never executing

the function.

So that's why we add it added in the manual function call right here.

OK.

So like I said one last thing I wish to you is the diagram of the steps to use to get the debugger to

show up if you want to you could take a screenshot of this right here.

Also remember that all the diagrams in this course are available inside of the Get hub repository.

So you could always go in take a screenshot or just manually download this diagram just to have the

steps of how to do this thing up for yourself.

All right.

So I'm glad that we now have some method to effectively debug our code.

We will use this method inside these videos several times throughout the rest of the course but again

feel free to use this debugger method as you are developing solutions throughout any problem.

You can use this on any problem you look at.

And I really encourage you to do so because it will give you a much better understanding of what's going

on behind the scenes.

All right.

So I think that's enough of that.

Let's take a break and continue with our next problem in the next section.
--------------------------------------------------------------------------------------------------------
=========================================================================================================





Раздел 4:Palindromes

13. Palindromes
Now that we know a couple of different ways of reversing a string we're going to immediately start to

look at another problem that requires you to reverse a string.

So inside of my exercises directory I'm going to find the question marked palindrome.

So here it is right here.

I'll open up the index dot J.S. file and then will also make sure that we immediately start up our tests

for this exercise as well.

So I'll flip back over to my terminal.

I'll end my running test runner by pressing control C and I'll start my test back up for that new exercise

by running just palindrome slash test J us slash dash dash excuse me watch like so.

So that will start up our tests and it looks like we have five passing and three failed right now.

Cool.

So let's look at the directions for this problem.

Back inside my code editor you'll find the directions listed at the top so the idea behind a palindrome

is that we should be able to reverse a string if the reverse string is equal to the original one then

that word is a palindrome.

Otherwise it is not.

So for example if we take the string A B B A and reverse it we end up with a string a BVA.

This is the reversed form of APBA the two strings right here are identical.

And so we would return true from our function to indicate that yes this is a palindrome.

However for the string ABC TFG if we reverse that we end up with G F E D CBA.

This is not equal to the original string.

And so we would say that this is not a palindrome.

One important thing to really keep in mind here is that you are not being asked to return a reverse

string you are asked to be.

You're being asked to return true or false to indicate whether or not this is a palindrome.

So you really want to make sure that after all your logic inside of your you ultimately end up returning

a boolean value something that says true yes this is a palindrome or false.

It is not.

So I'm going to leave you to put the solution together here.

Obviously there is an element of string reversal here.

So you'll probably want to remember how to reverse a string.

And then you'll probably want to think of some way to take that reverse string and compare it with the

original one.

So I'll leave it up to you on how to approach this.

Remember I can't say it enough.

If you get frustrated don't sweat it.

Just go to the solutions.

Take a glance and then give it another shot.

Don't get frustrated here right at the beginning.

If you get frustrated now it just means that you might end up getting too frustrated and end up quitting

and all we really care about at this point is seeing enough problems to get a really good sense of what

you will be frequently asked inside of an interview.

So give this a shot and I'll see you in the next section and we'll take a look at some solutions.
-------------------------------------------------------------------------------------------------------------

14. Palindromes, Solution #1
OK hopefully you had some success in checking to see if you're working with a palindrome here if you

were not able to get the test to pass.

One thing I want to remind you about right now is to recall that you're supposed to return a true or

false value from this function.

That's what the tests are looking for.

The tests want to see a truth or falsity value being returned.

All right.

So let's give this thing a shot with our first solution.

Now the first solution we're going to look at is the easiest or I should say kind of like the most direct

solution or the most compact one.

When I say easiest I don't necessarily mean the most obvious solution or the solution that you should

have gotten.

I really just mean to say this is probably the most direct solution.

So let's give this a shot.

The first thing to recognize is that we want to somehow reverse the string that is provided to us.

So we just learned how to reverse strings in three separate fashions.

So the first thing I'm going to do here is to reverse the string that is passed to us.

So I will say Konst reversed is string dot split.

That gives me an array that I will reverse.

And then I will join it back together.

And so in one line right here I now have the reversed string available to me.

Now remember if a string is a palindrome the reversed form should be equal to the original form.

And so there's not a lot of additional logic I need here.

I can just do a direct comparison between reversed in string and return the result to that if the two

are equal.

Fantastic.

They must be a palindrome.

Otherwise if they are not equal then it must not be a palindrome so right underneath.

I can simply say return String equal equal equal reversed.

So this is a Boolean statement right here.

Or I should say it produces a boolean value if string is equal to the value of reversed then we will

return true.

Otherwise if they are not equal to each other than we will return false.

So like I said this is the most straightforward solution.

Not necessarily the easiest one to come up with just the most straightforward one.

So I will save this file.

Let's check our tests and see how we're doing.

And so it looks like that solved it.

Not bad.

OK.

So if you didn't come with that solution of course don't sweat it might me personally.

When I first sit down to look at these I usually come up with a very round about solution one that's

not always the best.

So there's many different ways of solving this problem.

Many many different ways.

If you came up with another solution that is totally fine.

Let's take a quick break right now.

In the next section we're going to look at a second way of solving this problem.

So quick break and we'll take a look at that second solution in the next section.
-------------------------------------------------------------------------------------------------------


15. Palindromes, Alternate Solution
Let's take a look at another way of solving the palindrome problem.

Now remember there is no ONE way of solving all these problems.

So if you came with a solution that is different from my own totally fine for this alternative solution

we are not going to manually reverse any string at all.

Instead for this solution we're going to make use of another array helper just like the reduce helper

that we use just a moment ago.

So let's take a look at some documentation in this solution.

We're going to make use of the every array helper.

So we'll take our string will turn into an array and then we will use this every helper on it.

Now I'm at the Indiana documentation for every and if you want.

You can come here yourself and take a look at some of the documentation but I'll give you a quick description

of how every works right now the every function is used to do a boolean check on every element within

an array.

So for example if we had an array containing the values 0 10 and 14 and we wanted to ask the question

if every single value in there was greater than 5 we could write some code that looks like this right

here.

We would take the array we'd call the every function on it and then we would pass in a function to invoke

for every element within the array.

So the first time that this function was executed we would pass in the first element as Val.

We would check to see if 0 was greater than 5.

In this case zero is not greater than 5.

So we would return false from this statement right here when the every function runs it checks to see

the return value of every function run if every function or if any function I should say of any function

returns false then the over all expression will return false as well.

However if the inner function comparison right here returns true for every element then the entire function

expression will return true.

So every as very aptly named It's essentially executing a check or some type of comparison for every

element within the array.

So I bet you might be able to have some idea of how we can use this to check to see if we are working

in a palindrome.

Here's what we're going to do.

Let's imagine this is the array of characters that we're working with.

We're going to take the first element of the array which is a.

And we'll compare it with the element at the very end.

If that if the two are equal then we will return TRUE and say OK looks good so far this is a palindrome.

Then for the next element we'll take it and compare it to the second to last value.

We'll compare the two and say are the same.

OK.

And then we will repeat the process throughout the array.

So for C we will essentially compare C to itself because it's at the very center we'll then compare

B to the previous B and we'll compare the last element to the first one.

Now one thing that you might immediately lock on here is to notice that we are doing more comparisons

that are necessary.

And that is absolutely true.

Once we have checked every element up to that very center right here we don't really have to check all

the remaining elements because we already checked to see if a.

Or the first stone was equal to the last one.

So we technically don't have to iterate through the rest of the array and compare them back to the first

elements inside of here.

And so I'm going to say that this is not an ideal solution for this problem just because we are doing

essentially twice as much work as we really have to do.

However there is a reason I am showing you this solution and I'm showing the solution just so you can

explain to your interviewer what I just explained to you when you are working with an interviewer and

answering their questions.

In many cases they'll see you.

Hey like I think that your problem or your solution has a problem.

Here's what it is.

What are you going to do about it.

And so many times you need to be able to respond identify and somehow solve these issues that come up

with your own solutions.

The issue here of double comparison so comparing the first to the last and again the last two the first

is a really easy thing to bring up an interview and it's a really easy way to look good to your interviewer.

You can propose this solution with every helper and then say you know what I think this is a clear solution.

However it's comparer is comparing or it's doing about twice as much as it needs to do.

And so maybe you could then suggest some alternative solution.

So when you are in an interview setting Remember you don't have to be line.

The best solution right away if you can think of multiple solutions to a problem.

I highly recommend you give multiple solutions.

It just shows your interviewer that you are aware of multiple ways of solving a problem and also makes

them aware that you can compare and contrast between different ways of solving a problem.

So as I've said many times so far and I will say several times again throughout the course many ways

to solve a problem.

And it's really in your interest to be aware of all the different ways of doing it.

OK.

So with that in mind let's put this to the test.

So back inside my index file I'm going to make a backup of our initial solution and then I will delete

the function body here and we'll put together a solution with the every function.

So the first thing we have to do is turn our string into an array.

Remember strings do not have access to that.

Every helper.

It's only arrays.

So the call string got split.

Passing the empty string and then call every now the first element or first argument to every function.

Excuse me is a function that will be called for every element in the array we will receive the first

argument to this function which is each character from the array as an argument that we will call char

or short for character.

And then the other thing to keep in mind here is that because we want to compare each element to it's

essentially mere On the other side we also need to figure out some way of getting access to the element.

On the other side of the array.

So fortunately as a second argument to this function right here we are given the index of the element

that we are currently iterating over which the record is high.

So the first time this inner function is called I will be equal to zero because we are operating on

the first element in the array so now inside if you're inside the function we can return a comparison

between the current element and the mirrored element.

On the other side of the array now getting access to the other side is a little bit complicated but

it's really not that bad.

So the first time we run our function we are at index 0 right here.

So I would be equal to zero to get access to the element on the opposite side.

We could look at the entire string array and access the element at the length of the array minus one.

So remember all arrays and Javascript are zero indexed.

So right here we would start off as 0 1 2 3 4.

So over here would be four.

There are five elements in the array so we can't say.

Look at the element.

At length we have to say look at the element at array length minus 1 to give us 4.

So in other words long story short all we really do here is look at the string at string length.

Linus I so that we'll make sure we increment for every step through the loop or through the every function

minus one and the minus one right here is to make sure that we are taking into account the fact that

length is the overall length.

But we are zero indexed with javascript arrays cook.

So it's looking good.

Now last thing we have to do and this is a real gotcha.

Never forget it.

We need to make sure we return the result of the every function call.

So I will put my return statement in here.

I also forgot to comment out the palindrome function down here I'll make sure I do that.

And I think we're ready to test this.

So I'm going to save the file.

We'll check our terminal and it looks like all of our tests are still passing great.

So again this is not an ideal solution right here but it definitely gives you a little bit of you know

ammunition to work with with your interview or it gives you something to talk about and say here's a

solution.

It makes use of an advanced array helper which shows you know what you're talking about but it's also

not the best way of solving it which gives you something to talk about and you can then propose this

other solution down here.

So this has been a pretty good solution.

Let's continue the next section and look at our next problem.
-----------------------------------------------------------------------------------------------------------
===========================================================================================================




Раздел 5:Integer Reversal

16. Reversing an Int
Time to move on to our next problem I'm going to find the reverse in a folder inside my project you

know open up the folder and open up the index js file.

Now before we forget We'll also start the new test file for this project as well.

So back at my terminal I'll stop the running test runner by pressing control C and they'll start up

the new set of tests by running just reverse it.

Slash test dot J.S. dash dash watch like so look at.

So you should see about four tests or so running.

All right.

So back over to our code editor let's look at the description for this problem.

Now before we talk about the problem itself I want to say that this is going to be another very similar

reversing type problem but this one has a couple of extra challenges stacked on top of it.

This problem right here is a fantastic example of how understanding and really succeeding at interview

questions is all about practice and practicing more and different types of questions.

Cause at first glance this is kind of a tricky problem.

However if you understand the one or two little tricks behind it and there are distinct little tricks

here if you understand the tricks then this turns into an extraordinarily straightforward question.

So there is a very straightforward solution to this but it's all about understanding that little trick.

So if you want to get this problem a try on your own then go ahead and pause a video right now.

Read the directions and take a look at the examples and give it a shot.

Otherwise stick around.

We're going to look at the problem.

We're going to talk about some of the little tricks that you should understand to really effectively

solve this.

And personally I recommend you stick around and listen to these tricks.

Otherwise this problem is just kind of a nightmare to deal with.

All right.

So first let's look at the directions and the examples.

Again we are reversing some type of data entry here.

In this case it is an integer.

So if I pass an integer or 15 I should see the numbers in there get reversed.

2:51 981 would go to 1 8 9.

If the number ends with zeroes then when we flip it those zeros should disappear.

So 500 should not be 0 0 5.

It should be just 5 and the other interesting thing is handling negative numbers as well.

So negative 15 should become negative 51.

And if we kind of take this issue with the zeros together with the negatives negative 90 should turn

into simply negative nine.

Now what they want to make sure is really clear here even though we're in a section on this course where

I said we're all talking about strings and whatnot both the input and the output should be numbers.

So if we wanted to kind of apply the same kind of string reversal stuff that we've been doing that's

fine but the end result of what we're doing should produce a number not a string.

So make sure that's really clear.

OK.

So let's now talk about some of the little gotchas here are some of the things that make this problem

really easy.

So first off you and I know at this point how to reverse a string.

Very well.

We've seen two problems already.

Each of them with multiple solutions on how to reverse a string.

However we've been talking about reversing strings not numbers.

We can turn a number into a string.

However by using a function called to string.

So let's take a look at my little code editor here and I'll practice this out really quick.

Now on the left hand side going to write some code and we'll see the results of that code up here on

the right hand side.

So this is a quick example let me show you maybe Konst my number equals 200 if I want to turn this number

this integer right you're into a string.

I can call line number dot to string and returns a string 200.

So at that point I can then use familiar functions like say split and turn it into an array of strings.

I can join it back together to form another string and so on.

So by using this two string function right here we can turn our number into a string and then work on

it as though it was a string and take care of it.

With all the usual reversal techniques we've looked at so far.

So it's kind of a trick number one trick.

Number two I want you to be aware of is a little function built into the math library that is included

with Javascript.

So I've got the documentation for it in a new tab right here.

I'm out the Mozilla Developer Network.

Looking at the documentation for math dot sign.

So I'm not going to tell you exactly where to use this in this problem but it's going to punt this function

out with this math sine function.

We can pass in a number if that number number is positive mouth sign will return 1.

Otherwise if the number that we pass in is negative then it will return negative 1.

So for example math got sign of 5 or 4000 or turn 1 mapped out sign of negative 4000 returns negative

1.

So I just want you to be aware of this little helper function because I think that it might be really

helpful in solving the issue with maintaining this sign here on the actual number.

Now the last thing I want to tell you about the last little trick.

Remember how we were just talking about.

Well you can turn a number into a string by using a string.

So let's say we have 400 again just to make sure it's really clear once we called to string on this

thing if we then split it into an array and join it back together.

We're still dealing with a number.

I mean we're still dealing with a string in order to turn all this stuff back into an actual number

which is exactly what we're really trying to do here.

You can use the parse int function so parse it like so.

So parsing it takes a string and it returns a number or at least what it thinks is a number inside that

string.

And then once it's been turned back into a number we can then add an add something to it like you know

add 2000 or divide by 2000 or whatever we want to do.

So clearly after calling parce and we are now dealing with a number here.

OK so that's the three little tricks part sent to string and math sign between those.

I think that you've got the tools to kind of take the reversing of string technique that we've been

looking at and apply it to this new problem that we are working on.

So at this point I encourage you to pause the video take a shot at the solution and we will go over

the solution in the next section so I'll see you in just a minute.
----------------------------------------------------------------------------------------------------------


17. Reversing an Int Solution
All right hopefully you had some success with this problem in this section we're going to walk through

the solution now for this particular problem.

We're only going to go through one solution.

There are certainly multiple solutions to this.

When you consider the fact that actually reversing the set of numbers here can be done many different

ways.

However we already spoke about some of the different ways to reverse strings.

In one of the last problems we worked on.

So this time around we're just going to kind of B-line a very direct way of reversing the actual number

and we'll focus a lot more on how we kind of work with the number in general and how we maintain that

negative sign on there.

So let's give this a shot inside my function body.

The first thing I really want to do is give myself the ability to reverse the number.

That's why I really care about here.

I want to reverse the number.

So in order to reverse the number we're going to use the same methodology that we use in that previous

section.

We're going to take the number.

We're going to somehow treat it as a string.

We'll split that number into an array.

We'll use the reverse method on it and then we'll join it back together.

So let's at least do that much and see what happens.

So I'm going to take n that's the number that gets provided to us and I want to first turn this number

into a string.

So I'm going to call and dot to straight.

So now we're working with a string as opposed to a number.

And at this point we can now use all that split reverse enjoying methodology that we saw in the previous

problem.

So I can call split to turn this into an array.

I can reverse it because it is an array.

And then I can join it back together into a string like so.

Now at this point let's just kind of make sure we get our return statement in here and I want to run

our tests and see how far this gets us I want to see what this is really going to do for us.

So back in my command line I can run my test again by pressing the enter key and it looks like ha.

Interesting.

So here is one of the tests right here.

Rather than producing the expected negative 5 negative 5 Our code is currently producing 5 minus as

a string.

Notice the set of quotes right there.

So looks like we've got two big issues on the one hand.

We're not properly dealing with the negative sign.

And on the other hand we're still returning a string here as opposed to the number that we are expected

to return.

So let's take a look at this and see what we can do.

Well in order to make sure that we return a number out of this thing we can use the parse and function.

So rather than immediately returning the result of this reversal I'm going to assign this to a variable

they'll call reversed

and then right underneath Let's return parse.

Int of reversed like so.

So now we're trying to actually pull an integer out of this string that we just produced.

I'll say this.

And let's see what happens now.

So now if we look at our test again it looks like we're passing more tests than we were before.

We still have this one test down here failing specifically around handling a negative number.

So at this point we are expected to return negative 5 on this.

But our code has produced five.

So it appears that even though we were able to somehow pull an integer out of that reversal we did not

actually maintain the sign.

So we're not including the negative side and we somehow lost the negative sign during the parse and

process.

So now all we really have to do is figure out whether or not we should get this number to be negative

or positive.

Deciding that really comes down to that input number of N so if and is greater than zero then we want

to just leave everything as is if an is less than zero then we want to multiply the result of this by

negative 1 to turn it into a negative number.

So let's try writing out that logic we can say if an is less than zero then return parse end of reversed

and we will multiply this by negative 1 like so.

So if it's less than zero return early multiply by negative 1.

Otherwise just parse the number out and we're done.

So let's try this.

I'll save the file and now it looks like our tests are passing.

Cool.

So this is definitely a working solution right here.

But clearly having these two return statements that both call Parsons isn't super ideal.

So if you stuck around at the end of the last section when I spoke about some of the little tricks that

you can use to really solve this problem in a very direct fashion.

The other the last trick that I suggested was a function that is a part of the JavaScript standard library

called Math Daut sign.

So if we pass math taught sign a positive number it will return 1.

If we pass math that sign in negative number it will return negative 1.

So rather than putting this complicated statement in here we can just dump the entire thing and instead

multiply the result of our parse in function right here.

Times math does sign and we'll pass in.

So now math dot sign is really taking the place of the if statement that we just had if and is greater

than zero it'll be positive or the result of all this will be positive.

Otherwise it is less than zero than the result of all of this will be a negative one and we'll end up

with a negative number.

So let's save this and see how we're doing.

Go.

So now we're still back to four passing tests.

But our code here is looking pretty straightforward.

Now one thing I want to throw out there.

It's totally up to you.

This is really a style thing but you'll notice that we didn't really have to come up with this temporary

variable reversed right here.

We could have easily wrapped this entire statement inside of the parsing function call.

However I think that the code right here looks pretty legible in this fashion.

And really if we wanted to kind of put everything into a one liner it really ends up being kind of nasty.

And I've actually got a example of that that I'll copy paste onto the screen.

So this would be kind of a one line solution right here.

I think that it's really tough to understand what's going on.

So personally I would really recommend leaving it as the two separate statements like so great.

So like I said this is just one solution.

There was many ways that we could kind of reiterate on this thing and change up the actual reversal

of the number.

But we already spoke about some of the different ways of reversing a string if you came up with a different

solution for actually handling the negative sign here.

We're actually pulling in number.

How do the string.

That's totally fine.

But this is definitely a solution that works as well.

So let's take a break here.

We'll continue the next section and move on to our next problem.
------------------------------------------------------------------------------------------------------------
============================================================================================================




Раздел 6:MaxChars

18. Max Chars Problem
I'm really excited about this next question that we're going to work on because the technique that we're

going to use to solve it is directly applicable to many other string related questions.

So in this one question Max Chaar there we're going to work on.

Let's open up the index not just file for it.

The technique that we're going to use to solve this can be used to solve many other string related questions

as well.

And I'll give you a list of some of the other ones that are very closely related in just a second.

First let's make sure that we start up our tests for this problem.

So at my terminal I think you know what to do by now.

We'll run just Max Chaar test dot genius dash dash watch like so you know I think I made a little.

It's not Max char's just Max Chaar.

My mistake.

Like so we should see at least three tests running.

OK.

So let's look at this problem in good detail and let's talk about the technique that we're going to

use to solve it.

So given a string we are going to return the character that is used the most.

Inside that string for example if we pass in a string of A B C C C C C will clearly C is used most frequently

inside of here.

So we see a return seat.

Likewise if we pass an apple and then 1 2 3 1 1 1.

Yeah.

These are numbers but they are inside of a string so they're still considered to be characters as far

as we are concerned.

And so clearly the most use character inside of here is one.

So we return the character or the string one not the number.

So no concern about numbers or in particular we're just saying unique characters inside of a string.

Ok so let's talk about the trick that we're going to use to solve this problem and many others like

it.

So first I want to show you some other common variations of this question.

So if you ever see questions like this on the screen right here you want to be thinking about using

this exact same technique.

And honestly I was going to put some of these other questions into this course but we would have just

been using the same technique again and again and again which would have been kind of annoying for you.

So I figured we would just do this one problem and have a good grasp on how to do it.

So if you ever see questions like the most common character on the string you see something like Does

one string have the same characters in the same quantity as another string.

That's what we refer to as an anagram.

By the way or do you ever see the question.

Does a given string have any repeated characters in it.

So anything like this anything around counting the number of characters or comparing the number of characters

between two strings.

You can always use this technique.

So let's talk about what it is here's what we're going to do for all these different problems that are

related to counting or verifying the number of characters in the string.

We are going to take our string and we're going to essentially convert it into an object where the keys

of the object are the characters from the string and the values are the number of times that that character

has been found.

So for example we could take the string Hello there.

Notice how hello there has one H.

It has three E's.

Here's what he 2E and three and he has two L's.

So with that in mind let's look at the resulting object that we would build up.

So inside of our object we would have one capital H and would have a value of 1 because that character

specifically capital H was found in our string exactly one time.

There are three E's present and they're each lower case so we would add a key of E and assign it a value

of three because it has been found three times.

Finally for l there is clearly two els here.

So we would put L in as a key and then assign a value of 2 and then we would repeat the process for

the rest of the string as well.

So when you have this kind of map right here it makes many different types of questions very straightforward.

For example if I asked you what is the most common character in the string which is pretty much what

we are trying to do right now.

Well now that we have this object we could walk through the object find the value that has the highest

there is give me find a property with the highest number assigned to it which in this case would have

been 3 and we would really know.

OK looks like is the most frequently used character.

If someone ever asks you to string a string B how the same characters at the same frequency.

Well we could build up an object that looks like this for both string a and string B and then compare

the two and make sure that both objects have the same number of properties inside of it and the same

values.

Finally does the string have any repeated characters so the words are there any duplicate characters

in the string.

Well this one's probably easiest overall.

If there's any value inside of this object with a value greater than 1.

Yeah that means that found say l twice were eat three times which means if someone asked me Does that

string have your repeated characters I would say yes that definitely does.

In this particular case.

So setting up an object like this is clearly a really strong tool for solving any type of question around

producing some counts or verification or validation of a word.

So with that in mind let's continue in the next section and I'll give you a quick overview on how we

would put together an object like this.

So quick break and we'll tackle this thing in the next section.
------------------------------------------------------------------------------------------------------------

19. Max Chars Character Map
In the last section we spoke about how turning a string into an object where the objects keys are the

letters in the string or the characters in the string can be used to solve a wide variety of problems.

In this section we're going to look at one possible way of generating this object right here.

Now if you want to give this entire problem that we're working on a go on your own and maybe even come

up with a solution that doesn't use an object like this that's totally fine.

Just pause the video here and continue on in the next section.

Otherwise let's get to this thing.

So I'm going to go ahead and use my little notepad over here to show you the solution.

So I hope to hear is that maybe you watch the solution but don't copy it down.

So maybe you watch it right now and then when you attempt the max Keres problem Remax charas problem

that we have cued up right now.

Maybe you tried to reproduce the solution from scratch at that point but of course I leave it up to

you.

All right so here's what we're going to do.

We're going to create some new string and I'll say hello there.

Just like the one we just saw in the diagram and then we're going to iterate through this string.

And for every character we're going to add that character to a new object.

So maybe you'll make a new object as well called chars short for characters.

So now there's a couple of different ways that we can take these characters and add them to the object.

We can either split the string into an array and then use a For Each helper to loop over all the characters

or we can use a four of loop to live through all the characters inside there and do basically the same

thing because we just saw the four of syntax just a little bit ago.

I think we should use four of again because it's nice and fresh in our minds.

So we will iterate through our string.

And for every character inside there we will either add the character as a property and assign it a

value of 1 or if we've already seen that character before we will add 1 to it.

So we'll save for let char of string and then for every character that we find and iterate over we're

going to add a property to chars to do that.

We'll say char's we'll use our index notation.

So this right here will return a reference to that particular character or at least its value.

Now if it's the first time that we are seeing this character we want to set its value to 1.

So if we have never seen chars at SE Capital H then this right here will evaluate to undefined.

So we need to make sure we handle that case.

So we'll say if nothing exists here right now.

Then set char's at Chaar to one otherwise assuming that there is a number already there will take charge

Chaar and will increment it by one like so.

So then at the very end we can print out charters and we end up with our object.

So we have a capital H with one.

We have three E's two l's and you get the idea.

Now the logic that we placed inside this for loop break here can certainly be condensed down from what

we have.

So a good way to simplify this would be to maybe use a tertiary expression.

We could also kind of condense this down to one line with a little bit of boolean logic and you want

let's let's see a quick example of that.

So another way of putting this logic inside if you're together without using an if statement would be

something like chars at char is char's char plus 1.

Now you'll notice this is why we can't just say add one.

Because if we try to add 1 to undefined we end up with no.

As you see right here.

So that's why we have to put in that statement to see if that value exists yet.

So one way of handling this eloquently in this particular case would be to say if adding one onto this

number resulted in a null value that's fine.

Then instead assign the value of 1 like so.

So if this is falsie then otherwise assign one to char at char and we end up with the same object either

way.

It's like I said many different ways of putting together the body of the for loop right here.

It's really up to you which way you want to do it.

All right.

So hopefully that kind of illuminates how we put this data structure together.

So at this point let's take a look at our question here and make sure it's really clear what we're trying

to do.

So inside this question member we are inside the max char folder in the index start G-S file.

We want to pass in a string to max char and then return the character that is most frequently used inside

that string.

So clearly inside the string C is used the most.

So I would expect to return see otherwise if we have Apple 1 2 3 1 1 1.

Well then we want to return one call.

So at this point we're going to take a break give this thing a shot see if you can't solve it.

And we'll go over the solution in the next video.
------------------------------------------------------------------------------------------------------------

20. Max Chars Solution
In the last section we spoke about how he can use a character map to solve a wide variety of different

string related questions a character map is an object where we take every character out of a string

we added as a key to the object.

And then the value for each for that key is the number of times that letter has been found in the string.

So hello there has three E's Inside of it.

So we have a Kievan E and assign a value of three.

Let's take this technique right here and approach and apply it to our Max char problem.

So remember inside of Max char we're trying to find the character that occurs most frequently inside

of a source string.

So definitely a problem that is well-suited to building up a character map.

So let's get to it inside of our function.

We'll start off by declaring a new variable called Char map which is short for Character Map and will

be an empty object.

Next will iterate over our source string right here and use that to build out the character map.

So we'll save for let char of string and then for every character that we receive we will add an entry

to Character Map and if an entry already exists there.

Then we'll just add 1 to the number.

So we'll say if Char map at char.

So if this exists if we already have an entry here.

Great.

Let's increment it by one

otherwise we will set char map at Char equal to 1.

So char map that char equal to 1.

Now you'll notice that I wrote this out opposite of how we just said in the example of minute ago I'm

just doing that on purpose just to give you a little bit of variety and make you use your brain just

a little bit.

So do you take note that I flip the kind of order of operations here between the two cases.

So now we should have our character map built up at the bottom of the file.

Or this function let's print out the character map that we just built just to make sure that it is working

correctly.

So I will console log char map like so let's flip on over to the terminal and see what happens.

So over at the terminal I should see my two console logs appear right here.

And so it looks like I correctly have.

Here's my character of one.

A B C D F G.

So remember this is some test input that is provided right here.

So looks like the test input has the character 1 and it's used six times.

So I would definitely say it this looks like it's working correctly right now.

All right let's take a quick pause right now.

We'll continue in the next section and we'll discuss how we can now iterate through our character map

and find the character that is most frequently used.

It's a quick break and we'll finish this up in the next video.
--------------------------------------------------------------------------------------------------------

21. Max Chars Solution Continued
In the last section we were able to verify that we successfully built a character map to represent our

strength.

Now it's up to us to somehow iterate through this character map and find the character that was used

most frequently in a given string.

So taking care of this is going to be very much like iterating through an object.

We're going to iterate through it.

We're going to try to find the value that has been used most frequently.

Now there's several different ways to iterate through an object like this and find the max value.

But we're going to take a very direct straightforward approach.

So we're going to start off by declaring to helper variables at the top of the function we'll say let

Max set that equal to zero and then let Max char and set that to an empty string.

So we're going to iterate through the character map if we ever find a character that has more uses than

max.

Then we'll set max equal to that new value and we'll set max char to a character that was responsible

for that number of uses.

So in other words the first time we iterate through say this hello world object right here we would

look at the key value pair of H and one.

Now one is greater than the initial variable of Max.

So we would say oh this must be a new maximum that we found.

So we would set max to 1 and then Max char would be set to the key at that location which is H.

We would then go onto the next value.

This one has three.

So we would set three equal to max and then Max char would be updated to e because that is the new maximum

character.

So in practice really not the worst thing in the world.

Let's give this a shot.

So I'm going to go down to the console log at the bottom and we will replace this with the new loop

to iterate through our character map.

So we'll save for let char.

And now here's something that's going to kind of blow your mind.

Notice how in the past we've been talking about that for of loop.

So the for loop is used for iterating through an array or a string or any type of iterable object.

But in this case we are iterating through an actual object like a collection of key value pairs.

So to iterate through this object or any type of javascript object as opposed to an array or a string

we instead use a slightly different kind of loop.

So in this case we use a loop that uses the for in syntax as opposed to four of the way that I remember

the difference between the two of these are just remember that object starts with 0.

And ironically they chose not to use of or you know starting with 0 to iterate through an object.

So I remember object starts with 0.

We do not use the four of which begins with 0 to iterate over an object.

Instead we use for it in.

So that's how I remember it personally.

So look at each character for char map.

Then if the char map at this particular character is greater than our Max we're going to update both

the max number and the max character.

So Max will become char map at char and Max char will become char.

So as you can guess right now when we iterate with a for in loop char right here is assigned to the

keys inside that object.

So this is not the values it is the key.

So char will be the different letters that we have added to our object.

Now after we run the loop we should then know which character is the greatest number of uses it will

be assigned to max char which means at the very end all we have to do is return Max char like so.

All right let's see how our tests are doing.

It looks like they're all passing.

Terrific.

OK.

Like I said using this kind of character map set up right here can be used to solve many different types

of string related questions.

And I really recommend you keep this technique close at hand whenever you are an interviewer they ask

you anything about strings it can be used in so many different locations.

So hopefully this has been helpful.

Let's continue the next section and continue working.

So a quick break and I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------
=================================================================================================================




Раздел 7:The Classic FizzBuzz!

22. FizzBuzz Problem Statement
The next problem that we're going to work on is going to be a lot of fun because it is the classic interview

question.

It is this buzz the question that has been asked more times than you could possibly believe in an interview

setting.

So in our physio's folder we're going to open up the index not just file will also immediately start

up our tests for Hizbullah's it as well.

So at my terminal or run just this buzz slash test that J us dash dash watch like so and then we should

verify and make sure that we see three Tests in total right now.

Two are failing one or passing OK.

Like I said this is the classic interview question.

As we said much earlier in the course one of the first sections we looked at and that one of those earlier

sections we had said that this is a problem that is really kind of challenging maybe moderately challenging

the first time you see it but as soon as you learn that little trick to it it becomes the easiest thing

in the world or so everyone claims.

So really if you haven't seen this problem before.

Don't sweat it.

If it seems challenging it's not until you see the little trick that it starts to get a little bit easier

to handle.

So let's make sure that it's really clear exactly how this problem works.

We have our first bus function down here towards the bottom when we call the fizz buzz function with

some whole number.

So some whole positive number we need to print out all the numbers from 1 to that number.

So when I say print out I really mean console logs we're going to cancel log out all the numbers from

1 to n. However for any number that is a multiple of three it's a multiple of three.

We are going to print out the string fills.

If the number is a multiple of five we're going to print out because if the number is a multiple of

both 3 and 5 then we're going to print out fizz buzz.

That's it.

So the real challenge here is I would really imagine you know how to count Konst alog you know how to

write a for loop to loop from 1 to n..

Clearly the challenge here is determining when the number is a multiple of 3 and five.

So that's it.

That's the little trick.

That's all there is as long as you can figure out exactly how to calculate a multiple of a number.

You can solve this problem without any issue.

So let's do a quick reminder on how to calculate a multiple of a given number in Javascript.

So I kind of flip back over to my little notepad here.

So we're going to use a very specific operator.

Now when I say operator I'm talking about like an addition sign a negative sign or a minus sign division

whatever it might be.

So if we say for example one missed one in this case the minus sign right here is our operator.

Now there is a very rarely used operator in the javascript world called the modulo operator and we spelled

out maade modulo like so.

So the modulo operator we can determine the remainder of a number during during division.

So for example if we took nine modulo three and returns zero.

So in this case it is zero.

Because if we divide 9 by 3 3 goes into 9 exactly three times and there is no remainder left over.

However if we divide 10 by three we'll then 3 goes into 10 still three times.

And there's one left over.

So three times three equals nine.

That is 1 away from 10.

And that's why we get a result of one over here.

If we do 11 mod 3 we'll then we're two away.

But if we go to 12 12 is again a multiple of three.

So we're back to zero.

So to determine if a number is a multiple of another we can use the modulo operator.

And essentially what we want to do is take some given number that we're trying to test use the modulo

operator with the number that we are using as the multiple.

And then the real question here that we are asking is whether or not the result to that is equal to

zero if 12 maade three is equal to zero then 12 must be a multiple of three.

However if we use 11 mod 3 this is not equal to zero.

So we get false.

So the story here is pretty much it.

This right here is the line that is the sole trick to fizz Buzz.

All you need to know is how the modulo operator works and then you can solve the entire problem.

So in practice you're going to test for each number from 1 to n and remember and is the number that

we pass in as an argument to the physio's function right here.

You're going to test to see if a given number modulo 3 is equal to zero.

And if a given number modulo 5 is equal to a given number person B is equal to zero.

And that's pretty much it.

That's the challenge here.

So I'd like you to give this thing a shot now as you're working through it.

There is one thing I want to point out here just because of how the tests are written.

Note that when you are printing out fizz and buzz and fizz buzz for multiples of three and five.

Notice that the expectation is that you're going to print out lower case things.

So lower case is not upper case for doing lower case fears here.

That is specifically what the tests are looking for.

Now the other thing to keep in mind is that you are not returning these numbers.

So if you find a multiple you're not returning it from the function you are con. logging the number.

OK.

OK.

So with that I'd like you to take a shot give it the best.

Darren can help go over the solution in the next section so I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------

23. Solving FizzBuzz with Style
All right hopefully you had some success with putting together your fist but solution in this section

we're going to walk through the solution and make sure it's really clear exactly how it works.

Remember the whole key to the solution is recognizing exactly how that modulo operator works.

The other thing that's really important to keep in mind is that as we are iterating through our list

of numbers we want to print out the number or features or buzz or fix bugs.

So for one particular number we print out only one thing we don't print out like three and four is for

the number three right here we print out only fizz.

So let's get started.

Step one is to make sure that we can iterate from 1 to n inside of our function.

So I get to find my first bus function down here towards the bottom and we're going to set up a loop

inside of it to iterate from one to end.

Now I know that I said a little bit ago that whenever you're doing interview questions you want to avoid

setting up manual for loops.

However this is one of those cases where we really can't get around it.

We don't have any object to iterate over.

We don't have any numbers or me any array to iterate over all we know is that we want to iterate from

one to end.

So this would be a case where we kind of are in a situation where we really want to just set up a for

loop manually.

So we'll set up our for loop to iterate from 1 to eat less than or equal to N and each time we're going

to increment by one.

Now one important thing to keep in mind here is yes we do want to start at 1.

If you write a lot of four loops in your life well you might be used to saying start off at zero.

We're not starting at zero here are the directions specifically say that we are iterating from 1 to

10.

So we're going to make sure we write out our loop like so next.

What I really recommend you do an interview setting just to make sure you nail this question 100 percent

is to write out some comments to guide you.

So the first thing we want to do here is check to see if the number is a multiple of both 3 and 5.

So we're going to say is the number a multiple of 3 and 5.

Because if so we want to cancel log and then do nothing else in this step through the loop.

And that's really important.

Remember if our number is say equal to 3 we only want to print out things and we don't want to print

out the number three.

So we need to make sure that we whenever we do all of these checks we initiate the check.

We print out the statement that is required and then we do nothing else inside of the step through the

loop.

So let's get started by writing out the if statement that is going to check to see if our number is

a multiple of both 3 and 5.

So I'll say if I modulo 3 is equal to zero.

So that's going to check to see if we have a multiple of three.

And if I modulo 5 is a multiple of zero then we want to cancel log out fizz buzz like so so that's step

one.

Now one thing that I will mention right away is if you look at this and you are kind of got a thing

for numbers.

You'll very quickly realize that we only are going to meet this kind of criteria right here having a

multiple three and a multiple of five when it is a multiple of 15.

So any number that is a multiple of three and five is going to be a multiple of 15 because three times

five is 15.

So if you came up with a solution where you said I modulo 15 and left it just like that.

That's totally fine and appropriate.

This is something that sometimes people do because it is just a little bit more terse and easier to

read but honestly you're totally fine leaving it just like so.

All right.

So we have successfully checked to see if we are a multiple of three and five.

Now the thing to recognize next is that we don't want to set up a nother separate if statement.

So if we met this situation right here this condition this is the only code this council is the only

law that we want to execute.

So essentially what I'm saying here is we want to make sure that if we meet this case we don't execute

any other code inside the for loop.

And so to make sure that's the case rather than writing out a bunch of separate if statements we'll

write out a bunch of ELSE IF statements.

So we're going to see if we meet this condition if we do.

Great.

Do the console log and go on to the next step through the loop.

Otherwise if we meet this next condition execute the next console log and so on.

So for the next one we'll check to see if we have a multiple of three

and I'll add a comment here just to remind myself is the number a multiple of three.

And if it is a console log out this next we'll out in the next.

Else if if so if we have a multiple of five then we'll cancel log out buzz.

And then finally if we have failed all three if statements inside of here.

So if we are not a multiple of 15 not a multiple or three not a multiple of five.

Finally at the very end here we'll just print out the number.

And so I will console log simply.

I like so ok.

You'll notice I missed my comments on these last two cases but I think you have a reasonable idea of

what those comments would be if you want to add them in.

So this right here is the classic an imitation of this buzz.

Now you will see sometimes other situations online or other implementations that kind of condense this

code down a little bit and they might use Tzschirner expressions or some oddities around javascript

to shorten it.

But honestly at the end of the day if someone asks you this question I really recommend you basically

just do exactly this right here.

There's really no need to get fancy.

And honestly if you start to get fancy with fizz buzz that's kind of something that interviewers lock

on to interviewers like to see that you understand advanced syntax and they want to see that you know

how some neat helpers inside javascript works.

But if you start putting what is otherwise very straightforward legible code like this into some really

fancy one liner honestly it's kind of ironic.

But their first inclination and I've seen this happen so many times in person.

Their first inclination is to say something like Wow you took some really easy code and you turned in

as some fancy one liner.

That's really hard to understand.

And so it's like well you know on some questions they want you to go above and beyond and use some fancy

javascript.

But on the ones they really want it to be just straightforward and simple.

And I would definitely classify fizz buzz as one to leave as very straightforward and simple.

So I really recommend you just kind of leave it in long form like this and not try to make it fancy

or condense it down to anything else.

OK.

Let's make sure that our tests are passing.

If we flip on over to the terminal.

Yup looks like we got three test passing.

Awesome.

So again classic this was all you got to remember is how the modulo operator works as long as you do

you're going to have an easy time with this question.

So now that we've heard this buzz it's time to move on.

Let's get on our next topic in the next section.
------------------------------------------------------------------------------------------------------------------------------

24. Array Chunk Problem Statement

I'm really excited about the next prong are going to work on because it's one of my personal favorites

in as much as you can have a favorite interview question.

So inside my code editor I'm going to find the chunk folder and then open up the index G-S file inside

of it and then of course before we forget we'll also flip on over to our terminal and start up our tests

as well.

So just showing tested.

Yes.

Dash dash watch like so and just make sure that you have.

Let's see five-Test popping up.

That's how many we have for this particular exercise.

So let's look at the directions here inside the index file.

You'll find the directions at the top.

So given an array in a chunk size as arguments and so look at the chunk function right here it accepts

an array and the size as argument.

Using those we want to divide the array into many sub arrays where each subarray is of length size.

So in other words we're taking one big array and splitting it into many smaller substrates that are

all contained within one larger array.

This function is probably easiest to understand when you start looking at some examples.

So let's do exactly that.

Let's look at the first one right here.

If we call chunk with an array of the numbers 1 2 3 and 4 and specify a chunk length of 2 then we should

end up with one big array that contains smaller arrays inside of it.

And so these smaller arrays are what we would refer to as the sub arrays each separate is of length

2 because two as we passed in as the size.

Notice that the two here is specifying the number of elements that go into each chunk.

It's not specifying the total number of chunks.

So to write here doesn't mean that we should have two separate chunks.

It means that there should be two elements in each chunk.

Perhaps the next one gives a little bit better example in that regard.

So in this case we have 1 2 3 4 and 5 and we still have a chunk size of 2.

So in this case we put two elements into the first chunk two elements into the next junk and there's

only one element remaining.

And so we take that one last element and put it into its own chunk at the very end and then you can

see this repeated throughout the other examples as well.

Another good example might be the one down here second to the bottom.

So we have one two three four five and a chunk size of four.

So we create one chunk that has one two three four elements inside of it.

And the only remaining element goes into its own chunk.

So in other words if you have kind of an orphaned element or you don't have enough elements to fill

up its own chunk that's totally fine.

You just stick it into its own chunk at the very end.

So that's pretty much it.

That's the challenge.

This is definitely a harder problem to solve.

But nonetheless I'd love it if you gave it a shot.

I'm going to let you kind of take it from here.

Without a lot more input from me.

Consider this a little trial by fire.

But of course if you get stuck at all don't sweat it.

Watch a couple of minutes of the solution and then come back and give it another shot.

So a quick break for you to work on this and we'll look at the first solution in the next section.
----------------------------------------------------------------------------------------------------------------

25. Chunk Solution #1

Hopefully you had some success with that chunk problem.

This is definitely a pretty challenging one.

So if you ran into any issues hey don't sweat it.

In this section we're going to go through one possible solution to that chunk problem.

Now there are two solutions that come to mind kind of easily when I think about this problem.

So we're going to look at one possible solution in this video and then we'll look at another possible

solution in the next one.

Now I think that the difficulty between these two solutions are kind of equal in putting them together.

But I think the second solution so the one that we'll look at in a little bit is probably more challenging

to arrive at by yourself.

So this is another great example of when you know the trick things get easy.

But if you don't know the trick well life is a little bit hard.

OK.

So we're going to look at a diagram.

This is going to describe our first solution.

So let's take a look at this.

So we're going to walk through this series of steps right here.

So this is our algorithm starting at the top and going down.

And as we talk through this algorithm We're also going to kind of trace out how all these different

puzzle pieces are changing or all these different arrays are changing over time.

So it's going to be just a little bit awkward.

Hopefully you can bear with me as I tried to diagram or demonstrate this with some of these shapes.

So let's get to it.

First off we're going to assume that our chunk function gets called with some array that has three elements

inside of it.

And so this green thing right here this is the array that our function is going to be called with.

We're also going to assume that we have a chunk size of two just for the purposes of walking through

this example.

So here's the algorithm we're going to use.

We'll first start off by creating a brand new empty array to hold this kind of chunky version of our

data and we're going to call this thing chunked.

So this is like the chunked version of our array.

So we're going to represent this brand new array that you and I are going to create with this blue box

right here.

And so I will draw an arrow from that step to this blue box to just remind you hey this is the chunka

version of our array.

After creating this empty array we will then start to L to iterate through the original n chunked array

that was passed into our function.

So the unchecked array is this original one right here up top in green then for each element in that

unchecked array we're going to go through a series of steps right here.

First we're going to retrieve the last element in the blue chunk.

So the last element the element that's Furnas to the right hand side.

Now the first time our algorithm runs this brand new chunk array will be completely empty.

So when we attempt to retrieve the last element inside of it we will end up with essentially undefined

will have nothing to show for it.

So the next line is how we handle that we're going to look at that element that we just retrieve the

last element in the chunk array.

We will say that if the last element does not exist or if the last element inside the chunk Drey is

equal to chunk size then execute this step right here.

So we definitely fall into this statement right here because the last element in our chunk doré does

not yet exist for the first time we run through this.

So we're going to execute this line of code right here in this line of code says that we are going to

push a new sub array or a new chunk into the blue chunk to one with the current element that we are

iterating over which is 1.

So this is the for loop that we are iterating through right here.

So we're going to take a new sub array this kind of chunk right here.

We're going to push it in and then we're going to add our first element to it.

And that concludes our first loop through this array.

We now will will iterate through this array again.

So we're going to move on to element 2 right here.

We will attempt to retrieve the last element and chunked.

Now this time it's going to be this blue chunk that we return right here.

So this is the last element in our chunk.

So this time we checked to see if that last element does not exist.

It does exist.

So that's not satisfied.

We then checked to see if the length of that chunk is equal to our chunk size of two.

Well at present our chunk size is 1.

So we don't fall into that case.

So rather than executing this line of code we'll go down to the else case right here in the case says

add the current element which is to into the chunk the last element in the chunk Drey.

So we're going to take two and added And right there.

Finally we'll iterate through the last element inside of our unchecked array.

So this is going to be a 3.

We retrieve the last element in chunked.

So that's going to be the purple block box right here.

We checked to see if its length is equal to the chunk size.

And so now at this point in time there are two elements inside of here and we have 2 a chunk size of

two.

So we do satisfy the if statement right here.

And we're going to run this line of code so we're going to push a new chunk into chunks.

So we're going to take this new chunk shove it in there and then we'll take the current element and

put it inside that.

And now we have nothing else to iterate through with our for loop.

Our original loop right here is now empty.

We've gone through everything and we have ended up with our correctly chunked array right here.

So this is it.

This is pretty much how we're going to accomplish this.

First run through this first solution.

Now again if you came up with a different solution than this one that's totally fine.

Totally appropriate.

This is just one possible solution and one that I personally think is kind of straightforward and easy

to understand or at least relatively easy.

So let's now take a break.

We'll continue in the next section and start to code this solution up.
----------------------------------------------------------------------------------------------------------------------------

26. More on Chunk

In the last section we looked at the diagram to understand our chunk solution.

Let's now continue by coding this thing up.

So inside my code editor I'm going to make sure I'm inside of my shunk index dot js file.

I will open up my function here and we'll start adding a little bit of code.

So remember Step one is to declare a new array that is going to hold all these different chunks.

So I'm going to create a new array.

I'm going to call it chunked to say hey this is the array that holds all the different chunks of data.

Next we will iterate through our original array of elements right here to iterate through the array

we're going to use the four of helper again.

So we'll say for let element of array and then we'll execute some logic inside of here to look out the

last element inside of our chunked array.

So to get the last element inside the chunk array we'll make a temporary variable.

So we'll say last is to say this is the last element inside that array and then you get the last element

inside of there.

We can say chunked at chunked dot length minus 1 like so.

Now the next part is pretty well explained by the diagram over here.

We want to check both to see if that last element does not exist or if its length is equal to the chunk

size because if it is we want to push a new chunk into chunked with a current element that we are iterating

over.

So to accomplish that we can say if last does not exist or if the length of last is equal to our chunk

size remember chunk size appear as an argument.

Then we want to add a new element to chunked or a new chunk to chunked and put our element inside that.

So to do that we can say chunked Daut push and then rather than put a new chunk inside of it and then

add the element ID in we can do both things at the same time.

So we'll push in a new chunk and we'll immediately put our element that we are currently iterating over

inside there.

So we're doing both things in one step.

Now the last thing we have to take care of is the case in which we already have a chunk but it does

not get full.

So in that case we're going to take the current element and add it to the chunk and remember the chunk

that we're discussing is this last variable right here.

So otherwise we will last dot push because remember last year is going to be the chunk that we are currently

working with and we will put our elements into that thing.

Now the very last step and make sure you never forget this.

This is such an easy thing to forget.

Make sure that you return the chunked array at the very bottom.

So we will make sure that we return shopped like some.

OK.

So save this let's check our tests and see how we're doing.

Well hey it looks good to me.

We've got five test passing out five.

So like I said this is one possible solution.

I think that this might be the slightly more obvious one.

Are you whenever I say obvious I don't mean hey this is so obvious you should definitely get this.

I just mean to say this one is probably a little bit more evident than the alternative solution that

we'll look at in the next section.

I do consider the next solution to be a little bit easier to put together and probably easier to understand.

But it's definitely more challenging to kind of think of on your own.

It's one where you can have to sit down and kind of noodle on it for a little bit.

This kind of iterative solution right here is probably one of the first ways a lot of people will think

about accomplishing this.

Now maybe if you thought of a solution like this and you didn't take this entire hey let's look at the

last chunk and see what to do with it.

Well maybe you didn't take that approach but maybe you at least did this kind of let's iterate through

the array and consider each element.

That's what I mean by you know I think this one might be a little bit more common to see in the wild.

So this is one possible solution.

Let's continue in the next section we're going to look at the second possible solution to this problem.

So quick break and I'll see you in just a minute.
------------------------------------------------------------------------------------------------------------

27. Chunk Solution #2

In this section we're going to look at a alternate solution to that chunk problem.

Now as usual we'll make a backup of our solution.

So inside of my current index not just file I'm going to copy my first attempt at chunk I'll paste it

down at the bottom of the file just for records.

Now a comment that went out and clean up the original chunk function by deleting the contents like the

OK so just like the previous section or the previous two lectures in this video will look at this alternative

approach.

We'll take a break and we'll come back and code up the solution because I do want to give you the opportunity

to attempt a solution with this other fashion if you want to.

So let's get to it.

All right now knowledge of this second solution.

Like I said it's a little bit harder to come at this solution on your own unless you are very familiar

or have very recently at least how this function in mind one particular function that has to do with

arrays and this function is called sleights.

So if we call letters dot slice.

So this is a function or a method that exists on all arrays.

We can pass in some start index.

So let's say I start index of 0 and then as the second argument some and index.

So maybe I'll put in three like so.

So this says starting at element 0.

Give me a copy.

That's very important.

We are taking a copy of every element inside of letters from 0 to element 3 but not including element

3.

So in this case element 3 would be the letter D right here.

So take everything from 0 up to element 3 but not including it.

One very common mistake around slice is thinking that the second argument is the number of elements

that we want to slice out of the array.

That is not correct.

If we change say the first Delman right tool 1 we're now taking everything from Element 1 up to but

not including element 3.

So clearly the second argument is not a length here.

If it was a length then we would still see three elements inside our result over here.

So with this slice method in mind we can start to think of a alternative approach to the chunk problem.

So again we're going to kind of sketch this out with a diagram.

I know this is kind of sloppy to do with the diagrams but frankly I can't do animations and you know

fancy Illustrator or what have you whatever you would use to make illustrations so I kind of like just

drawing it out keeps it simple.

So again we're going to start off by creating a empty trunked array and that's going to be our blue

box right here.

Then we're going to create a index variable.

So just some random variable.

We're going to call it index and we're going to start it off at 0.

We will then create a for loop or be a while loop and this while loop will run as long as index is less

than our original arrays length.

And then here's where things get interesting.

Inside this while loop we are going to take a slice out of our original array starting at index and

ending at index plus size will take a slice out of it and then we will push that into our chunk array.

So let's put some numbers to this thing for the first go through.

We're going to start off with the index of 0 and we have a chunk size of two.

So we're going to take a chunk size from 0 to.

And we're going to put that into our array right here.

So our a slice from 0 to 2 on the green array would include everything from 1 to 2 right here.

So take that slice it puts it into our chunked array element one element to we then add size to index.

So chunk size to index.

So the second time around we then restart our while loop right here.

Index would now be equal to 2 and we'd then repeat the process.

So we had now attempt to take a slice from two to four.

And in this case we don't have elements going up to 4.

So it just gives us everything left inside the array.

And we would end up sticking everything in like so.

So I think as far as the code goes with this solution it's probably far less code that we have to write.

And there's really kind of less edge cases that we have to worry about but it really does.

It's all predicated on your knowledge of the slice method.

If you're not familiar with slice in the interview setting.

Well then this would be a hard one to kind of pull out of a hat and imagine if you did come up with

a solution.

I've got to like hats off to you like nice job coming up with this one because this is definitely not

a solution that I think I would come up with on top of my head personally.

So now that we have a better idea of how this works let's take a quick break and then put together the

implementation in the next section.
--------------------------------------------------------------------------------------------------------

28. Even More on Chunk!
All right let's give a shot at our second implementation here by using the slice function.

So I'm back inside my chunk file I'm going to open up my function and we'll start off by following some

of the blueprints that we left over here on the diagram.

So we had said that we would create an empty chunk array and we would create an index variable starting

off at zero.

So inside of chunked or something inside of chunk we'll create chunked which will be our empty array

and it will create our index variable.

Now index is going to be changing over time.

So we're not going to use a concert keyword here.

Instead we use a let keyword because this is a variable that we want to allowed to change over time.

Next we'll set up our while loop.

So we want to run this while loop as long as index is less than the original arrays length.

So I will say while index is less than array length and then inside of here's where the magic really

starts to happen first we'll write out the slice statement.

So this would be the statement that we'll take a slice out of our original array right here.

So we want to slice everything from index to index plus size.

That's the magic that's the hard part right there.

Array that slice produces an array that contains some number of elements out of the original array right

here.

So we can take this slice that gets produced and just stick it directly into the chunked array by using

the push method.

So we'll take this whole thing and stick it into chunked by saying chunked dot push like so and then

make sure you're close off the parentheses on the other side.

Then immediately after that after we do our slice statement right here we need to move on to the next

index.

So we're going to take our index variable and we'll add size to it.

So we're not incrementing by one here where incrementing by the size variable because you want to essentially

take big scoops out of the original array over time.

So say index plus equal size and then remember that one very important step that I would never want

you to forget.

Make sure you return chunked at the bottom OK.

Let's check our tests and it looks like they're still all passing.

So I think you can agree with me that this is visually a kind of more straightforward solution at least

in terms of lines of code.

And as long as you understand how slice works it probably is a little bit easier to understand what's

going on rather than the solution that we came up with before where we iterated through the entire array.

Again I think this would be a harder one to come up with on your own so if you didn't come up with this

hey don't sweat it.

Remember this course is all about just giving you these little tricks and tips because that's how you

get better over time.

You just see more problems.

You learn tips like this and you apply them to future problems that you see.

So let's take a break right now.

We'll continue in the next section and start looking at our next problem.
--------------------------------------------------------------------------------------------------------------
==============================================================================================================

Раздел 9:Anagrams

29. What Are Anagrams?

Our goal here is to check to see if two strings are anagrams of each other.

Remember an anagram is where we take one string and then generate another string out of it that has

the same number and quantity of characters.

So for example if we took the string rail safety and jumbled those letters into this string fairytales

they both use the same number in quantity of each character.

So for example I will find exactly 1 are in both strings.

I will find two ways in both strings and so on.

You get the idea.

Now some special directions on this question in particular is note that we only want to consider characters

we don't want to consider spaces or punctuation like say ex-school exclamation marks or anything like

that so we can completely disregard exclamation marks and spaces.

In addition we want to consider capital letters to be exactly the same as a lowercase character.

So the second example right here is a great example of both those two rules.

So you'll notice right above we have real safety and fairytales are anagrams.

The second example right here has still real safety but with capital letters and exclamation marks.

However we should still consider this to be an anagram of the lowercase fairy tales.

Now just to make sure that you start down the right path.

I want to give you a couple little tips for dealing with these kind of edge cases around characters

and not spaces or punctuation.

And also a quick tip around capital letters as well.

So let's flip over to my browser really quick.

We're going to look at some examples here.

So the first thing I want to give you a quick note on is on the Indiana documentation we have Regg axes

which are short for regular expressions regular expressions can be used to manipulate strings very easily.

And in this case we can use a regular expression to very easily remove all the spaces and exclamation

marks from a given string.

So in this article I'm going to scroll down a little bit and one of the items inside of here right here.

So backslash w specifically shows us how to match only characters and completely disregard any type

of space or any type of punctuation or other symbol for that matter.

So let's see an example of this in practice as a quick example let's say maybe we have a string called

Word and it is the string.

Hi there.

All capitals with a lot of exclamation marks and a space in between right here.

So we can very easily remove the space in all the exclamation marks from this thing by calling word

dot Daut replace and they'll make use of a regular expression inside this.

So I'm going to place a forward slash a square bracket a carrot backslash w a closing square of race

slash G.

And then we will replace any characters like that are that are found with an empty string.

And so you can see that very easily that removes all the extraneous characters from the strings so it

gives us something a little bit more cleaner to work with.

Now the other thing to keep in mind is that we only want to work with lowercase characters.

So a very easy way of making sure that we are working with a lowercase string of beats of chain on the

method to lower case like so and so essentially with these two methods right here we can take a string

that is capitalized with spaces and punctuation side of it and reduce it down to just the bare characters

like so.

So I really expect to you will end up making use of these two methods right here and your solution.

So essentially copy these things down because I really expect you're going to need them.

Now the other thing I want to mention just as a reminder about how we'd generally like to solve any

type of question involving strings and comparison between them is to generate character maps and that

was something that you'll recall we did earlier on in this course.

So just as a suggestion.

One possible way and this is just one way there is more than one way to do this question but one possible

way is to generate a character map out of both the strings you are given.

So for example if we are given the strings hello and I don't know what this is supposed to be.

Li Li Ho I guess I don't know if we build a character map out of both these.

We would end up with 1 h one e two l's and 1 0.

And we would get the exact same character map for Leo as well.

So we could iterate over one of these character maps and compare all the letters inside of it with all

the letters and the other one and the quantities as well.

So I'll leave that one up to you to kind of get through a little bit and figure out.

So there is one last little gotcha around the character maps that you're going to generate here.

If you decide to go with this method let me show you what this kind of edge case is when I just told

you that you would want to compare these two character maps.

You might have thought OK we can iterate through this object right here and then compare all the properties

and values with the properties and values in the other object as well.

So there's one little edge case that I want to throw out there just so you are aware of.

Imagine the case of we were going to compare these two character maps.

So notice I just change the diagram the word over here on the right has changed to close.

So has an extra s on here.

Now imagine if we wrote a loop to iterate only through this object if we only iterated through this

object we would look at the character H see that it has one use and compare it over to this object we

would say OK this one has h as well and it has one uses well within repeat the process for E.

They're the same l they're the same.

Oh they're the same.

And that's it.

We've now finished iterating through this object.

But notice how we completely missed the fact that this other character map has an extra s on it.

So one possible way of solving this problem is to compare first this character map to this one and then

iterate through this character map and compare to this one.

However there is the easier or kind of a little shortcut that we could use to avoid that.

So we don't really have to do a comparison one way on a comparison back to the other.

If you want to know what that little trick is I'm going to say right now what we can do is count the

number of keys that are present inside of one object and compare it to the Keys that exist inside the

other.

So for example this key over here has four legs or letters inside of it.

This one over here has five.

And then another very obvious way of handling this would be to count the length of characters inside

this string and compare it to this one over here.

So just two ways of addressing that issue.

OK.

So we've laid out a couple of notes here.

Now this anagrams question is a rather challenging one.

So do give it a shot but as usual if you get stuck feel free to check out the solution and we'll walk

through how to solve this thing together.

So quick break and we'll continue with the solution in the next section.

--------------------------------------------------------------------------------------------------------------

30. Solving Anagrams
I'll read my friends hopefully anagrams was not too bad.

This is a rather challenging question.

It is challenging but it's also one that I can almost guarantee that you would see in an interview setting.

So if you go on like 10 interviews I would personally be surprised if you didn't get asked this question.

So it's definitely a very good one to keep in your back pocket because you never know when it's going

to be asked.

So let's talk about her solution here by using character maps.

We're going to build a character map out of string A and string B and then we'll compare all the characters

inside those two maps together.

So let's start off by giving ourselves a little bit of space inside this function.

Now we're going to need to make a character map out of both of these things right here.

So the first thing I'm going to recommend is we don't really want to build two for loops to iterate

both through string A and string B instead.

A really easy way to save ourselves the pain of having to write two separate four loops to iterate through

each string right here would be to write a helper function to build a character map for us.

Now if you didn't make a helper function if you wrote out two character map assemblies inside this function

already that's totally fine.

But the interview setting interview is kind of like to see you create helper functions and it kind of

also allows you to better segregate or compartmentalize your code which is always helpful in sort of

an interview.

I have some other tips around creating helper functions that we'll talk about later on in the course.

They're actually kind of a great thing to keep in mind in an interview setting.

So let's first start off by making a helper function here.

And we're going to use this helper function to build a character map for a given string.

So we only have to write this logic one time and then we can use both on string A and string B will

say function build char map and we'll pass a string in to that function.

Then inside of here we'll create an empty object that will serve as our character map we'll then iterate

through our string and for every character inside there will add it to our character map.

Now one other thing to keep in mind is that we had said that our string needs to be only considering

lowercase characters and we also need to strip out any spaces or any punctuation.

So we certainly could do something like create a cleaned string ahead of time and do the Ragg X and

the two lowercase call right here.

But one easier way of doing it or maybe not easier but a slightly more compact way would be to tuck

that kind of Clean-Up logic directly into a for loop itself.

So let's look at what that might look like.

You could say let char of string dot replace.

So this is where we're going to do that replace in lower case logic logic just right here in line with

the for loop.

So we will replace forward slash square bracket.

Carit backslash W..

And then on the other side of the square brace we'll put a forward slash G.

So note that everything inside of your code editor should very likely turn into a slightly different

color when you've got this regular expression put together correctly.

So any time that we find a character that is not a number a character Kapell character or a lowercase

character we want to replace it with nothing or essentially an empty string after we've done that Clean-Up

logic.

Well then take the entire string and turn it to lower case like so you no open up our for loop.

Ok so now we're iterating only over the portions of the string that we really care about and remember

how we put our character maps together.

We take our character map we assign a key to the character map of the current character that we're looking

at and then we increment the value out that character.

So we'll say char map at char is char map at Char plus 1 and then we need to handle the case in which

this particular character has not yet been assigned to the character map.

So to say or one like so then very important.

I can't stress this enough because when you're in a high stress setting like interview or even when

you're practicing these problems yourself at home.

So easy to make tiny little mistakes so I I know it might be annoying for me to remind you all the time

to get the return statements in here but honestly you have no idea how often people just honestly forget

to put in a return statement so I will harp on that throughout the course.

I apologize if that is annoying.

OK so we've got our helper function here to build up our character map.

Now we can use it to produce a character map both string a and string B.

So let's declare a variable let's call it a char map will be build char map from string a and b Schar

map will be build char map from string B.

So we've now got these two character maps and it's now up to us to compare the two of them together.

The other thing that we still need to keep in mind is that kind of edge case that we mentioned at the

end the last video where if we only compare this object to this one we might miss out on some extra

entries inside the second one.

So I had mentioned that an easy way to solve this is to either compare the length of the two character

or the two strings.

If we do that do you remember that you would have to compare the length after subtracting out spaces

and punctuation.

So if you want to take that approach you can do the same kind of replace in two lowercase for both strings

up here and then compare the length of the two of them.

Another possible approach would be to look at the number of keys inside of both these maps and check

to see if they are identical in length.

So that is the approach that we're going to go with so we're going to pull out all the keys from both

these objects right here and we'll count the number of keys that is contained in both.

If you've never pulled out the number or the schism if you never pulled out the keys inside an object

before that's totally fine I'll show you how to do that.

Let's look at a quick example.

So if we have an object that would call just O.B. J.

And it has keys a b and c we can get a list of all the keys inside this object by calling object.

Notice that is a capital O object.

Keys will cast an object like so.

So that returns an array with all the keys from our object.

If we then call DOT length on that.

Well then we can very easily tell how many keys exist inside of our object.

And so this is the solution that we're going to use to address this problem of some extra character

existing in one character map or the other.

So we'll get the number of keys inside this character map the number of keys and this character map

and then can compare the two together.

So in practice will put a little if statement here will say if object we use for aid char map length

is not equal to object.

Keys for the char map length.

Well then we must know that we do not have an anagram because they have a different number of characters

or maybe a better way of putting that would be to say one character map has an extra character type

that the other one does not.

So if that's the case we'll just immediately return false from this function.

Now if they do have the same number of characters that we want to proceed with the map checking process

in which we will look at each one of these characters and compare the number of uses that it has to

the other map most part might sound like it's kind of challenging.

You know this I know that when I kind of see that with words you know I put it in a plain-English it

sounds like it's something is challenging but honestly I think you know how to do this I think this

is something that you definitely can do what we have to do here is to iterate over one char map look

at every character inside of it and then compare it to the other Charmel.

So we're going to iterate over a char map and really we could iterate over either one it doesn't really

matter here we just have to pick one.

In this case we'll iterate over a char map.

So save for let char and then don't forget here a little.

Gotcha.

And if we are iterating iterating over an array We use of.

But if we are iterating over an object we use in and remember that what's the term for it not anagram.

We're we're working at anagrams.

I know it's going to come to me.

The little trick for remembering which one to use.

If we are iterating over an object We use of which is really confusing because 0 starts where object

starts with oh so you would think that you would use of to iterate through an object but that's not

the case.

So for an object we use in which is kind of doesn't line up with the first letter in that word right

there.

I know that's probably an awful way of remembering but that's what I use.

So look through a char map and if a char map at char is not equal to the char map at char then something

must be wrong.

So let's say we're iterating through a char map and the first character that we look at is the letter

A.

We say how many times has a been used inside of HRO map if it has not been used the same number of times

and of the term map.

That means that something must be wrong or these two things do not line up at all.

So in that case we can't immediately return false

OK.

Now the last thing and again I know I'm harping on the return statements here but this is another very

easy one to forget.

Notice how we set up here inside the directions that we need to return true if they are anagrams and

false if they are not.

So we've handled the cases in which they are not anagrams by basically returning false.

And the thing that we cannot forget is that if we succeed in both these checks right here that means

that they must be anagrams.

And so in that case we should return true.

Like so.

OK so this is our solution this is solution number one for solving anagrams.

Let's check our tests.

It looks like they're all passing which is fantastic.

So I think that is going to work out just fine.

Now in the last video I had mentioned that this whole anagram question and the two solutions that we're

going to look at is kind of nice because it frames some later content that we're going to discuss in

the course.

So I want you to kind of look at this solution right here.

Very quickly when we look at it you'll notice that if we consider the number of times that we have to

iterate through either these streams right here we iterate through string a one time to build our character

map we iterate through string B one time to build our character map and then we iterate through one

character map to do the final comparison here.

And so I just want to very quickly point that out because we are going to come back to this question

or this solution right here later on in the course and I'm going to just kind of point out some interesting

things about the way that we solved this problem right here.

And the way in which we solve it in the next section because we are going to look at a second solution.

So if any minds let's pause right now we're going to continue the next video and we're going to look

at another way of solving this problem that is far far easier.

But it does run into some interesting issues that like I said we'll kind of consider later on in the

course.

So a quick break and we'll tackle that second solution in just a moment.
--------------------------------------------------------------------------------------------------------------

31. Another Way to Tackle Anagrams

All right.

Time for a solution or two to anagrams.

So this one's going to be a little bit more straightforward.

Well I should say a lot more straightforward but like I said at the end of the last video it will run

into some interesting performance concerns.

That is something that we're going to kind of use to frame another topic later on in the course.

So the first thing we're going to do is a little bit of clean up of our indexed not gigas file.

So I'm going to take both the anagrams function and the build char map function.

I'm going to highlight it all.

I'm going to cut it.

I'm going to move it to the bottom of the file and I'm going to comment both those functions out.

So I do want to keep these around just for record keeping.

Honestly it's for you for the future when you come back and review this stuff if you choose to.

But we'll keep it there.

And then we do need to redefine the function anagrams because we cut and pasted the entire thing.

So call string A and string B like so.

OK.

Seligson.

Now the second solution for handling anagrams.

Like I said is going to be a little bit more straightforward but like many many things that we've seen

inside this course it all depends upon knowing one little trick.

So let me show you a little trick.

It's going to flip on over here.

I'm going to make an array and then we're going to look at one specific method that exists on array

an array that will make solving these anagram things pretty straightforward.

So let's make an array of numbers and I'll give it about ten thirty five negative ninety one 10000 where

that is.

So here's the interesting function.

I want to show you where you look at numbers dot sort.

So when we sort in array it will take all the elements in the array.

And your javascript runtime will do its best to figure out how to somehow meaningfully sort the characters

or I should say the elements within that array now sort cannot only be used with numbers.

It can also be used with characters as well.

So if we had instead like Z c b d y and then we sort it we end up with alphabetical order.

And so this alphabetical order is what really forms the basis for this alternative solution to anagrams.

So here's we're going to do.

We're going to take our two inputs.

So in this case like maybe rail safety and fairy tales we're going to clean up both strings by replacing

or I should say removing any spaces or punctuation.

We're going to lowercase both strings and then here's the magic part.

We're going to sort both strings.

So when we sort both them no matter what characters we have inside they will end up in the exact same

order.

If the two sorted strings are then completely identical then we can say that we have an anagram and

so when you take this solution we you and I don't even have to do some four or Luper iteration or anything

like that to look at every single string.

We can just sort both these strings and then say that's it.

Compare the two.

We're done.

I think the best way of covering this solution will probably be to write out some code and then we can

copy that code over to this little editor over here and see it in play.

I think that will be the best way of handling this.

So let's get to it.

So again I'm going to make myself a little helper function to automatically kind of clean up each of

these strings.

So remember that kind of replace statement and the two lowercase statement.

And in this case doing the sorting of the string as well.

So I don't want to duplicate that logic inside of this anagrams function so I'll make a helper function

to do all that for us.

So don't I make helper function called Clean string.

It will be called with a string.

We're going to return the string.

We're going to replace and this will be our regular expression again.

So do forward slash square brace square bracket

carrot backslash W..

And then on the other side of the square bracket forward slash G and we'll put an empty string inside

there as a second argument.

Next we'll do a two lower case and now before we attempt to sort this thing remember we just looked

at the sort method that is a method that belongs to arrays not strings.

So we do have to temporarily turn this string into an array sort it and then turn it back into a string.

So we will split this thing on an empty string we'll sort it and then we will join it back together

into a string.

So that's a lot of statements chained together into one.

Remember when we consider chaining of methods in javascript we read it essentially from left to right.

So first we call replace then we call to lowercase on that then split then joint Simien then split then

sort then join.

I think maybe as a quick little test we should copy this over to that little code editor and just see

how this thing works.

So back over here I'll make a short string let's say Konst as TR is b c r c d do a real example.

Hello there.

So then if I paste that snippet.

So here is string replace to lower case all that stuff.

This is what we end up with right here.

So if we then consider some anagram like let's say string two and this one is there.

Hello.

So these two are clearly anagrams of each other.

Remember we are completely ignoring any punctuation.

And so if I then do string two and then that whole chain loops let's clean that up.

There we go.

So now I've got two strings I can very easily compared to each other and in this case you can see very

plainly.

Yeah they've got the same characters in the same order so they must be anagrams.

However if I start to add in characters to one of the other.

Well this is clearly no longer an anagram because these two sorted strings over here are no longer equal.

So now the last thing do is to figure out how to actually do that comparison between the two strings.

So again you might be thinking OK we have to loop through one string and we have to compare every character

to the other string.

Well no it's actually a lot more straightforward than that.

We will call clean string will pass in string a and then we're going to make it take advantage of the

equals equals equals operator.

So compared the cleaned up string a string the end if the two are absolutely identical.

Then we must have an anagram.

So essentially what we're doing with this line right here is to compare these two strings together.

So of course if we wrote out let's do this actual statement if we wrote out is that equal to that well

then we get true.

So that's essentially what we're taking advantage of here.

We don't have to compare this in character by character.

We're going to say hey is this string identical to this string.

Yes they are.

OK well then we must have an anagram.

And of course last thing never forget it.

Don't forget that return statement.

Most important part.

OK.

So this is the alternative solution.

You know this is another one where once you see the trick once you understand OK we can split it into

an array sorted and then join it back together and then compare the two results.

This is a real easy you know maybe relatively easy solution to remember probably a little bit easier

than remembering how to build a character map on the fly.

So yet again out of so many examples that we've already seen in this course and so many that we will

see as we go through.

Once you've done these problems one time you learn that little trick and you'll be able to solve it

more easily in the future on an interview.

Now very last thing I need to save this file and we'll check our tests.

So back at the terminal it looks like all six Tests are still passing here.

Fantastic.

Great.

So this has been the anagram problem again.

Very common one that I would really expect to see in an interview setting.

Let's take a break and we'll continue to our next question in the next section.
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================


Раздел 10:Sentence Capitalization

32. Understanding Capitalization

The last problem that we worked on was a little bit more challenging.

So in this section we're going to go live take a little bit of a breather with a slightly more easier

problem or at least one that is certainly short in nature.

Not many lines of code are required for this one.

So inside of my exercises folder I'll find the capitalize directory and open up the index file inside

there or then change on over to my terminal and I'll make sure that my tests are running over here by

running the command just capitalize test.

J.S. dash dash watch and we should see about three or four tests start to run.

So it like yeah three tests right here.

So let's look at this problem.

Now this one is a little bit more straightforward but I think that it's one that appears at first glance

to be very easy but in practice it does require at least a little bit of thought.

So the goal is to write a function that takes a string.

We want to capitalize the first letter of each word in that string and then return the capitalized version.

So for example a short sentence which is all lowercase should turn into Kapolei short with the last

sentence with the capital S..

So essentially just capitalize the first letter of each word.

That's pretty much it.

Like I said at first glance it looks really easy but once you start pulling together well it might get

a little bit more challenging.

Now I'll tell you right now that there are two distinct solutions that we're going to look at this problem.

The first one is going to will say that the first I'm thinking of them out of order here but I'll say

that the first one that we're going to look at is pretty concise.

It's rather few lines of code and it's rather easy to read.

But that solution requires a pretty good knowledge of the JavaScript standard library for working with

strings.

The second solution.

The second one that we're going to look at is kind of easy to reason about but it does require a kind

of nasty looking for loop and it's kind of hard to tell exactly what's going on with it by just looking

at the code.

So I'm telling you right now that you can either take a slightly easier to read solution by having a

good understanding of the JavaScript standard library or you can take a slightly more challenging to

read version that just kind of brute forces it and makes it happen.

So before I let you go I do want to give you a little tip or two on how to approach that kind of easier

to read solution.

And I want to point out to you a couple of methods that belong to the standard library that you might

want to be aware of.

So the first method that we're going to look at and again we are at the India and India documentation

page is the slice method belonging to all strings.

Remember slice can be used on a string.

It will take some number of elements out of that string.

The first argument is the index of that string to start from.

And then there is an optional second argument of the end index.

If you don't provide that second argument right there then the rest of the string is just automatically

included.

So where would this be useful.

Well let me show you a quick example of it.

Let's imagine that we have a word of simply there.

If we do we're slice with simply one.

It gives us everything after the T.

Now if we wanted to get just the t we can look out word at 0 and now the part that you really need to

be aware of.

Remember we have access to the to upper case function like so.

So very quickly I think you can see how we can take a lowercase word like this and start to capitalize

just the first letter.

So here is clearly a capital T.

Here's the rest of the word and I'm sure you can figure out how to join those two together.

So these two methods right here will lead you towards a rather straightforward solution.

Again this is not the only solution you can take a little bit more brute force one and this but certainly

give this a try.

So I'm going to let you kind of roam free on this one.

Give it a shot and I'll catch you in the next section and we will go through the first solution.

So quick break and I'll see in a minute.
-----------------------------------------------------------------------------------------------------------

33. Capitalization Solution #1

OK hopefully you had some success with this problem.

Like I said you might have found that it is a little bit more challenging than it appears at first glance.

However I do hope that you came together with a good solution in the section we're going to walk through

one possible solution very quickly.

We'll then take a look at an alternate solution in the next video as well.

So for this first solution let's look at some pseudo code that will kind of guide us in exactly what

we're going to do.

We're going to start off by making an empty array that we're going to call words.

This word's array is going to store the end result of the final kind of capitalized words that we are

dealing with after we create this.

Words.

Empty array.

We will then take the original string that was passed into our function and we'll split it by the space

character to get an array of words.

So each of those words are what we're going to try to capitalize.

We will then loop through that an array.

We will uppercase the first letter of each word.

We will then join that first letter that is now capitalized with the rest of the word.

And then we will push the result into that original words array that we created at the very beginning

after we loop through each word.

We will then join the words array together into a string and then we'll return it from the function.

So that's the general idea here.

Let's give it a shot.

Back inside my code editor I'll get myself a little bit of space.

We will declare an array of words that's going to start off as empty.

We will then loop through our string.

So we do need to split it by spaces.

Remember if you split by spaces we can do so by.

Let's say we have Konst sentence and our string is something like.

Hi there buddy.

We can call a sentence dot split and then rather than splitting on an empty string as we have done many

times in this course we will split by a space character instead.

And so now we're working with three individual words.

And that's what we want to do here.

So we're going to save for.

Let word of string dot split with a space.

So now whatever string gets passed in here assuming it is a sentence that is split by spaces they will

be split up by this split statement.

Next we will take the first character of each word so word at 0 and we will uppercase it by calling

two upper case then we will join it with the rest of the word and we can get the rest of the word so

everything minus that first character by using the slice function.

So we'll say word dot slice with one which means give me everything from the element at index 1.

So that's not the first element that's the second element.

Everything from index 1 onto the last character in the word.

So we're going to join us to get two together and then we will push the result into our words array.

So I'll say words.

Push and push the results into that.

Then finally at the very bottom after we have iterated through all these different words we will take

that word's array we will join them together with the space character.

So note that again this is not an empty string.

Here we are joining all of these different words together with the space character.

We will make sure that we return the result.

So let's see how we're doing.

OK.

Three-Test passing looks good to me.

OK.

So like I said this is the easier I think or maybe the more direct easier to read solution of the two.

Let's take a pause.

We're going to come back in the next video and we're going to look at another solution that is just

a little bit more effort goes into it.

But it's one that I think is much more easier to arrive at or I think that one it's easier to kind of

picture the other solution.

It is harder to code.

That's what I mean to say.

So let's take a quick break and then attempt that solution in the next video.
---------------------------------------------------------------------------------------------------------------

34. How Else Can We Capitalize?

In this video we're going to take another look at the capitalized function and come up with a slightly

different solution.

So as usual I am going to back up my result here by copying it down to the bottom of the file and commenting

it out.

I will then clear out the contents of the capitalized function like so.

All right let's look at a diagram that's going to help us understand this alternative solution.

So here we go.

Cascio here's a serious sequence of actions this time around.

We're going to start off by creating an empty string called result.

So notice that in this case we're creating an empty string not an array.

We are then going to iterate through every character in the string for each character.

We will look at it and we'll say in the character to the left of the current one.

So whatever still left is that a space if it is a space then we're going to take the current character

that we are iterating over.

We'll capitalize it and we'll add it to the original result string.

Otherwise if it is not a space to the left of the current one then we'll just simply take the character

and added to result without capitalizing it.

So essentially we can imagine a string.

Say hi there.

When we look we iterate through this thing and let's say we look at the character eye right here.

We'll look at the character to the left of it.

That's an H.

It is not a space.

So we're going to say no problem.

Just add in to the result string.

We'll then move onto the space.

We don't care about the fact that this thing is a space.

We're going to look to the left of it see that there is an eye there and we'll say OK that's an eye.

We don't need to worry about it.

So we'll take this character and add it into result then we'll move on to t with t look to the left.

We'll see.

Oh you know what that is a space.

So we're going to capitalize T and then add it into the result string.

Now this solution right here has one very big weakness to it.

One very big weakness.

I'm going to ask you if you can kind of find it right now based on a description I just gave you.

The problem with this solution is that it doesn't work well with the very first character.

So when we are capitalizing a sentence the very first character should always be capitalized.

So if we try to look to the left of the first character well there's nothing to the left and so we will

never attempt to capitalize it even though it absolutely should.

So 8 easy way to solve this is to say that when we create this initial string result rather than creating

it as an empty string we should create result which is the first character of the input string capitalized.

So that's how we're going to get around that little limitation when we create this first result string

the very the only content it's going to have will be this first character or just going to immediately

capitalize it.

Then when we start to iterate through the rest of this array of characters here we'll start with the

first character or I should say the character at index 1.

The second element and consider everything from here moving forward.

So the downside to this approach is that it will require a manual for loop.

We cannot use a for loop in this case because a for loop is always going to attempt to iterate through

every character.

And in this case we don't want to iterate through every character we want to skip that first one.

So little bit of a downside here.

But such as the way.

All right.

So let's give this a shot.

Back over my code editor will first declare this starting string that we're going to call result.

So say let result and it's going to take the first character out of string and automatically capitalize

it because that first character we always want to capitalize.

So we'll say string at zero dot to uppercase like so.

Now we can iterate from one to the length of the string.

And for every character will look to the left of it and decide whether or not we need to care to capitalize

the current character.

So we'll say four letters.

I equals one.

I less than string dot length plus plus.

Now we'll look to the left.

We'll say if at string I minus 1.

So this is to the left of the current character.

If that thing is a space then I want to take the current character that we're looking at.

I want to uppercase it.

We have two upper case with a capital C and then I'm going to add that on to the result string by saying

result plus equals like so.

If the character to the left of the current character is not a space well in that case we want to just

add it on to the results string by saying string as I like so.

And now if you look very carefully at my function I'm missing the most important parts.

The return statement down at the bottom don't forget it.

So will return results.

All right let's look at our terminals.

Our tests are doing looks good to me.

So yeah this looks like a reasonable solution here this solution.

I'm not super happy with personally because it is kind of weak against you know assuming that that first

character always needs to be capitalized.

You know what if for some crazy reason we are attempting to capitalize a Spanish string or something

like that.

You know I say Spanish because they've got you when they do a interrogative sentence they start off

with a question mark like you ok tall like so.

So clearly in this case that first character we wouldn't really want to capitalized because it is a

question mark so you know but hey I'm not I don't think we can really clear claim that this solution

would address that as well.

I guess I'm just not super happy having this thing being hardcoded to always catalyze the first character.

I don't know just kind of natural engineering judgment.

I feel like it's a little bit off anyways.

At the end of the day I would still claim that this solution is harder to take a glance at and really

understand what's going on.

I think that the solution right here.

The first thing we worked on is very legible and I think that it would be pretty reasonable to hand

this solution to an engineer.

Ask them what is going on.

And I think they'd be able to give you a reasonable answer as to what's happening here and I don't think

that's really the case with the solution up here.

But hey to each their own.

OK.

So that's their solution to the capitalized sentence function.

Let's continue with our next example in the next section.
----------------------------------------------------------------------------------------------------------
==========================================================================================================

Раздел 11:Printing Steps

35. The Steps Question

I'm really excited for this next problem because the next problem we're going to work on is very closely

related to the one after that.

So we're going to have two questions in a row that are extremely closely related.

The first version is going to be kind of a easier version of the problem and then the second one is

definitely much more challenging in my opinion.

So we'll get kind of like the warm up and then the real deal immediately after that.

Now even the warm up is still kind of a hard problem and it is also definitely a problem that I think

is very common to see our interviews.

So they're both very useful but it's going to kind of prep us for the tougher ones.

So I think it will be a nice little build up.

So inside my code editor I'm going to find the steps folder and then I'll open up the index file inside

there.

And I think you know exactly what else we need to do.

We'll start up our test with steps test Scott J J.S. dash dash watch lifeso and we should see a number

of tests running in this case about four by the way just to clarify the reason I always point out the

number of tests is just to help you make sure you don't make a typo in like you know the test file name.

If I do a step slash test dodgiest then it's going to say Oh hey I can't find any tests to see you know

that's why I always happen to mention that.

Anyways let's take a look at this problem.

So the directions are to write a function which is kind of already done for us that take an argument

of a positive number.

Or in this case really an integer n so some positive number the function should then cancel log.

So key statement there we need to console log a step shape whatever that is with and levels using the

pound character.

So in practice you know the directions are kind of hard to read.

It's a lot easier to just look at the examples right here.

Basically is what we want to do.

So if we call steps with two I want to see like pounde and then on the next line pound pound and so

they're supposed to kind of form a visual staircase you know where the steps are the actual pound symbols

here.

That staircase is a little bit more evident on some of these larger number ones down here so like you

know first step second step third step fourth step the number just to be clear is the number of lines

that we want to log.

So we pass into I want to see two lines of steps we pass and three we've got step one step two step

three.

The other thing that is extremely important and the other thing that makes this problem a little bit

more challenging is the fact that we if we have like just one step right here out of two total there

has to be a space character to the right of it.

See there's a space character right here with Steps 3.

We should have a pounds and then one space and then two space.

So you can very easily kind of quickly realize that the number of characters in the strings is always

going to be square.

So we've got three console logs down for end of three and we have three characters from left to right.

So character one character or two in character three that's really important.

Don't forget that if you only log out just the bare minimum here of just the pound symbols the tests

are going to fail so the tests specifically want to see the correct number of empty spaces to the right

hand side.

And that was important because like I said the next problem that we're going to work on is very closely

related.

And the next problem is going to kind of build on this idea of making sure that you actually print out

your steps here.

So make sure you do that.

OK.

So that's the problem.

In this case I think that this is one that really just requires a little bit of thought on your end.

So there's not necessarily any big tips I want to give you ahead of time.

I'm going to I'm just going to let you give this one a stab.

Remember that much earlier in the course we walk through the technique of placing a debugger statement

so that you can kind of work with your code and see what it's doing.

And remember the directions for that are in the diagrams for this course.

This is a problem where I very highly recommend you use that debugger technique if you get stuck because

it's going to be really easier to help you figure out exactly what's going on as you run through your

code.

So let's take a break here.

Give it the best shot you can.

Remember if you get stuck.

Don't sweat it.

Just go solution Watch a minor to the solution and then take another stab at it on your own.

So quick break and we'll go over the solution in the next video.
--------------------------------------------------------------------------------------------------------------

36. Steps Solution #1

All right hopefully you had some success with this exercise.

One quick thing that I want to mention here is that the intent was that you should be making multiple

console log statement calls.

So we are not assembling one string and then escaping it with like a newline character at the end.

We are making multiple strings and cancel logging each of them.

When I say multiple strings I mean one string for each kind of set of steps here or each level to the

staircase.

So if you saw some error message saying Hey I expected you to call stairs more often or something like

that that's probably why you were seeing the message.

Make sure you are logging each independent level.

OK.

So in this section we're going to go through one possible solution.

I think that this is definitely the easier to come up with solution that we're going to go through first

after we look at this solution.

We'll then take a look at an alternate way of solving this by using a little bit of recursion.

I think that the recursion solution here is ultimately maybe a little bit easier to come up with and

put together.

However it does require to kind of use your recursion skills to think of which is definitely quite challenging.

So anyways we'll do the iterative solution first and then take a look at the recursive solution.

So let's look at a diagram that's going to help us understand this iterative solution.

So the first thing to recognize here is that we are kind of dealing with a matrix of sorts or kind of

like a to d array.

We're not really working with the race here.

We're always working with strings.

That's what we are assembling.

But it's helpful to just kind of think of it in terms of like indices.

It's going to make it a lot easier to come up with the actual solution.

So here's the idea.

First we want to recognize that we're going to have some number of columns in the rows that we want

to iterate through.

So this would be row one right here and then row 2 and row 3 and then we are also kind of going to want

to iterate through some number of columns so call them 1 call 2 and column 3.

I came up with the nomenclature saying that we will reflect the current row that we are iterating through

with a variable that we're going to call I.

And then the current column with a variable that we're going to call J.

One very easy way to make your solution look much more straightforward and you what I think that we'll

probably end up doing this rather than calling is i and j.

Because that's kind of tough to remember.

Let's call this like row and column that makes life a little bit easier.

I think that's going to be a little bit better.

OK.

So then mind let's take a look at exactly how we're going to do this.

First we're going to write a for loop the first for loop that we're going to write is going to iterate

through all the different rows that we have.

We're going to iterate from 0 to N and we'll call this you know we'll say specifically iterate through

rows then for each row that we are considering.

So let's imagine this particular row right here.

We are going to start off by creating an empty string that we'll call stare.

Now Syria is meant to be singular like just stared by itself to indicate that this is one individual

row that we're looking at.

Then we're going to iterate from 0 to and again in this case this second for loop right here is meant

to iterate through all of our different columns.

So from left over to right then inside this inner loop will say if the current column that we are looking

at is equal to or less than the current row we want to add a pound.

So this is kind of like the big jump in logic right here.

This is kind of tough part is this if statement.

So I want you to look very carefully at this thing right here.

We have columns 0 then column 1 column 2.

Let's add a little bit of numbers on here just to make that all that easier.

So do a copy so we'll say see 0 meaning column zero.

I'll put that right here and then we'll put rows 0 right there and then I'll just do two others with

this nomenclature we'll put our one right here.

We'll put still sees zero right here because we're still in column 0 and then just one more we'll put

Rozier show over here and see one right here.

So when you start working on these problems where you are kind of iterating through two sets of rows

and columns especially I honestly I want to use more generic terms but any time instructing in terms

of row and column you want to start seeing if you can see a pattern of any sort here.

And so if I start thinking about a pattern between which of these squares or which these characters

are supposed to have pound which are supposed to have a space.

The first thing they start to notice is that we want to have a pound.

If C has a value that is equal to or less than R and we can see that in a very quick action here.

So C is equal to our.

So we get a pound.

In this case C is less than our So we get a pound.

But over here C is greater I said poun excuse me C is greater than our row.

So we get a space instead and that's the pattern that we're following all throughout this thing.

So even when we start going down to the very bottom right corner down here.

So down here we would be working with column two and road 2 right here.

So still we are less than or equal to the row count.

So we're still going to get a pound down here.

So that's basically the row that we're going or the rule excuse me that we're going to use if we do

not meet this if statement right here.

Dan Rather than adding a pound we must be on this kind of upper right hand triangular section up here

in which case we want to add a space rather than a pound and the last kind of Keats.

The problem here is that after running through this for loop where we iterate through all the different

columns we will take that stair or that kind of row representation of this one line that we have and

we will con. log it.

Then we go through the next iteration or move onto the next row we're going to read it clear that Stehr

variable as a new empty string.

So that's very much the solution.

Again this is just one possible solution.

There's definitely more than one way of doing this but I think that this is a relatively straightforward

way of doing it.

So let's take a quick break right now.

We'll continue the next section l put together the implementation for this solution.
------------------------------------------------------------------------------------------------------------

37. Steps Solution #1 Continued

In the last section we looked at one possible solution to the steps problem and this section we're going

to start to code up.

We'll get through this solution pretty quickly and then we'll move on to an alternative solution that

I think is a little bit more interesting in the next section.

So let's get through this one.

Now I want to use the steps that I've written out over here so we can very easily read through them

as we put together the solution.

So I going to kind of place my Windows ever so slightly so you can see both them at the same time throughout

this course.

You've seen me put together several diagrams like this that kind of use pseudo code to walk through

a solution.

I hope that you're definitely getting a sense of how you might put these together yourself in an interview

setting.

Anytime you're in an interview setting especially at a white board I highly highly recommend.

I can't say enough.

I highly recommend you try to write out a possible solution with pseudo code or like basically plain

English before attempting to code it on the white board.

When you use pseudo code pseudo code to outline your solution it's going to more easily communicate

what you're trying to do to your interviewer and your interviewer might be able to help you catch errors

rather than if you went straight into a code solution and they're both helping you try to catch errors

but also understand what the heck you're trying to write with code.

So in general I highly recommend you try writing out a pseudo code solution.

All right let's give this a shot.

So we're going to start off first by iterating from 0 to N and this is intended to be the current row

that we are operating on where row is like one string set OK.

So we'll say four let row equals zero row less than an ROE plus plus.

And then inside of here for every different row that we are going to operate on we're going to create

a completely empty string.

A brand new string that we're going to call stare.

Now we could call Stehr anything else.

Honestly I just you know maybe you would be better to call it step or something.

I thought Sarah was still reasonably related to the problem but different enough from the function name

of steps like steps and step there a little bit too close.

So I would definitely not you step personally so we'll say let's stare because going to be an empty

string.

Next we're going to iterate from zero to N and this is intended to be our iteration through all the

different columns that we're going to work on.

So for left column starting at zero column less than n column plus plus.

So for each column we're going to write an IF statement we're going to say if the current column that

we're looking at is equal to or less than the current row.

So if the current column is less than or equal to the current row then we want to add a pound symbol

to the stair string.

So we'll say stair plus equals pound.

If column is not less than or equal to RHO then we're going to instead add a space.

So else stare plus equals space and make sure you have a space here not an empty string.

It is supposed to be a space.

Make sure you have a character inside there.

Finally after we process one entire row.

So this is the row processing step right here we have processed the entire row.

We have now assembled a full stair string.

We need to make sure that we can still log it it's console log Stehr make sure that you are logging

Stehr still inside of the road for a loop because we want to end up with an number of console logs like

in the case of passing and for here we want to end up with four console logs.

So I don't want to put the console log at the very bottom of the function.

I want to still be inside of my for a loop so that I get one console log for each row that we are attempting

to assemble here.

OK.

So this looks good.

Let's save this we'll run our tests and see how we're doing.

So back over here in my terminal you can see that we got a lot of the console logs from the testing

code and I've got four test passing which definitely makes me feel like we've got the right solution.

So this is looking pretty good.

This is one possible solution.

If you are in an interview setting this is probably a type of solution.

I recommend you go for.

It's very easy to reason about.

It's easy to troubleshoot.

Pretty reasonable.

Having said that we are going to look at an alternate solution in the next section that uses a little

bit of recursion.

This next solution is going to be a little bit more tricky and just because it is tricky I generally

recommend not going straight to the solution.

In an interview setting unless you are specifically asked for a recursion solution nonetheless we haven't

spoken a lot about recursion yet inside this course.

And so this is going to be our first good taste of recursion which is a topic that we'll be discussing

a pretty good amount throughout the course as well.

So let's take a quick pause and then start to tackle that second solution in the next video.
---------------------------------------------------------------------------------------------------------------

38. Step Up Your Steps Game
In the last section we looked at an iterative solution to the steps problem in this section.

We're now going to continue by looking at a recursive solution to this.

Now if you're here in this course and you're preparing for a professional javascript interview I am

going to assume that you have seen recursion before at least once.

Nonetheless we will do a very quick review just to make sure that we are on the same page.

Well then look at a couple of general tips around recursion and then we'll come back to this problem

and figure out how to tackle it.

So let's do a quick review first with recursion.

We always start off with some type of function.

So let's imagine we've got a function called about print number about that.

Let's imagine that we want to make a recursive function called Print number.

We should be able to pass this function a number and it will print from that number down to zero.

So we'll assume that we always pass the thing a positive number.

Let's write out an example of that.

So let's pass it like the number 10.

So I'll say that to succeed in this problem.

I want to see a console log from 10 all the way down to 1 or 0 1 and the other.

And the first thing that we always do with a recursive solution is to identify what is called a base

case the base case is the case in which we decide there is no more work for us to do.

And it's time to return and stop the recursion process.

And so without even thinking about the term base case or anything like that.

Think back to the description of this function I just gave you two seconds ago I said we want to print

from whatever number is passed all the way down to zero and then at zero we stop and we do no more work.

So to think of a base case in this situation I would say that if the number that is being passed to

this function right here is equal to zero.

That means there is nothing else we need to do.

We have hit the base case and we want to stop recursion.

So let's write that in here.

Let's imagine that print number gets called with some number and as an argument we will check to see

if n is equal to zero.

And if an is equal to zero then we are going to return and we're going to do no more work during the

recursion process.

Nailing your base case like this is one thing that is absolutely critical during the recursion process.

I really encourage you to spend a lot of time in general thinking about your base case.

It's way too often that people start to think about the base case only at the end.

And if you think about the base case only at the end Well usually it means that if you try running your

function before then you'll end up in a infinite recursive solution which is always nasty to try to

debug.

So we start thinking about your base case from the get go after checking to see if we've met the base

case.

We will then do some amount of work and then call our function again.

So in this case the work that we want to do is to print out the current number.

And so I'm going to print out with a log.

And then the last thing to do is to call our function again when we call the function again.

It's extremely critical to make sure that we have changed the arguments in some fashion.

If we call print number again with an We're going to immediately and are seemy we're going to enter

an infinite loop because we have not changed the arguments and the exact same code path will occur.

So I'm going to be 100 percent sure that I would to change the arguments they're going to call print

number with here.

I'm going to make sure that the change that I'm making will somehow eventually get r r and number here

down to zero.

So specifically I mean to say I want to make sure I subtract 1 or subtract some type and number.

OK.

So when we call print number again and this of course right here is the actual recursive step because

we are calling the function that defines that this function call is defined in again then we see our

numbers printed out here.

Now you will notice that you see two if you're using this tool or if you're just looking at my screen

you'll notice that we get two sets of prints from 10 down to 1.

That's just because of the way that this tool right here behaves.

The code that we have is 100 percent correct as just because the way that this tool works to make stuff

print out nicely that you see the log out here twice.

OK.

So what are some takeaways that you can immediately notice about recursion from this process right here.

Here they are.

So the first thing that we really want to do is to identify the bare minimum pieces of information that

represent what we are trying to accomplish.

So in this case the bare minimum of minimum piece of information that we want to pass from loop to loop

or from I should say call to call a recursive function is the current counter.

I did not pass along some extra piece of information like what the number was the last time it was called

or some object that we're not doing anything with.

I identified just the bare minimum information that was needed to call our function again and progressed

towards our base case.

The next thing to keep month recursion is to always give yourself some reasonable defaults to those

minimum pieces of information.

So in this particular case we had said that we were going to provide the number and then always subtract

1 to get towards our base case right here.

But let's imagine that maybe we had said well maybe an additional requirement of the print number function

was that it should be to be called with some number to decrease and by each time.

So in other words maybe we don't want to always decrease by 1.

Maybe we want to decrease by some other argument here that you know me we'll call mentor or something

like that.

So this second step right here giving reasonable defaults make sure that if there are any optional inputs

you give some reasonable default input to them.

So in this case I would want to maybe default the value of deck to be one.

And then I could very safely use it down here.

Print number and even if someone didn't pass in that debt variable or the deck value.

I've got some reasonable default to make sure they don't accidentally fall into some infinite recursion

situation right here.

For example I can very easily show you if I were to I'm not going to because my browser would lock up

but if I were to delete this declaration right here of deck or if I were to not default it to be one

then every single time we called Print number we would take an minus deck.

Deck would be undefined.

If I didn't defaulted to be one and would we would then call print number again and would probably be

like not a number or something like that.

And so we would never hit the case where an equal zero in return.

So make sure you have some reasonable default in here to safely handle your recursion.

The next thing to do during the recursion process always remember to check that base case inside the

base case you want to see is there anything left for us to do.

If there's no work that's it we're done.

OK.

Don't color function anymore and return if we do not meet the base case then we want to make sure that

we actually do some work.

We call the function again and when ever we call the function again this is a really important part

when ever we call the function again we want to make sure that we have changed our arguments in some

fashion.

The arguments have to change if they don't change.

That means that we're very likely going to end up in an infinite recursive solution which is again something

we don't want to deal with.

OK.

So with all this in mind let's take a quick pause.

We're going to come back to the next section and we're going to apply these rules right here to the

steps problem and we're going to come up with a recursive solution.

So quick break and I'll see you in just a minute.
---------------------------------------------------------------------------------------------------------------

39. More on Steps
In the last section we got a very quick review of recursion.

Let's now take some of these lessons right here and apply them to the steps problem at hand.

So I've taken one of the diagrams we were looking at previously and I pulled out some very interesting

pieces of information.

My goal here was to identify the base case and I also wanted to identify the remember bare minimum pieces

of information that represent our problem.

So let's take a look at some of these different notes that I made right here.

OK.

So the first big note right here is our base case.

So if we imagine that we still have some row counter that we're going to pass during each recursion

step then if we increment row each time we kind of progress down here when ever row is equal to N and

member and was deciding how many steps we have in total then that means that we have hit the end of

our problem.

So this was something that we noticed with our Interesse solution as well.

Remember we had the for loop where we iterated from an up to or something from 0 up to N and as soon

as we hit that we said okay that's it.

No more work for us to do.

So essentially I think that our base case here is to say if we have some row piece of information that

is being incremented from 0 to 1 to 2 and eventually to 3 as soon as we hit 3 that means nothing else

for us to do.

Now the next kind of interesting note that I made about our interim solution here was I noticed that

the stair string remember the stairs string kind of represented a row and all the elements within that

row.

If that row has a length of N So RHO means length of and or a stair string has a length of.

And it means that we are at the very end of the row and we are ready to print or do console log out

that row.

So if we have a string with one element to element 3 element inside of it three is equal to and equals

three.

That means that the stair string is ready to be printed.

Now the last very important note here is that if the length of the stair string so if the length of

the string that is being used to generate or it's that string is being used to represent the row here

has a length that is equal to or less than the current row that we are working on.

Then we want to add in a pound.

Otherwise we're going to put in the space.

We saw this exact same thing just a moment ago when we were looking at our iterative solution.

So remember back over here we had said that we had that inner for loop we had the inner for loop that

iterated through our list of columns and if the column counter that we had inside there was less than

or equal to the row counter then we would use a pound sign.

Otherwise we would use a space.

The interesting thing about this solution right here is that you can kind of very quickly tell that

this for loop right here.

It was made to iterate from 0 to an but we actually have another piece of information inside of that

interim solution that mirrors or kind of encodes that exact same counter the length of the stair string

right here the length of it was always equal to the current count column that we were iterating over.

So back here we were looking at the column counter to decide whether or not we wanted to use a pound

or a space but for our recursive solution we're going to instead look at these stair string to decide

whether or not we want a pound or a space.

OK.

So these are the three big things that are going to help us put together our recursive solution.

So we're now going to flip back over to our code editor and we're going to put this thing together.

Now as we write the code for this we're going to kind of speed through the implementation because honestly

writing out recursive stuff is challenging to explain to say the least.

So it's more important that you understand these kind of base cases right here and that you get a sense

of how to kind of discover these on your own once you can think of your base case life gets a lot easier

and you can start to put together this implementation.

So anyways let's just put this thing together and see what it looks like.

So back inside my code editor I'm going to take my whole steps function I'm going to copy it.

I'm going to put it down at the bottom the file and comment it out again just so I have a nice little

backup then scroll back up I'm going to clean out the steps function.

So it's now empty.

All right.

So the first thing we're going to do here is we're going to define our base case and we're going to

check to see if the base case is satisfied and if it is we will return.

So I'm going to check to see if n is equal to Roe and if it is I'm going to immediately return now.

Right away you'll notice that there's no variable inside of your called row.

So let's say that every single time that we call the steps function one very important piece of information

that we always want to pass along to every function call it steps is the current row that we are operating

on.

So as an argument to the steps function I'm going to add in row now the first time that steps gets called

we can assume that we called like that steps of three.

Remember that is exactly what the directions up here said it said Write a function that accepts a positive

number.

And so I'm kind of arbitrarily deciding that there is an additional argument I want to add into this

function call.

Now just like we saw a moment ago over in the code editor over here we need to make sure that if row

is for some reason not defined in our function call we need to give it some default argument.

Otherwise we might get some really unexpected behavior.

So to handle it first time that steps is called Where presumably Roe will not be passed along.

I'm going to default the value of row to zero.

So this means right here I want to start on the very first row where the top row of our problem.

OK.

The next thing that we're going to do is we're going to examine our second case.

The second important note here this one right here we're going to write in some code that checks to

see if the length of the stair string is equal to a length and be equal to the variable and if it is

then that means that we are at the end of the row and we should probably print out the stair string.

So the next thing we'll do back over here we're going to check to see if an is equal to stare length.

And if it is then we need to assume that we are at the end of this particular row.

And we should print out the stair variable.

Now again you will notice that we have not yet defined stare.

So satyr is another piece of information that I really think that we need to share in between function

calls.

So as an additional argument I will assume that we are going to call this thing with a stare argument

and I'm going to give it an initial default value of an empty string.

So by default nothing is nothing is inside of stair.

Now the only thing we have to take care of now is figuring out how exactly we are going to decide to

call steps again in the future and how we are going to make changes to stare and row.

So at some point in time we need to increment row right here.

And at some point time we need to add a character onto stair.

I can ask you a question here.

When do you think we need to increment row row needs to be incremented when we hit the end of a row

like when we have completed a stair and we just wrote an if statement for that right here.

So when ever we have hit the end of a row we're going to cancel log out stare and then we're going to

call steps again but this time around we're going to increment the value of rho.

So after we hit the end of the stair we'll console log stair and then we'll call steps still with N

but with RHO plus 1.

Now you'll notice that I'm not going to provide a third argument here because when we move on to the

next row I want to use an empty stare again and song and rely upon the fact that we are using a default

Stehr value of empty string here.

I could very much just as well do something like this.

You know I could pass an empty string manually but it's not necessarily necessary because we've already

got this default value set up here.

Now the other thing to keep in mind is that if we hit the end of the row as indicated by this if statement

and we Consolo this thing and we call steps again we don't want to do anything else inside this function.

So if we meet this case right here there's nothing else we want to do.

So when I call steps right here I'm going to make sure that I just return right away.

Now we don't necessarily have to return the value of steps that's not necessary.

You know if we wanted to we could put return down on the next statement because we are not returning

anything here per se.

I just want to point that out.

Not really important either way.

Just one thing to keep in mind.

OK so we've handled the case that we have completed all of our work.

We've handled the case where we've hit the end of a row.

The last thing we have to do is handle the case in which we are still assembling our stair string and

remember the big thing to keep in mind for that was that if the length of the stair string is less than

or equal to the row that we are currently working on we're going to add a pound.

Otherwise we're going to add the space.

So for that we can add in a little if statement will say if stair length is less than or equal to Roe

then we want to add a pound onto stair so we can say stair plus equals pound.

Otherwise we want to add a space like so now the very last thing keep in mind here the last line of

code we need to write.

Notice how the only points and right now that we do any type of recursion is if we've hit the end of

a row but we still need to make sure that we recurse through a row as well.

So after we have appended on some character to the stair string We then need to call steps again and

that's going to start the entire process over again.

So after we do that statement we will again call steps we'll pass and we'll pass and row and notice

that we are not going to change the value of Roe here because we are still working on the same row.

And the last thing we'll do is pass and stare.

Okay.

So I know this has been a little bit complicated but I think that if you really think through these

steps they make a lot of sense.

The problem with recursion is that arriving at which steps to put together is really challenging.

You know this is the kind of thing where you when you see the solution you can go like oh that makes

sense.

But before you see it it's the hardest thing in the world.

And that's why recursion is kind of the story is difficult to pick up.

All right let's do one last run through here.

So the first some we call steps and I'm going to move steps 3 up here by the way make sure you get rid

of that don't want to throw off any tests.

So make sure you dump that statement.

So the first steps we're going to have and of like 1 2 three four 5 whatever it might be will have a

roll of zero.

We'll have a stair of empty string.

So a 0 0 empty string is an equal zero.

No it's not because and is equal to 1 2 or 3 or whatever is an equal to stared at length.

No it's not because there is still an empty string.

OK.

Well don't go down here is stared at length less than RHO will start at length zero RHO is equal to

zero.

So yes it is equal to or less than.

So we're going to add a pound to stare.

We then call steps again.

So we go back up to the top again we have and of one two or three whatever it is we have a row of still

zero.

But now Stehr is a pound.

This case doesn't apply.

This case doesn't apply.

We hit here again Stehr Now now has a length of 1 1 is not less than or equal to Rho.

So we fall into this case here.

We add on a space to stare and then we call steps again.

So at this point in time Stehr is now equal to pound space RHO is still equal to zero and is still equal

to 1 2 or 3 or whatever.

So this no longer not not relevant not relevant.

We hit here again stared at length will be too.

So we fall into adding a space again we call steps again.

We now add on an additional space and this is the last step we'll go through right now.

We call steps again.

We have let's say three in this case RHO is still zero Stehr is now pounde space space.

We checked to see if and is equal to a row.

No it's not.

We checked to see if N which is three is equal to stared length which is three.

Yes it is.

OK.

So we console log out stare.

We then return from this function.

So we do no other work inside of here.

We call steps again but this time steps is now have steps of an equal to three and RHO is now moved

on to one.

The entire process repeats until we hit this case again and then eventually RHO is incremented up to

three.

We checked to see if any is equal to three.

It is.

And so we return here.

All right.

So that's a full run through.

Yeah recursion is real nasty.

Like I said earlier my big tip to you.

In an interview setting if you get asked anything about recursion try to put together the solution first

and then look to refactor it over to recursion it will make your life easier.

In fact when I put together this recursive step solution right here that's exactly what I did.

I put together this eritis solution.

I looked at which variables were changing and then I realized OK like we can probably do at x y z and

I identified that base case and it made life a lot easier.

If you asked me to put together this recursive solution from the get go yeah I would have a tough time.

Probably like most other people in the world.

So I really recommend if possible you try the solution first just to get your mind in the right place

and then go to the recursive solution.

Now lesing I want to mention here.

Completely optional.

But if you wanted to we could definitely shorten this statement down here with a little bit of a turner

expression.

So this is totally optional.

This is 100 percent equivalent syntax spital just kind of condensed down our solution.

We could say something like Konst add equals square dot length less than three goals to row.

And then if this expression right here is true we would assign a pound to add.

Otherwise we would assign an empty string to add and then when we call steps we would pass and stare

Plus at.

So in this case add a short for like character to add.

OK.

So I think that's the only factor that I kind of want to do here to shorten things up.

And of course I bet we could maybe shorten up one or two things here beyond this but I'll leave that

up to you.

OK.

So that's pretty much it.

That is our recursive solution.

We will look at recursive recursion again in this course several times.

Again I can't say enough.

It's one of those things where you just have to see it many many times before you start to get a feeling

for yourself.

Now I did forget to do one thing.

I'm going to check my tests.

Yeah they're still passing.

So we're all good there.

OK.

So I think that's enough on recursion.

Let's take a break and continue on to our next problem in the next section.
------------------------------------------------------------------------------------------------------------
============================================================================================================

Раздел 12:Two Sided Steps - Pyramids

40. Pyramids Vs Steps

The next problem that we're going to work on is going to build directly off the steps problem.

So we're going to take care of it right now while we still have the steps problem fresh in our mind

inside of my exercises directory.

I'll find the pyramid folder and then open up the index file and then of course will also start up our

tests as well.

So at the command line just a pyramid pyramid test Geass dash dash watch.

And let's see how many tests we have.

All right.

So now you got about four tests running.

All right let's take a look at this.

So we're supposed to write a function that accepts a positive number and the function should cancel

log a pyramid shape with an levels using the pound character.

Make sure the pyramid has spaces on both the left and right hand sides.

So this looks very similar to the problem we just worked on the steps one.

However now it's not only one side that we want to put these kind of spaces on both sides.

So we are now forming a pyramid shape.

So definitely you can very quickly see why this is very much so similar to the problem with it we just

worked on the steps one.

So methodology will be very similar but now it's going to be up to you to kind of figure out some very

interesting edge cases around this one.

So I'm going to give you a little bit of a head start here.

Beyond the fact you know saying obviously go back and look at the code from the steps problem we're

going to look at a diagram that's going to kind of help you focus in on a couple of different areas.

So we looked at one diagram very similar to this for the step problem.

This time around I've kind of removed some information and changed some stuff around to accommodate

the differences for pyramid.

So I think that the general algorithm that we used for the solution for steps is still going to work

here.

So I think that we should still iterate from 0 to n so and here being the total number of rows that

we have.

So we'll start off at 0 1 2.

Then for each of those rows I think we'll still create an empty string.

But now things start to get really interesting is that inner for loop.

So we're going to iterate from 0 2.

I don't know if you're going to have to figure that part out.

That's going to be one of the challenges here.

In addition once you figure out exactly what balance you want to iterate to for that inner for loop

you are also going to have to do some very interesting logic to decide whether or not the given column

should have a pound.

So remember previously it was a pretty easy determination for us before when we were doing the steps

we said if the current column is equal to or less than the current row yes we want a pound.

So this time around it's going to be a little bit more involved than that.

I'm going to leave it up to you to figure out exactly how to do it.

One tip that I will give you just so you are aware that this exists.

And I really want to just give you a quick example of it.

Remember that math floor is a function.

So if you use math floor it will take a decimal number and it will rounded down to the nearest integer.

In this case 5.

So I don't know maybe they'll be helpful for you depending on how you tackle this.

Maybe it won't.

I just want to remind you that that function exists.

So that's what you're going to have to do.

You have to do a little bit of work to decide whether or not a given column should have a pound.

Otherwise everything else is going to be pretty darn similar.

Now I do want to focus on one thing here.

Remember previously and was determining the number of rows and columns but like we just said now that

enter number or that inner for loop or the number of columns is going to be not exactly identical to

three.

So this is an accurate diagram for and 3 because we have three rows here.

But you can see that there's clearly more than three columns.

And if we start to think about the different pyramid shapes that we might have you know put some of

them together here.

Here is the pyramid shape for any equals two.

This one has three columns years and equals three.

This one has five columns and we can go to any of those four and this one has seven.

So in each case here you can see that the number is changing.

Yes it's changing by two each time.

But you know I'll leave it up to you exactly how to calculate it.

So just keep that in mind anyways.

Give this a shot.

Obviously again you draw upon your experience from the steps problem quite a bit as you're working on

this one.

I will say that we are going to go over the iterative solution first.

So I recommend you put together the iterative solution first and then we'll take a look at the recursive

solution after that.

So if you want to just do one or the other totally fine.

I leave it up to you anyways.

Quick break.

Give it a shot and we will look at a solution in the next section.
--------------------------------------------------------------------------------------------------------------------

41. Pyramid Solution #1


In this section we're going to start to look through the iterative solution to the Paramount problem.

So let's get started.

Now the first half of this solution is going to look very similar to the steps one.

So we want to make a for loop that's going to iterate over each row of our output.

So very similar to what we did before.

Well write a for loop and iterate from row equal to zero row less than an ROE plus plus.

So that will take us from row 0 all the way up to and minus one for each row that we create.

Just like before.

We'll make an empty string here.

Now previously we call this empty string something like steps or something like that.

This time around just because we're working with a pyramid I'm going to call this string level to represent

a level of the pyramid.

If you want to go with stair steps or whatever we use totally fine there is no difference.

Now inside of here is where the real magic begins.

So this is where things start to get a little bit different from our initial steps.

Solution in sight here we want to iterate over all the different columns inside of our pyramid.

And like we said at the end the last video the number of columns is not equal to N like it was before

with steps.

So this time around we have to say somehow produce four.

And he goes to we need to get three columns for any equals three we need five and so on.

Now one thing I would really caution you against really try not to look at the relation between each

of these levels here like we're not trying to really derive a pattern from three going to five because

you could very quickly be thinking OK I just need to like add to to something every time.

And that's not correct.

We don't want to think about the difference in rows.

Irks me the difference in columns each time.

We're really trying to think of is how N is related to the number of columns.

So I don't want to compare three to five and try to figure out some pattern there.

I want to look at two to three three to five and four to seven and try to figure out some combination

or some pattern between each of those pairs of numbers.

So the relation between these you know there's not a super easy way to lead into this I'm going to tell

you what it is essentially the relation is we're going to take in we're going to double it and then

subtract 1 and that will give us the total number of columns so we can test this out very quickly in

our heads.

So two times two is four minus one is three.

So that works out two times three is six minus one is five.

So that one's good.

And then two times four minus one is seven.

So that's pretty much it.

We're going to iterate from 0 2 to two times and minus 1 and that will give us the correct number of

columns.

All right.

So back over here we'll write out our inner for loop will save for left column equal to zero column.

Less than two times and minus one column plus plus.

Like so OK.

So this will take care of our correct number of columns.

Now very quickly we start to run into the next big issue.

So previously when we worked this problem when it was all about steps we had a very clear and easy comparison

to make.

We had said that if the current column is equal to or less than the current row we should add a pound.

But this time around it's way different we've got a much more complicated calculation going here.

And really I'm not sure how much we can just do a very simple comparison between the two to figure out

what to do here.

In particular in this case we have some like range in-between here that we need to somehow figure out.

So this is another location where the math starts to get a little bit hairy.

Let's do a quick code up over here and figure out exactly what we need to do.

So essentially going from 0 1 2 3 4.

So from values 0 1 2 3 4 we need to make sure that number two or kind of value.

Number two in there gets a pound.

So I'm going to kind of make do a little pretend over here.

Let's say our columns are 0 1 2 3 and 4 and then our ROE.

Let's get some identifiers here.

Our row at this point is zero.

So I need to somehow relate these two sets of numbers together to make sure that I somehow can pull

out a pound for this index right here and spaces for these other areas.

And then if RHO was one then I would want to make sure.

So just to be clear that would correspond to this second row right here if RHO is equal to 1.

So in that case I would need to make sure that I can somehow produce a pound here a pound here a pound

here.

But then space's on the ends and then of course for RHO equals two.

Everything needs to be a pound.

So we need to figure out some relation to essentially generate that kind of stuff.

So here's my thought.

I think that what we can do is calculate the midpoint of our array right here.

So we'll calculate the midpoint.

Like what is the very center index of this thing.

If we can figure out the center index then we can say that take row number of elements on either side

of that Centerpoint and make those into pounds.

So with words that's really confusing.

So let's look at what this looks like in practice.

So first I want to get the midpoint of columns right here to get the midpoint in and when I say midpoint

I'm typing it like the index.

So in this case I had one index of two.

So I need to somehow turn zero one two three four or five into two.

So essentially you know let's just get to the point here.

Essentially we can do math.

Floor two times and minus one and then divide that by two.

Where and is the number of elements Hursey the number of total rows that we're working with.

So if we wanted to only consider the actual number of rows here it would of course be we're dealing

with five elements divided by two and then we'll take math top floor of that and that will give us a

second element to Spickler that two times and minus one.

I made a mistake right there this is the final solution.

I didn't mean to go that far forward.

Let's just forget we saw that and just think about five divided by two.

So now we can think of two and zero elements on either side should also be made into a pound as well.

So only element 2 in this case should be made into a pound.

If RHO goes to 1.

Then I want to take essentially math floor and math for floor plus 1 and math out for floor minus 1.

So elements in position 1 2 and 3.

So 1 2 and 3 should be made into pounds.

So hopefully that makes a little bit of sense here.

Again this is kind of getting into you know challenging stuff as far as some of these math calculations

go.

Let's try coding this up and I think it'll will start to make a little bit more sense.

So back over here the first thing we're going to do is to calculate the midpoint of our row.

So the midpoint of our row is going to change depending on N and that's why we had that two times and

minus one calculation in there for a second.

So we're going to say the midpoint is that index math Daut floor two times and minus one divided by

two like so.

So that's the midpoint index.

Now the other thing to keep in mind here is that we are iterating through this list of columns.

So in truth you know we don't really need to be calculating midpoint every single time here.

We could actually calculate midpoint at the very top of our function because it's only ever going to

be reliant upon and is never going to change.

So let's pull midpoint out to the very top up here.

And then inside of our loop all we really have to worry about is watching for row number of elements

to the left of midpoint and row number of elements to the right of midpoint as well.

So in code that would look a little something like this will say if midpoint less minus II is less than

or equal to you know not.

My mistake Roe if midpoint minus Roe is less than or equal to Culham.

And if midpoint plus Roe is greater than or equal to column then we want to add a pound.

So this if statement right here is going to make sure that the current column that we are looking at

is within the bounds of midpoint minus Roe and midpoint plus Roe.

So this is a check right here to make sure that we are inside of some bracket of numbers.

So if we meet that condition we'll add in a pound.

Otherwise we'll add in a space like so.

All right.

I know that was nasty but we did get through it.

I am pretty confident that if you look at these numbers a little bit they will make sense.

So do you know if it still seems a bit confusing do you try writing it out on paper.

You know for all the matters and I think that you're going to get a hang of it pretty quickly.

So here's our for loop inside of there we assemble one rows worth of numbers or one levels worth of

numbers.

So after that for loop just like before we will cancel log out level.

So let's see how we're doing with our tests back over here.

Looks like we've got 4 tests passing.

All right.

That was a challenging one but I think that steps gave us some pretty good preparation at least to pull

it into kind of two separate problems that we had to worry about.

So this looks good.

Let's now continue in the next section.
--------------------------------------------------------------------------------------------------------------------------

42. Pyramid Solution #2

In this section we're going to look at the solution to that pyramid problem by using recursion.

Before we get started.

Quick pause I wanted to tell you if you had any difficulty with the recursive solution to the steps

problem that we worked on just a little bit ago I really encourage you to give a shot at doing pyramid

on your own with the recursion solution because you essentially already know how the recursion solution

is put together.

All you really have to change is some of the bounds or some of the like you know essentially the range

of numbers that we're considering with this new solution for Paramount.

So this would be a great opportunity to practice some recurrent related stuff on a problem that you're

already kind of familiar with.

Now if you're to give it a shot or if you don't want to you know whatever it is no problem we're going

to go through the recursive solution right now.

So as usual we're going to make a backup of our pyramide function.

So I will copy the whole thing go down the bottom.

I'll paste it here it is right here and commented out.

I'll then go back up and I will clean out the pyramid function.

So now we've got only pyramid and the export statement right here.

All right.

So in general the recursive solution is going to look very similar to the recursive solution for the

stairs problem.

So the first half of this we're going to speed through pretty quickly.

And then as soon as we start getting into some pyramid related stuff will slow down just a little bit.

So just like before we're going to take special note of our argument list up here.

We're still going to hold onto the value N we're still going to worry about which road we're currently

looking at and we're still going to want to consider some given level here as an empty string.

Now the most important thing as usual and we want to make sure we spend careful thought on this even

if we are speeding through a recursions solution we always want to make sure that we set up our base

case correctly.

So just like before.

We're still going to watch for when Roe is equal to and if Rose equal to N..

That means we're all done with recursion.

We need to return and stop calling pyramid anymore.

Now note that Roe is still equal to and here because and ultimately was really describing the number

of rows we want in the last video when we spent some amount of time figuring out how to calculate the

number of squares going this way right here.

That was all about calculation calculating the column direction.

So Roe is still always going to be at a maximum of three.

It's the width of this thing that's going to start to change in nature.

Speaking of which that's going to be relevant right now because the next statement that we're going

to put together is going to detect when we are at the end of a level.

So at the very right hand side over here remember the maximum column length are the maximum number of

columns that we can have in a row is determined by the calculation two times n minus 1.

So essentially we want to check to see when our string the level string has a length of two times and

minus one.

If we are at that length then it's time for us to cancel the level and move on to the next row.

So we'll say if level length is equal to two times and minus one then we need to console log the current

level and move on to the next row.

So we'll call it pyramid with an will increment row by 1 and note that we are definitely in a place

the return statement here to make sure that we don't do any other work inside this function.

OK.

So that's looking good.

Now the last third to this thing is where things start to get a little bit more hairy.

Remember that the last third here is really intended to to decide whether or not we need to add a space

or a pound to the level string.

Now previously we had that very simple calculation to worry about how we had to worry about was if the

length of our string was less than or equal to Rho.

But this time around just like we had to kind of struggle a little bit with the solution this time around

we have to again calculate that midpoint and then decide if the current element that we were considering

is within that range of the midpoint.

So just like before I know the description on this was a little bit challenging but we still want to

do this kind of midpoint calculation.

We want to consider the row that we're on and then mark every element that's within some range of that

like plus or minus some amount to be a pound.

Otherwise it should be a space.

So let's look at the math for this first.

We'll calculate the midpoint which will be math floor two times and minus one and then another.

Outside of this first set of parentheses right here.

Remember order of operations will divide by two.

So that will give us our midpoint index.

Next we're going to put together an if statement to decide whether or not we're going to add on a pound

or a space.

Now rather than do our actual function call to the next pyramid call inside the if statement I'm going

to make a temporary variable called add at is going to contain the character that we're supposed to

add to our level string.

It'll make sense in just a second when we put down this if statement.

So we'll say if this is the nasty part.

So pretty big comparison we've got here.

If midpoints minus Roe is less than or equal to level dot length.

So remember in the recursive solution we determine which column we are currently operating on by looking

at the length of our level string.

So if the length the level string is less than or equal to or greater than or equal to the difference

between midpoint a row.

So it would essentially take care of making sure that we are you know on the right hand side of this

barrier right here.

And then we'll do the opposite side as well.

So Iand if midpoints plus RHO is greater than or equal to level length

then we will add in a pound.

So the second portion of the statement over here.

So this portion right here is making sure that we're still to the left of this found right here OK.

So now we're going to decide which character to add or I should say we just did.

We're going to sign the character that we should add to the variable add.

So in that case it's going be pounde.

Otherwise you want to get a space in there and of course to make sure that this is a space character

not an empty string.

So that's by the way why we use this temporary variable add right here.

It's just to assign the character.

We should add in and then down underneath all this stuff that's going on right here.

We will then start off our next call to pyramid.

So pyramid and is always going to be unchanged.

We are not going to change Roe because we are still in the middle of a road here on this bottom third

and then the last part we're going to make sure that we take this new character that we just generated

and added on to our level strength.

So we'll say level plus add like so

just one.

Let's see this.

Check our terminal.

Looks like I completely forgot to start my tests.

Mr. Arty's back up we'll see how we're doing.

All right.

Four test passing out of four.

Not bad.

OK.

So this has been our recursive solution.

Again this was pretty good practice because we got to see kind of more straightforward application of

it with the steps problem.

And then we got to redo it over here with pyramid but with some added complexity on top.

Both these problems.

I know I say this all the time throughout this course.

I know I said oh yeah this is a real common problem.

But again all the problems I picked for the course are of course common problems.

I really do expect you to see an interview.

And so proms like this one right here that are kind of concerned with spatial things and you know laying

out objects and spaces or whatever it is.

Common interview questions you'll see even though yeah of course you know no one ever had no one in

front end engineering ever is going to do some stuff like this.

I know.

You know that's a totally separate discussion that we haven't really touched on in this course.

I know that most These questions are totally bogus and not relevant to relate to a real job at all.

But you know that's just life.

I could we could talk for hours about that.

Anyways this has been a recursive solution.

Let's move on to our next problem in the next section.

So see you there.
-------------------------------------------------------------------------------------------------------------------
===================================================================================================================

Раздел 13:Find The Vowels

43. Get Your Vowels

Let's move on to our next question.

This next one is going to be rather easy.

Really very very easy.

But it's one that I've seen asked in preliminary interviews more than one time.

So what the heck let's just get through it.

Inside my vals directory I'll open up the index file and then of course we'll flip on over to our terminal

and start up our tests with just vowels test dot J us lunch like so and we should see four Tests.

Very good.

OK.

So we'll flip back over to the index dot just file.

Let's look at the description for this problem.

So we're going to write a function that's going to take a string and scan return the number of vowels

that are used in that string.

And if you are a foreign English language speaker of English is not your primary language of vowel is

any character a e i o n u.

So essentially we pass a string like Hi there.

Lis has one vowel two and three.

So we would return three for the next one.

Why'd you ask.

We have one two three and four.

So we were turned 4 and then the last one down here.

No vowels so we turn return y.

When I was back in elementary school we were always told like why is a half vowel.

I guess that's not really a thing anymore so you know we're not going to count y.

Who knows.

Anyways as you might guess this is not the hardest problem in the world.

So I encourage you to give it a shot.

We will look at two different solutions.

One is going to be an iterative solution and the other one is going to use a regular expression.

So if you are not up to speed with regular expressions this would be a great time to get a little bit

of practice in.

So give it a shot and I'll catch you in the next section and we'll go through the iterative solution

first.
---------------------------------------------------------------------------------------------------------------------------

44. Finding Vowels

In this section we are going to look at an iterative solution to the vowels problem.

Now this interim solution will be pretty darn straightforward.

So we're going to create a counter variable at the top will initialize it with a default value of zero.

We will then iterate through all the characters inside of our string.

If a given character is a vowel we will then increment the counter and at the very end of the function

will return that counter.

So not that bad.

Let's first start off by creating the counter variable.

So I'll say let count starts off a 0 and then we will iterate through our string.

So say for let char of and one thing that I want to point out here the directions didn't really indicate

if we wanted to consider capital avowals or not.

I think that it's entirely safe to assume that you want to include capital avowals and our fellow counting

here.

So we'll make sure that we lower case the string right before we iterate through it.

So say string to lower case and then we'll put some logic inside of here to decide if we're working

with a vowel.

And then afterwards we will return count.

OK.

So now the real thing that we want to care about here.

You know the real question is how are we going to check to see if we are working with a vowel.

Well you might be thinking hey let's put down a bunch of if statements.

If char is equal to A or if Char is equal to eat and so on.

Well we can definitely do that.

But that leads to some pretty nasty looking code with all these statements put together.

So I want to show you a little helper method that is included with all strings and all arrays as well.

That's going to dramatically simplify this.

So we'll look at a very quick example of it over here at my code editor.

I'm going to create a string.

Let's call it simply word and I'll give it the content.

Hello there.

Now a method that this string has is called include.

So I can Coale word dot include and then I'll pass in some substring that I want to see if it is included

in this string right here.

So maybe 0.

What do we get from that scares me.

Includes not include includes There we go.

So we're done includes We pass an O and yep there's Owen there so we get back.

True.

And then we can do something like capital F that's not in there.

We can do a substring like so.

So EHLO Yep that's unhealth right there.

So essentially using this includes method right here we'll go a long way towards helping us very elegantly

figure out whether or not a given char right here is a vowel or not.

So right above our for loop we will make a string that is going to contain all the different vowels

that we want to consider.

So I can say Konst.

Ideally I would really want to call this thing vowels.

But the function is already called vowels so we'll call this slight you know checker I don't know I'm

making it up and I'll make this a string.

So h e i o u like so now inside the for loop we can say if Sheckler

dot includes char then counter plus plus like so.

So if the character that we're looking at is included in this string right here then we're going to

increment the counter.

We'll iterate through all of our different characters and then eventually return it.

Now one thing I want to point out here is that using a string in this fashion right here is kind of

misleading.

You know it's not really the most clear thing in the world to any future developer who looks at this.

They might look at this and say oh is the order of characters here really important.

So even though we can use a string of characters to use this includes method I would probably recommend

that instead we should use an array as the kind of root comparison thing.

So arrays also have this includes helper method on it as well.

Let's see an example of what that would look like would be something like a b c c.

There we go.

And then we would want to see if C is included in the word array and Yezidis.

So if we use an array like this I think that life just becomes a little bit more clear for future engineers

who are working on this problem right here.

So maybe a e i o and you like so in addition this would also allow us to put in like discrete substrings

if we ever wanted to were kind of multi-character strings like if I ever wanted to.

For some crazy reason look for ABC is like.

Put that into this array.

I could not very easily do this same thing with only a single big book string.

So just one thing to keep in mind as well you know that's the kind of thing that interviewers want to

see you having consideration of.

To be honest.

So even though it might seem like this is overkill discussion for a function check and see if we avowals.

Honestly it's kind of a good discussion point to have during an interview.

All right.

Lesson do is make sure we're passing our test here.

Let's check the terminal and it looks like we are failing here.

Counter is not defined.

My mistake I'm incrementing counter right here is should be simply count and back over here.

We're now passing our tests.

Very good.

OK.

So that's one possible solution.

Now there is another solution that is much more condensed than this right here.

So let's take a break and we'll check out that alternate solution in the next section.
--------------------------------------------------------------------------------------------------------------

45. Another Way to Find Vowels

In the last section we went through an iterative solution for the vals function.

We're now going to replace this with a slightly more condensed version so I'm going to copy this thing

down to the bottom the file as usual.

Commented out just to leave a backup here and then I'm going to clean out the contents of the vals function.

Now this alternative solution is going to make use of a reg X expression or a regular expression.

So using a regular expression here in my opinion is so easy it's almost like cheating.

So what we're going to do is to look at the string we're going to call the match method on the string

matches used to see if some possible thing right here is included inside of this string.

So we can pass in a regular expression and this regular expression is going to check to see if we have

any values inside of here.

So our regular expression is going to have a pair of square braces when put in square pair of square

braces like this where essentially saying hey if this string contains any character that is inside of

the square brackets right here then let us know.

So we're going to put in all the characters that we care about a B.

I knew you'd think that we're going to do is to add on two options to the X itself.

Both G and III the G.

Regular Expression right here make sure that we don't stop at the first match that we find inside of

our string.

So if there are multiple vowels of some type in there we're going to attempt to find them all.

And then the right here stands for insensitive or case insensitive.

So remember before we had to manually turn our string into a lowercase version of itself the right here

will automatically take care of cases for us.

Now just one little odd thing about this match function right here.

If it finds any matches it will return an array of all the matches that were found.

So we will return that and assign it to a variable called matches.

But the part that's kind of awkward is that if no matches are found then match will return.

No instead.

So in other words matches right here will be either an array or no.

So we need to handle both cases appropriately.

We're going to use a turner expression for this.

So we're going to look at the matches variable if matches is no no considered to be a falsie value if

it is an array then that is considered to be a truthy value.

So for the first part of our turn an expression will say if this thing is a truthy value.

So if it is in an array then I want to return matches length otherwise it matches is null or if it is

a falsie value then I want to produce 0 and then ultimately we really want to just return the results

of the Turner expression.

So make sure we put the return keyword in there as well.

All right so we'll save this and let's see how we're doing now.

So still for passing.

Fantastic.

Again this is definitely more concise but it really is kind of predicated on you really closely understanding

exactly how a match works especially the fact that it returns no if no matches are found.

Personally if I were you I would probably stray towards this interim solution.

It's very clear and you can have some side discussions with your interviewer like the one that I just

mentioned at the end of the last video where using an array here is kind of the checker thing rather

than a string is beneficial.

So really up to you.

But honestly I think that the kind of value or the solution down here is probably the safer bet.

OK.

This has been a nice little breather Meisl easy one.

Let's now continue with our next exercise in the next section.
------------------------------------------------------------------------------------------------------------------
==================================================================================================================

