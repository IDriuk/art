Раздел 1:Get Started Here! 
1. How to Get Help

Hello and welcome.

We're going to get started with the course in just a moment but before we do I want to tell you how

you can get help if you get stuck at any point during this course.

So there's three great ways to reach out to me.

The first is to post on the course discussion boards.

I usually check the Course discussion about once a day on Monday through Friday so I'll do my best to

get back to you as soon as possible if anything comes up.

The next best way to reach out to me is to send me a direct message on you to me.

I'm usually very good about responding to these requests and usually better about that than with the

Course Q&A.

Finally you can reach out to me via Twitter.

And here's my handle listed right here.

Twitter is a great way to reach out to me with short questions but if it's anything technical related

I usually recommend either posting on the course discussion or send me a PM because obviously with Twitter

we've got that character limit that makes technical discussions a little bit more challenging.

All right.

So that's the three ways to get help if you ever get stuck during this course.

Let's pause right now and we'll start talking about our first technical topic in the next video so I'll

see you in just a minute.
----------------------------------------------------------------------------------------------------------

2. The All Important Coding Interview

Before we dive into any technical content we are going to discuss some important items regarding interviews

and white board questions.

I want to put you in a certain frame of mind of how you should approach interviews and interview questions

so let's get to it.

We'll start off by looking at a couple of different diagrams.

First I want to show you a quick timeline of the general job seeking process at any given company getting

an offer from a company is really split into two different phases the contact phase in the interview

phase contact phase is when you try to get in contact with a living breathing human at a company and

this might take the form of talking to a recruiter getting a referral from a friend or submitting your

resume through some online form.

Now this part at the top isn't too bad.

You know right now there's a pretty good amount of demand for software engineers.

And so after some amount of time of sending out your resume talking to recruiters.

Eventually you will get through this phase.

What comes after the contact phase is much more interesting.

So after you make this initial contact you move on to the interview phase the interview phase consists

of phone screens take home coding assignments and on site interviews.

This is the real make or break part the part that decides whether or not you're going to get an offer

with these two phases in mind.

I want to now ask you a question.

So during each of these two phases What is the average company looking to evaluate in you.

Well I've got a couple of thoughts about that.

I think that the average company is evaluating a couple different qualities in you during each of these

two phases.

So during the initial contact phase the company kind of wants to get a general idea of who you are.

So what work experience do you have.

Do you have any interesting side projects.

Are you friends with many people at the company during the second phase.

However during the interview phase there are some distinctly different qualities that a company really

wants to evaluate once you meet and interview in person they are going to try to decide whether or not

you're a good culture fit like whether your personality is going to mesh well with other people at that

company.

But much much more importantly than that it's during this interview phase that a company is going to

attempt to evaluate whether or not you are an effective coder or a good engineer.

So what's the point of this.

I'm sure you know you've already gotten a good idea of how companies hire people.

But the point here is I want to really make sure that it's clear that of all these different qualities

out of everything that a company is doing to evaluate you there is exactly one make or break quality

that you can improve.

Right now today.

And that is your ability to code your ability to answer a coding interview questions is the single most

important quality that you are going to be judged on during the interview process.

I personally have seen many people apply and get accepted to companies like Google Facebook Amazon and

many of them had little work experience no side projects no social contacts.

They might not be the nicest person in the world.

Maybe they didn't have the best culture fit but they could code and they could answer whiteboard questions

effectively.

And that is going to override every other quality during the interview process.

So the big takeaway here is that just by being here in this course watching this video right now you're

making a great move because you are are on the path to improving one of the most critical and easily

improvable areas for getting a great job.

And I hope that doesnt sound like too much of a marketing statement on my part but really I want you

to understand that there is nothing that gives you bang for your buck in the job seeking world.

Like being good at coding interviews.

So with all of this in mind let's continue in the next section and start to break down exactly how you

can get better at coding questions.
---------------------------------------------------------------------------------------------------------------------------

3. Getting Better at Coding
Questions

In an interview setting interviewers have three big tools to evaluate your coding ability.

First they can assign you a take home project which is something that you would usually do on your own

time and then submit to the company looking to hire you.

Second your interviewer can sit down next to you at a computer and the two of you can do a little bit

of pair programming.

Usually this peer programming focuses on a more practical use of skills rather than algorithms or theoretical

questions.

Third and what you will see most frequently at large companies like Google or Facebook is whiteboarding.

So the term whiteboarding is a reference to standing at a whiteboard or a chalkboard and writing out

some code to satisfy your interviewers questions whiteboard interviews have traditionally been seen

as kind of confrontational and certainly very nerve wracking as well.

Nonetheless it really is the tool of preference for many large companies.

And like we just mentioned the last video whiteboarding really is the easiest area for you to get better

at.

So the natural question to ask here is how do we get better at whiteboard questions.

If this is how we get hired if doing well Whiteford questions is how we get hired at a job.

How do we get better at doing them.

And the answer there might be a little bit disappointing is of course practice practice practice nonstop

practice.

There's no magic pill that you can take.

There's no secret.

One time exercise that is going to turn you into a pro at Whiteford interview questions all you can

do is practice.

Let me tell you a little bit about why practice is so important for interview questions by showing you

two extremely common interview questions.

So we're going to look at two very calm questions and we're going to kind of break them down a little

bit.

And I think you're going to find this a little bit interesting.

So the first one that we're going to look at is the classic fizz buzz problem.

If you've never seen it before this buzz is an extremely common interview question that requires you

to print out all the numbers between 1 and 100.

If a printed number is divisible by three divisible by three excuse me you should print out the string

fizz and if the number is divisible by 5 then you should print out the string buzz and then there's

one other case on here as well not super important.

This is considered to be one of the easiest interview questions around but people still fail this question

all the time in interviews.

So why is that.

Is it that lots of people are just really bad at programming.

Well in my opinion the reason that so many people fail at a supposedly easy question is that it's not

really an easy question at all.

My personal belief is that this is a moderately difficult one that has a little trick to it but once

you see that trick once you know what that trick is the problem becomes amazingly simple and amazingly

straightforward.

So I don't think that this is an inherently easy question.

It's that as soon as you know the trick it becomes incredibly simple.

And that is repeated with so many interview questions so many programming candidates who get interviewed

are not sitting there in a boat like a programming genius an interview because they get every question

right.

It's because they have done enough questions on their own time.

They've done enough practice to know the little trick that is required to solve each question.

The more problems you practice and the more problems you solve the better off you will be at knowing

these little tricks as they come up.

So see one other great example of this.

This kind of phenomenon.

So here is another amazingly common interview question.

This is a question that I've been asked myself so many times in interviews and I have seen it asked

at companies I've worked at as well.

One company I worked on particular asked every single candidate this question.

So I've seen this question asked many times and I've seen it answered many times as well.

So this is a question about the Fibonacci series and this question.

You're supposed to print out a specific number from the Fibonacci series.

Now it's not really important to understand what the Fibonacci series is just yet.

I kind of want to have just or commentary about what's going on around this question.

In most interviews an interviewer will ask the candidate to solve this problem with a recursive solution.

So here's the recursive solution down here.

Now I'm going to level with you.

And be really honest here.

I have seen amazingly few candidates over the years who have sat down and come up with this recursive

solution on the fly.

Like in other words nobody is really being asked this question.

For the first time in an interview and giving this as a solution I'm 100 percent convinced of that.

Instead every last one of these candidates who ever get this question right has always practiced this

exact question in the past.

They memorize this very short solution right here and then.

Hey soon as you get answer ask this question.

Great here's this like three line solution right here.

So the more you practice these problems the more likely it is that you'll be asked a problem that you

have already seen.

Of course if you have been in their interview and came up with a solution on the fly you know if that

has happened to you in the past that's great.

You know I'm not saying that it's impossible and doesn't happen for people to figure this out on the

fly.

I'm just saying that the bulk of my experience.

Most people who solve this question have seen it before and most people who have not seen it usually

fail the question which is certainly not good.

OK so hopefully at this point it's clear why solving problems nonstop really is the best way to get

better at technical interviews.

So let's continue with the next video where we're going to start to discuss how problems in this course

are laid out.

So quick break and I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------
=============================================================================================================



Раздел 2:A Touch of Setup

5. Environment Setup

Now that we have a good sense of why it is so important to practice coding problems will well now to

continue by doing a little bit of environment setup in this section we'll be cleaning a get help repot

that contains all the exercises and problems that we'll be working on throughout this course.

So let's get to it.

I mean the first change on over to my browser and I'm going to navigate to get hub dot com slash Stephen

Greider slash algo casse and I'll paste the link right here just to make sure it's nice and legible

for you.

I also put this link in the last lecture as text so you can always go back there and copy the link as

well.

OK so once I'm at this page I need to find the green button on the right hand side that says clone or

download a click it and then you can either download this entire repo as a zip file or clone it with

get.

In my case I can go ahead and clone it with get by copying the link right here.

So I copy the link.

I'm going to change back over to my terminal and then I will clone the repository by writing get clone

and then that link next will change into that directory that was just created.

And that's pretty much it.

Now there is one little dependency that we have to install here.

We're going to first install the dependency in this section and then we'll talk about what it does in

the next video.

So still at my command line I'm going to run the command sudo NPM install Dashti just now really important

if you're on Windows you don't need sudo right here.

So if you are on Windows go back over to the very left hand side and you'll delete that sudo only if

you're on Windows.

Otherwise go ahead and run the command.

You'll be prompted for your system password.

You can go ahead and give it and then run the command.

All right so this is going to take a couple of minutes to install.

So let's wait for it to finish and continue in the next section.
---------------------------------------------------------------------------------------------------------------


6. Repo Test Setup
In the last section we installed a get repo that contain all the exercises and programs they'll be working

through inside this course and then we install the just command line tool with NPM.

Let's now take a look at the contents of this repo.

And we'll also discuss what that geste program is for.

So I'm going to start up my code editor inside this directory that we just cloned and we'll take a look

at some of the files and folders inside of it.

OK.

So inside of here you'll notice two folders right here.

You might notice one or two more folders.

After I have gone through income and recension records all the content of this course.

But what you and I are really concerned with right now is this exercises directory.

So we open up the exercises folder you'll see a number of some folders inside of that.

Now for you you're probably going to see many more folders inside of here for me as I'm recording this

course.

I decided to just keep a minimal number of folders inside of you at any given one time.

So it's easier for you to understand where I'm working inside of the directory structure inside of each

of these folders you'll find both the index start ups and a test dot js file.

So the idea behind these different folders is that each one represents a specific problem that we're

going to work on.

All the code that you and I are going to write to solve the problem will go into the index not just

file of each respective problem and then some code to test our solution has been already written for

us inside of the test.

JS file.

So if I could open up test not genius you'll see some number of tests inside of here.

So that just command line tool that we just installed is a test runner that we're going to use to evaluate

all these different tests for each of these different exercises.

Let's now flip back over to the command line tool and just kind of see how it works.

So back in my command line I'm going to change into the exercises directory and then I'm going to run

the just command.

So I'll simply run just like so now when we run just it's going to automatically attempt to execute

every last test inside of this repository for us.

So we'll see something that says like hey here's some number of tests that might have passed in some

number that might have failed.

Now we are not going to want to really run all the tests for all the exercises every single time.

Instead we're going to usually be running one set of tests.

In other words just a set of tests for one specific problem that we're working on in order to run one

batch of tests.

We're going to modify how we run that just command slightly.

So here's what we're going to do.

Let's imagine that we want to run the tests for this fib exercise right here to run just the test for

this fib exercise.

We'll run the command just fed slash test drive J us and then slash slash or seen dash dash watch.

Like so.

So in other words you will write out the test file for just the exercise that we're trying to run.

Now in general throughout the course as we are working on each and every different one of these exercises

I will be showing you how to write the command.

So you don't need to necessarily memorize this command right here or be sure to show you over time how

we are going to run it again and again and again just to give you a good reminder.

So we now run this command.

You'll see that we are running only with tests related to that fib problem.

So I see now just six Tests being passed ran six Tests executed because there are six tests inside of

this test file for the fifth exercise.

Now just some other quick things to understand.

Whenever you change any of the code inside the project structure these tests will automatically rerun

for us.

But if for some reason you want to rerun them manually you can press the Enter key on your keyboard

and that will rerun all these tests once you're done running all the tests for a particular exercise.

And you're ready to run to move on to the next one.

You can always Press Control C on your keyboard and that will stop the test runner.

So if I press control C that will stop the test runner like so and then of course I can always start

them back up and then exit out again by pressing Control-C again.

OK.

So that's pretty much it.

This is our testing setup we're going to be using it throughout the course for each of the different

problems so we end up working on.

So the good thing about this test setup is that if you ever decide you want to deviate from the course

and just solve all these problems on your own or maybe come back later on and practice the problems

on your own then hey fantastic you've got a bunch of tests here to make sure you're doing the correct

work.

So now that we have our development setup all put together let's continue on the next section and get

started on our first practice problem.
--------------------------------------------------------------------------------------------------------
========================================================================================================




Раздел 3:String Reversal

8. First Question! Reverse String.
Now that we've set up our repo and we have a better idea how to run tests.

Let's get started with our first problem.

So the first question that we're going to tackle here is the one marked as reverse string is going to

open up that folder and then open up the index G-S file inside of it.

Now before we talk about this question too much I want to start up my tests for this particular question.

So back in my terminal I'm going to make sure that I'm inside of my exercises directory if I list out

all my files and folders inside of here I should see the reverse string problem listed.

Now to start my tests or run just reverse string slash test G-S then dash dash watch like so so a run

this and that will start up our tests and the first time they run I should see two test failing and

at least one test is passing which is great.

So you're going to work out this question and then as you start to solve it or whenever you think you

have a solution come back over to your terminal and make sure that all three tests are passing.

This is a nice kind of mild.

First question to start off with.

So hopefully we'll get kind of a knack around the pattern of writing a little code and then coming back

and checking out the tests.

All right now let's check out the question itself.

So inside of my reverse string index dot G-S file you'll see the directions list at the top.

Now essentially all we really want to do here is take a string that is provided as an argument as TR

short for string.

Reverse it and then return it from the function.

And the last part is really important.

Don't forget to return the string that gets reversed.

Very important.

So inside of this function body right here you're going to write in your solution.

Save the file and then whenever the file is saved you should see your tests rerun and repeat until you

see these things pass.

Now in this particular case I'm going to very purposely not give you a lot of direction on this question.

I want you to kind of dive in head first into this particular question but on future questions we will

talk a lot about pre-amble and different possibilities to solve it and all that kind of good stuff.

So just on the first one I want to just dive in headfirst.

Give it your best try.

One thing keep in mind is that if you ever start to get frustrated on the question please please please

just stop working on it and watch the solution especially when you're first getting started with practicing

interview questions.

It's really really important to make sure that you don't end up getting to know a little bit frustrated

when you're first getting started.

It's all about just seeing a lot of questions very quickly so you can start to get a handle on the types

of questions that you'll be asked.

So again if you are spending a lot of time on this question or any other one we work on just take a

break watch this solution and then give it another shot and I'll remind you this several times as we

go through the course.

OK.

So I'll leave this up to you.

Or catching the next section and we'll go and walk over the solution.
------------------------------------------------------------------------------------------------------------------

9. String Reversal, Solution #1
OK hopefully you had some success with this problem in this section we're going to walk through one

possible solution.

Now the first solution that we're gonna start off with is by far the easiest one.

However it's also not necessarily the most obvious one.

So this one requires a little bit of trivia knowledge of javascript in general.

So rather than going and writing out the solution right away I want to show you a little bit of documentation.

And as soon as you see this documentation you might have an auto type moment.

So let's take a look.

So inside my browser I'm going to open up the documentation for a re prototype reverse reverse is a

built in function that is included with all versions of javascript.

I should say most recent versions the reverse function right here will reverse all of the elements within

a given array and you can very easily see with the documentation right here.

We have one two three.

The reverse method is called on it and then a contains three to one instead.

Now this is very important to note here.

A method that belongs to all arrays.

But we were passed a string.

So in order to use this very easy very simple straightforward solution right here we need to make sure

that we are working with an array not a string.

Fortunately we can use a little method to convert our string into an array called the reverse method

on it and then turn it back into a string.

So if we put this into a kind of flow diagram Here's what we get.

So we're going to take in that SDR short for string arguments we're going to turn it into an array we'll

call reverse on it will join that array back into a string and then return the result.

So let's give this a shot.

Back inside my code editor I'm going to take this as TR short for String argument and we'll turn it

into an array.

So I'll say Konst A R R I like to abbreviate array as simply a r r.

By the way I will call string dot split and pass in an empty string.

So when we call split and pass in an empty string it takes the provided string and turns it into an

array with every element in that array consisting of a different character from the string.

So right here with a r r we're now working with a ray of characters we can call a r r dot reverse that

will flip or reverse all the elements within the array.

And then finally we can join it all back together again by calling a r r join in passing in an empty

string as well.

So this will join all those elements back into a string and then finally we'll make sure we return the

result.

So I can put my return keyword in here.

So let's save this.

Check our test and see how we're doing so save the file.

I'll check on my terminal.

It looks like all of our tests are successfully passing.

Cool.

So like I said this was a solution that kind of relied on a little bit of trivia.

Now it's entirely possible that you took a different solution.

So we're still going to cover two other possible solutions one that uses a for loop and another that

uses an array helper.

I do really recommend you check out these other two solutions that we're going to take a look at because

both them you might be required to give one of these other solutions your interviewer might say hey

don't cheat and use that reverse helper.

So we will look at two other solutions that take care of this process manually before we go however

I want to point out that we can do a little bit of code cleanup to make this function a little bit more

concise than it is.

Notice how right now we split our string into an array and assign it to this variable.

We then call reverse on it and then we join it back together.

So in fact we don't really need to make use of this temporary variable right here.

We could simply call reverse on the result of this expression and then call join on the results of that.

So let's look at that alternate solution that's just going to kind of clean up our code here a little

bit.

So I'm going to delete everything and I will return as TR dot split.

So that's going to give us our character or our array of characters we'll call reverse on that which

will reverse all the elements within that array and then we will join it all back together like so now

when I save the file.

I have a built in little code formatter so you'll notice that my formatter automatically splits it out

to a couple of lines here but it's all 100 percent equivalent to the code we just were looking at a

second ago.

So I'll save this file and if I go back over to my terminal again it looks like the tests are still

passing great.

So this is one possible solution.

Let's pause right now.

Continue in the next section and look at another possible solution.
-----------------------------------------------------------------------------------------------------------

10. String Reversal, Solution #2
In the last section we put together one very straightforward solution for reversing a string.

Now it's entirely possible that your interviewer might say hey don't use the reverse helper because

obviously if you know this thing exists it really makes the question quite easy and quite straightforward.

So in this section we're going to look at an alternative solution that's a little bit more manual work.

OK.

Now just to keep a record of all of my solutions as we go through I am going to copy this down to the

bottom of the file and comment out our first solution just to keep a record of all the different solutions

we come up with.

And I'm going to delete the contents of the reverse function.

OK.

So let's talk about the second solution.

The second solution is going to make use of a for loop.

So we're going to create an empty string and we'll call that thing maybe reversed.

I think that's a reasonable name for it then we're going to iterate through the string that was provided

and for each character in that string will take that character and add it to the start of the reversed

string.

After we iterate through the entire string we'll then return the variable reversed.

So essentially we're going to make an empty string.

We're going to take each character out of the original string and stick it into the new one.

One at a time.

And because we are adding the new characters because we're adding each character to the start of reversed

the reversed variable contain the reversed string.

So let's see what this solution looks like.

All right.

So back at our code editor We'll start off by declaring a temporary variable that we'll call reversed

and also sign it an empty string.

So this is the string that we're going to kind of assemble over time as we iterate through the string

variable right here.

OK so now we need a for loop.

One thing I want to mention about for loops in general and I'm going to tell you this many times throughout

this course wherever possible I really recommend you avoid writing for loops in the kind of very classic

syntax.

In other words the for loop syntax that looks like var i equal to zero.

I less than string length.

Plus plus.

So I really recommend you try to avoid for loops like this right here.

And the reason for that is that there are so many tiny little spots inside of here that you can very

easily make a mistake or make a typo for example maybe you accidentally flip the less then sign right

here.

Maybe you actually accidentally flip it the other way maybe rather than looking at string length maybe

you accidentally looked at reversed length maybe instead of semi colons you put in commas instead which

is honest to God something that I accidentally did on an interview one time.

So whenever you use you use this long form for loop you're just introducing many different locations

where you can accidentally make a little typo.

So for us throughout this course where ever possible we're not going to use this classic for loop.

Instead we're going to use a new syntax for four loops that was introduced with as 2015 called the four

of syntax.

So let's write the code for it and see what it looks like.

I'll say for lead character of S.

TR So that's the string that we got passed in as an argument.

Then in the body of the loop we'll say reversed equals character plus reversed.

Then at the bottom we will return reversed.

OK so let's talk about what's going on here.

So again this is a new syntax for for loops we say for a variable declaration.

So I'm creating a temporary variable that is redeclare.

Every single time through this loop of character than we say of.

And then the iterable object that we want to iterate through.

So in this case we are iterating through all of the characters of the string variable right here.

So we're going to iterate through each character of string one by one and set each character equal to

this temporary variable character.

We then take that character added on to the start of the string reversed and then after the entire four

loop we return the string reversed.

So again in general I really recommend you make use of this new and improved loops syntax rather than

attempting to write out the full for loop by herself.

Now there are several questions out there and I should say actually many questions out there where you

can use this syntax because maybe rather than iterating through every single element inside of a string

or an array or something maybe you want to iterate through every third element or iterate through every

fifth and there are Interview questions that require that type of logic.

And so if you are confronted with needing to loop through every so many elements within the array Well

then you do have to go back to using a for loop or even a while loop for that matter.

However as much as possible I do encourage you to try this new and improved syntax.

OK let's save this and see how we're doing a flip back over to our terminal and it looks like we're

still passing here as well.

So this has been a second solution.

This one's a little bit more manual and something that I would probably expect to be asked in a interview

question.

You know I would really kind of expect that any competent interviewer might say oh yeah don't use reverse.

That's just too easy.

All right.

So this one is a little bit more complicated.

Let's continue in the next section and we're going to look at one more possible solution.

So quick break and I'll see you in just a minute.
-------------------------------------------------------------------------------------------------------------

11. String Reversal, Solution #3
We have now put together two possible solutions to the string reversal problem.

Now I do want to look at one third solution you might be sitting there thinking Stephen do we really

need a third solution.

You know aren't the two we have good enough.

Well to be honest throughout this course I want to usually show you multiple solutions to the same problem

because inevitably first some people one type of solution is going to stick.

And another one will not.

In addition as we look at these solutions I'm going to usually be showing you some of the more complicated

ways of solving a problem.

Now sometimes you do want to use a slightly more complicated way just because it might show your interviewer

that you kind of know what you're talking about.

So this last solution is going to use a very complicated little array helper but it's also going to

make it very evident to your interviewer that you really know how to reverse a string.

So let's give this last solution a shot.

I'm going to start off by copying the second solution down to the bottom the file and commenting it

out and then I'll delete the function body for our solution right here.

So here's what we're going to do.

We're going to take our string.

We're going to turn it into an array by calling the Split function on it.

And then we're going to use the reduce helper.

So the reduce helper is a method helper that was included with.

Yes 5.1.

We'll take a look at how it's used in just a second.

So first turn this thing into an array by calling string split with an empty string like so and it will

set up the reduce helper function.

Reduce is used to take all the different values with an array and condense them all down to one singular

value which is essentially exactly what we're trying to do here.

We want to take all the values within this array that we just created and condensed them down to a single

string value.

Reduce takes two separate arguments.

The first one is going to be an arrow function that'll set up like so and then the second argument is

going to be a starting initial value for our function which I'm going to pass in an empty string like

so.

Now whenever reduce runs it's going to take this starting argument.

It's going to pass it into this arrow function has the first argument and then whatever gets returned

from that inner function will be then used as the starting argument for every successive run of the

function.

In total the function runs one time for every element within the array right here.

So in other words we can really picture that this first value for the first argument that has passed

introduce is are reversed string.

So I will receive it as an argument named reversed.

Then the second argument is the element or the character that we are currently operating on out of our

array.

And I'll receive that as an argument called character then the logic inside this function ends up being

the exact same thing that it was with our FOR loop solution.

So we're going to take our character that we're operating on right now.

We will add it to the total reverse string or the string that represents the reversed string that we

were past and then return the result.

So I will say return character plus reversed like so.

So this reduced call will yield a string that has the reversed form of the string that was passed down.

So the last thing we have to do is make sure that we return the results.

It's going to get my return key word in there like so.

All right.

So let's look at our tests.

Looks like everything is still passing.

Fantastic.

So this is definitely a solution that would work.

The last thing that would probably do here is to kind of simplify some of the syntax a little bit by

using some knowledge of iOS 6.

Again this is little improvement that is not necessary but something that might kind of impress your

interviewer just to show that yes you are familiar with.

Yes 2015 and understand the differences in syntax.

So one way that I could condense this function call write your down a little bit is to remove both the

return statement and the curly braces.

So I would remove the return statement.

I would remove the curly braces there's the other curly brace and then I also don't need the semi colon

here anymore.

Finally having the full word reversed in character is you know a little bit long here.

So I might choose to replace these variable names with simply Rev and char like so.

That's 100 percent you know up to you style preference but it's something that I think still conveys

their meaning but really condenses down the line.

All right.

So looking at this as a one line solution it's still not quite as brief as the reverse function call

with that first solution we did.

But I think it's certainly a little bit more condensed down than the second solution where we use the

for loop.

So again any three of these solutions works A-okay 100 percent just fine.

And of course there are other solutions out there that we didn't even cover many different ways to solve

this problem.

However if I want to really wow my interviewer or at least make them think that I understood some advanced

array helpers like say The reduce helper then this is likely a solution I would go with right here.

OK.

So this is our first problem.

We've gone through hopefully three different solutions.

Wasn't too tiring.

Like I said in general I want to show you multiple solutions just so you see different ways of solving

a problem.

So hopefully this first problem went along.

OK let's continue in the next section and start working on our next question.
---------------------------------------------------------------------------------------------------------------

12. Debugger Statements
We've now looked at three possible solutions to the reverse string function.

Now as you were working on your own solution here you might have noticed that it was kind of hard to

debug your work.

In other words the function that you put together you might have noticed that it's kind of tough to

figure out whether or not you're doing the right thing until all the tests are passing over here and

these tests aren't the most effective thing for helping you arrive at the solution or develop a solution.

They're really more about making sure you did the right thing.

So in the section I want to give you a quick little tool that you can use to very easily debug your

work and this tool.

I'm going to show you can be used not only on this reverse string function you can use it anywhere inside

the course so the tool that we're going to use is a regular debugger statement.

If you've never used debuggers before that's totally fine.

We'll take a look at exactly how they're put together.

So let's imagine for a second that maybe we want to pause execution of our code inside this function

so that we can inspect some variable inside of here to do so we can place a debugger statement like

so.

So now any time the javascript interpreter executes this line of code it will pause in execution and

we can take that opportunity to inspect some of the different variables that are floating around our

program.

This makes it extremely useful for debugging or essentially developing our solution to make sure that

we can actually catch this debugger right here whenever we place a debugger statement like this.

We do have to manually call the function.

So right now we are defining the function and then to merely export it.

If you want to use a debugger make sure that you call the function.

So I'll call it right after afterwards right after we define it.

I mean I'll call it with a string of SDF.

So now if we run this function in debugger mode or if we run this file we will pause an execution right

here and then we can inspect a couple different variables and just kind of see what's going on.

So let's figure out exactly how that works.

I'm going to flip on over to my terminal.

I'm going to kill my test by pressing Control-C and then going to change into my reverse string directory.

Reverse string and then I'm going to execute that file that function that we were just working on in

debugger mode and I can do that by writing Noad inspect index G-S like so now when I do so you're going

to see some information pop up.

It says that we have a debugger listening and it's attached to our running process.

You'll then see some little snippet of code right here and then we get kind of a prompt right.

You're asking us what we want to do.

So we just launched that file in debugger mode the instant it started up inside of our console right

here.

It paused in execution on the very first line of our file.

So right now nothing is running.

It's just saying hey I'm ready to start to inspect your code to tell this inspector to continue executing

our code.

We can write Khant short or continue or you can write just simply see and then hit enter.

So now the debugger started to or I should say the interpreter executed our file line by line until

it found a debugger statement.

Once it got to the debugger statement it paused in execution and it's now saying hey if you want to

you you can inspect some of the variables that are floating around inside this function.

Now let's imagine that we wanted to look at the argument right here of SDR or string.

You can't you cannot just put in TR right here to actually inspect a variable.

We have to enter a REPL mode REPL being short for read at it something something.

Whatever it is.

So will run the command Ruppel that'll kick us into an actual javascript console right here where we

can start to inspect variables that exist inside of our codebase.

So I could look at the variable string and it returns to me.

Ok here is what you're what that the value of that variable is.

And then if I wanted to I could always start to say copy over some code like I'll copy this expression

right here.

I can paste it right here.

And I see.

OK.

Looks like that did in fact reverse the string properly so you can use this entire REPL and debug all

D.C.M. debugger thing to very easily audit your code base and just kind of develop it on the fly and

get a sense of exactly how the data inside of your function is working.

So this is a tool that I highly recommend you give a shot with on some future solutions.

You know definitely give us a shot.

Obviously you can't always do this in an interview setting but as you're practicing these problems this

is extremely useful to use.

Just to give you a slightly better example of why this would be useful.

Let's look at a slightly different implementation of this.

So by the way to exit the REPL I can that's not the REPL I can hit Control C that kicks me back to debug

mode and then to you execution of my file I can hit C and enter again.

And in this case there was no other debugger statement inside my code base.

So it just quit.

And I can hit Control C again to completely exit the debugger.

So to get a better example of this I'm going to remove the debugger statement we had placed.

I'm going to take this last implementation of reverse that we had put together.

I'm going to cut it.

I'm going to move it to the bottom of the file and comments it out.

And I want to take that earlier solution we had put together with a for loop.

So I'm going to uncomment this thing.

I'm going to cut it and then I'll paste it above the reverse function call like so.

And then let's say that maybe something appears to be going wrong inside of our For loop right here.

So maybe after we start to concatenate the string together let's put a debugger statement right here

and this will allow us to inspect all the different variables inside the for loop and figure out exactly

what's going on there.

So again I can go over to my Turnell.

All right.

Node inspect index.

Yes.

Again I get kicked into debug mode.

We are poznań execution on the first line of the file all run.

See to continue execution of our code until we get to the debugger statement.

So here's the debugger statement and now I can enter the REPL and start to inspect some of the variables.

At this point in time.

So possible variables that I might want to look at would be a B character string or reversed.

You know anything in here.

So we could look at reversed.

OK there's what Reversed is when to look at character.

What character is and string like so.

Now notice how this is a for loop.

So the body of the for loop will be executed many times in a row.

So if I want to I could press control Control-C to leave the REPL.

I can continue execution again.

And now I just got paused again at the second iteration through the for loop and if I hit C again there's

the third time.

And then the fourth time.

So I can enter Ruppel again.

I can look at the reverse string.

And now it's the entire reverse string.

And of course I can look at characters well and now it's the last character that we were iterating over

which in this case is at so do be aware that if you place a debugger statement somewhere inside of a

for loop or a foreach or a map statement or whatever it will be called multiple times and you'll have

to use that C command to skip through it multiple times.

OK so I think that you've got a reasonable idea of the debugger here.

Again you can use it throughout the course on any problem we are working on.

To get a better idea of how your code is working I'll show you a diagram in just a second to remind

you of some of the steps you need to go through to set up the debugger.

Just keep in mind that when you are all done with the debugger you will want to remove the debugger

statement and then also remove the manual function call.

Down here we have to add that manual function call.

The one that we just had a second ago because if we don't call the function manually then when we start

to inspect this file there's nothing that actually invokes the reverse function inside of here.

So if we just if we ran the debugger on this file as is nothing actually invokes the reverse function.

So even if we had a debugger inside of here it would never get caught because we're never executing

the function.

So that's why we add it added in the manual function call right here.

OK.

So like I said one last thing I wish to you is the diagram of the steps to use to get the debugger to

show up if you want to you could take a screenshot of this right here.

Also remember that all the diagrams in this course are available inside of the Get hub repository.

So you could always go in take a screenshot or just manually download this diagram just to have the

steps of how to do this thing up for yourself.

All right.

So I'm glad that we now have some method to effectively debug our code.

We will use this method inside these videos several times throughout the rest of the course but again

feel free to use this debugger method as you are developing solutions throughout any problem.

You can use this on any problem you look at.

And I really encourage you to do so because it will give you a much better understanding of what's going

on behind the scenes.

All right.

So I think that's enough of that.

Let's take a break and continue with our next problem in the next section.
--------------------------------------------------------------------------------------------------------
=========================================================================================================





Раздел 4:Palindromes

13. Palindromes
Now that we know a couple of different ways of reversing a string we're going to immediately start to

look at another problem that requires you to reverse a string.

So inside of my exercises directory I'm going to find the question marked palindrome.

So here it is right here.

I'll open up the index dot J.S. file and then will also make sure that we immediately start up our tests

for this exercise as well.

So I'll flip back over to my terminal.

I'll end my running test runner by pressing control C and I'll start my test back up for that new exercise

by running just palindrome slash test J us slash dash dash excuse me watch like so.

So that will start up our tests and it looks like we have five passing and three failed right now.

Cool.

So let's look at the directions for this problem.

Back inside my code editor you'll find the directions listed at the top so the idea behind a palindrome

is that we should be able to reverse a string if the reverse string is equal to the original one then

that word is a palindrome.

Otherwise it is not.

So for example if we take the string A B B A and reverse it we end up with a string a BVA.

This is the reversed form of APBA the two strings right here are identical.

And so we would return true from our function to indicate that yes this is a palindrome.

However for the string ABC TFG if we reverse that we end up with G F E D CBA.

This is not equal to the original string.

And so we would say that this is not a palindrome.

One important thing to really keep in mind here is that you are not being asked to return a reverse

string you are asked to be.

You're being asked to return true or false to indicate whether or not this is a palindrome.

So you really want to make sure that after all your logic inside of your you ultimately end up returning

a boolean value something that says true yes this is a palindrome or false.

It is not.

So I'm going to leave you to put the solution together here.

Obviously there is an element of string reversal here.

So you'll probably want to remember how to reverse a string.

And then you'll probably want to think of some way to take that reverse string and compare it with the

original one.

So I'll leave it up to you on how to approach this.

Remember I can't say it enough.

If you get frustrated don't sweat it.

Just go to the solutions.

Take a glance and then give it another shot.

Don't get frustrated here right at the beginning.

If you get frustrated now it just means that you might end up getting too frustrated and end up quitting

and all we really care about at this point is seeing enough problems to get a really good sense of what

you will be frequently asked inside of an interview.

So give this a shot and I'll see you in the next section and we'll take a look at some solutions.
-------------------------------------------------------------------------------------------------------------

14. Palindromes, Solution #1
OK hopefully you had some success in checking to see if you're working with a palindrome here if you

were not able to get the test to pass.

One thing I want to remind you about right now is to recall that you're supposed to return a true or

false value from this function.

That's what the tests are looking for.

The tests want to see a truth or falsity value being returned.

All right.

So let's give this thing a shot with our first solution.

Now the first solution we're going to look at is the easiest or I should say kind of like the most direct

solution or the most compact one.

When I say easiest I don't necessarily mean the most obvious solution or the solution that you should

have gotten.

I really just mean to say this is probably the most direct solution.

So let's give this a shot.

The first thing to recognize is that we want to somehow reverse the string that is provided to us.

So we just learned how to reverse strings in three separate fashions.

So the first thing I'm going to do here is to reverse the string that is passed to us.

So I will say Konst reversed is string dot split.

That gives me an array that I will reverse.

And then I will join it back together.

And so in one line right here I now have the reversed string available to me.

Now remember if a string is a palindrome the reversed form should be equal to the original form.

And so there's not a lot of additional logic I need here.

I can just do a direct comparison between reversed in string and return the result to that if the two

are equal.

Fantastic.

They must be a palindrome.

Otherwise if they are not equal then it must not be a palindrome so right underneath.

I can simply say return String equal equal equal reversed.

So this is a Boolean statement right here.

Or I should say it produces a boolean value if string is equal to the value of reversed then we will

return true.

Otherwise if they are not equal to each other than we will return false.

So like I said this is the most straightforward solution.

Not necessarily the easiest one to come up with just the most straightforward one.

So I will save this file.

Let's check our tests and see how we're doing.

And so it looks like that solved it.

Not bad.

OK.

So if you didn't come with that solution of course don't sweat it might me personally.

When I first sit down to look at these I usually come up with a very round about solution one that's

not always the best.

So there's many different ways of solving this problem.

Many many different ways.

If you came up with another solution that is totally fine.

Let's take a quick break right now.

In the next section we're going to look at a second way of solving this problem.

So quick break and we'll take a look at that second solution in the next section.
-------------------------------------------------------------------------------------------------------


15. Palindromes, Alternate Solution
Let's take a look at another way of solving the palindrome problem.

Now remember there is no ONE way of solving all these problems.

So if you came with a solution that is different from my own totally fine for this alternative solution

we are not going to manually reverse any string at all.

Instead for this solution we're going to make use of another array helper just like the reduce helper

that we use just a moment ago.

So let's take a look at some documentation in this solution.

We're going to make use of the every array helper.

So we'll take our string will turn into an array and then we will use this every helper on it.

Now I'm at the Indiana documentation for every and if you want.

You can come here yourself and take a look at some of the documentation but I'll give you a quick description

of how every works right now the every function is used to do a boolean check on every element within

an array.

So for example if we had an array containing the values 0 10 and 14 and we wanted to ask the question

if every single value in there was greater than 5 we could write some code that looks like this right

here.

We would take the array we'd call the every function on it and then we would pass in a function to invoke

for every element within the array.

So the first time that this function was executed we would pass in the first element as Val.

We would check to see if 0 was greater than 5.

In this case zero is not greater than 5.

So we would return false from this statement right here when the every function runs it checks to see

the return value of every function run if every function or if any function I should say of any function

returns false then the over all expression will return false as well.

However if the inner function comparison right here returns true for every element then the entire function

expression will return true.

So every as very aptly named It's essentially executing a check or some type of comparison for every

element within the array.

So I bet you might be able to have some idea of how we can use this to check to see if we are working

in a palindrome.

Here's what we're going to do.

Let's imagine this is the array of characters that we're working with.

We're going to take the first element of the array which is a.

And we'll compare it with the element at the very end.

If that if the two are equal then we will return TRUE and say OK looks good so far this is a palindrome.

Then for the next element we'll take it and compare it to the second to last value.

We'll compare the two and say are the same.

OK.

And then we will repeat the process throughout the array.

So for C we will essentially compare C to itself because it's at the very center we'll then compare

B to the previous B and we'll compare the last element to the first one.

Now one thing that you might immediately lock on here is to notice that we are doing more comparisons

that are necessary.

And that is absolutely true.

Once we have checked every element up to that very center right here we don't really have to check all

the remaining elements because we already checked to see if a.

Or the first stone was equal to the last one.

So we technically don't have to iterate through the rest of the array and compare them back to the first

elements inside of here.

And so I'm going to say that this is not an ideal solution for this problem just because we are doing

essentially twice as much work as we really have to do.

However there is a reason I am showing you this solution and I'm showing the solution just so you can

explain to your interviewer what I just explained to you when you are working with an interviewer and

answering their questions.

In many cases they'll see you.

Hey like I think that your problem or your solution has a problem.

Here's what it is.

What are you going to do about it.

And so many times you need to be able to respond identify and somehow solve these issues that come up

with your own solutions.

The issue here of double comparison so comparing the first to the last and again the last two the first

is a really easy thing to bring up an interview and it's a really easy way to look good to your interviewer.

You can propose this solution with every helper and then say you know what I think this is a clear solution.

However it's comparer is comparing or it's doing about twice as much as it needs to do.

And so maybe you could then suggest some alternative solution.

So when you are in an interview setting Remember you don't have to be line.

The best solution right away if you can think of multiple solutions to a problem.

I highly recommend you give multiple solutions.

It just shows your interviewer that you are aware of multiple ways of solving a problem and also makes

them aware that you can compare and contrast between different ways of solving a problem.

So as I've said many times so far and I will say several times again throughout the course many ways

to solve a problem.

And it's really in your interest to be aware of all the different ways of doing it.

OK.

So with that in mind let's put this to the test.

So back inside my index file I'm going to make a backup of our initial solution and then I will delete

the function body here and we'll put together a solution with the every function.

So the first thing we have to do is turn our string into an array.

Remember strings do not have access to that.

Every helper.

It's only arrays.

So the call string got split.

Passing the empty string and then call every now the first element or first argument to every function.

Excuse me is a function that will be called for every element in the array we will receive the first

argument to this function which is each character from the array as an argument that we will call char

or short for character.

And then the other thing to keep in mind here is that because we want to compare each element to it's

essentially mere On the other side we also need to figure out some way of getting access to the element.

On the other side of the array.

So fortunately as a second argument to this function right here we are given the index of the element

that we are currently iterating over which the record is high.

So the first time this inner function is called I will be equal to zero because we are operating on

the first element in the array so now inside if you're inside the function we can return a comparison

between the current element and the mirrored element.

On the other side of the array now getting access to the other side is a little bit complicated but

it's really not that bad.

So the first time we run our function we are at index 0 right here.

So I would be equal to zero to get access to the element on the opposite side.

We could look at the entire string array and access the element at the length of the array minus one.

So remember all arrays and Javascript are zero indexed.

So right here we would start off as 0 1 2 3 4.

So over here would be four.

There are five elements in the array so we can't say.

Look at the element.

At length we have to say look at the element at array length minus 1 to give us 4.

So in other words long story short all we really do here is look at the string at string length.

Linus I so that we'll make sure we increment for every step through the loop or through the every function

minus one and the minus one right here is to make sure that we are taking into account the fact that

length is the overall length.

But we are zero indexed with javascript arrays cook.

So it's looking good.

Now last thing we have to do and this is a real gotcha.

Never forget it.

We need to make sure we return the result of the every function call.

So I will put my return statement in here.

I also forgot to comment out the palindrome function down here I'll make sure I do that.

And I think we're ready to test this.

So I'm going to save the file.

We'll check our terminal and it looks like all of our tests are still passing great.

So again this is not an ideal solution right here but it definitely gives you a little bit of you know

ammunition to work with with your interview or it gives you something to talk about and say here's a

solution.

It makes use of an advanced array helper which shows you know what you're talking about but it's also

not the best way of solving it which gives you something to talk about and you can then propose this

other solution down here.

So this has been a pretty good solution.

Let's continue the next section and look at our next problem.
-----------------------------------------------------------------------------------------------------------
===========================================================================================================




Раздел 5:Integer Reversal

16. Reversing an Int
Time to move on to our next problem I'm going to find the reverse in a folder inside my project you

know open up the folder and open up the index js file.

Now before we forget We'll also start the new test file for this project as well.

So back at my terminal I'll stop the running test runner by pressing control C and they'll start up

the new set of tests by running just reverse it.

Slash test dot J.S. dash dash watch like so look at.

So you should see about four tests or so running.

All right.

So back over to our code editor let's look at the description for this problem.

Now before we talk about the problem itself I want to say that this is going to be another very similar

reversing type problem but this one has a couple of extra challenges stacked on top of it.

This problem right here is a fantastic example of how understanding and really succeeding at interview

questions is all about practice and practicing more and different types of questions.

Cause at first glance this is kind of a tricky problem.

However if you understand the one or two little tricks behind it and there are distinct little tricks

here if you understand the tricks then this turns into an extraordinarily straightforward question.

So there is a very straightforward solution to this but it's all about understanding that little trick.

So if you want to get this problem a try on your own then go ahead and pause a video right now.

Read the directions and take a look at the examples and give it a shot.

Otherwise stick around.

We're going to look at the problem.

We're going to talk about some of the little tricks that you should understand to really effectively

solve this.

And personally I recommend you stick around and listen to these tricks.

Otherwise this problem is just kind of a nightmare to deal with.

All right.

So first let's look at the directions and the examples.

Again we are reversing some type of data entry here.

In this case it is an integer.

So if I pass an integer or 15 I should see the numbers in there get reversed.

2:51 981 would go to 1 8 9.

If the number ends with zeroes then when we flip it those zeros should disappear.

So 500 should not be 0 0 5.

It should be just 5 and the other interesting thing is handling negative numbers as well.

So negative 15 should become negative 51.

And if we kind of take this issue with the zeros together with the negatives negative 90 should turn

into simply negative nine.

Now what they want to make sure is really clear here even though we're in a section on this course where

I said we're all talking about strings and whatnot both the input and the output should be numbers.

So if we wanted to kind of apply the same kind of string reversal stuff that we've been doing that's

fine but the end result of what we're doing should produce a number not a string.

So make sure that's really clear.

OK.

So let's now talk about some of the little gotchas here are some of the things that make this problem

really easy.

So first off you and I know at this point how to reverse a string.

Very well.

We've seen two problems already.

Each of them with multiple solutions on how to reverse a string.

However we've been talking about reversing strings not numbers.

We can turn a number into a string.

However by using a function called to string.

So let's take a look at my little code editor here and I'll practice this out really quick.

Now on the left hand side going to write some code and we'll see the results of that code up here on

the right hand side.

So this is a quick example let me show you maybe Konst my number equals 200 if I want to turn this number

this integer right you're into a string.

I can call line number dot to string and returns a string 200.

So at that point I can then use familiar functions like say split and turn it into an array of strings.

I can join it back together to form another string and so on.

So by using this two string function right here we can turn our number into a string and then work on

it as though it was a string and take care of it.

With all the usual reversal techniques we've looked at so far.

So it's kind of a trick number one trick.

Number two I want you to be aware of is a little function built into the math library that is included

with Javascript.

So I've got the documentation for it in a new tab right here.

I'm out the Mozilla Developer Network.

Looking at the documentation for math dot sign.

So I'm not going to tell you exactly where to use this in this problem but it's going to punt this function

out with this math sine function.

We can pass in a number if that number number is positive mouth sign will return 1.

Otherwise if the number that we pass in is negative then it will return negative 1.

So for example math got sign of 5 or 4000 or turn 1 mapped out sign of negative 4000 returns negative

1.

So I just want you to be aware of this little helper function because I think that it might be really

helpful in solving the issue with maintaining this sign here on the actual number.

Now the last thing I want to tell you about the last little trick.

Remember how we were just talking about.

Well you can turn a number into a string by using a string.

So let's say we have 400 again just to make sure it's really clear once we called to string on this

thing if we then split it into an array and join it back together.

We're still dealing with a number.

I mean we're still dealing with a string in order to turn all this stuff back into an actual number

which is exactly what we're really trying to do here.

You can use the parse int function so parse it like so.

So parsing it takes a string and it returns a number or at least what it thinks is a number inside that

string.

And then once it's been turned back into a number we can then add an add something to it like you know

add 2000 or divide by 2000 or whatever we want to do.

So clearly after calling parce and we are now dealing with a number here.

OK so that's the three little tricks part sent to string and math sign between those.

I think that you've got the tools to kind of take the reversing of string technique that we've been

looking at and apply it to this new problem that we are working on.

So at this point I encourage you to pause the video take a shot at the solution and we will go over

the solution in the next section so I'll see you in just a minute.
----------------------------------------------------------------------------------------------------------


17. Reversing an Int Solution
All right hopefully you had some success with this problem in this section we're going to walk through

the solution now for this particular problem.

We're only going to go through one solution.

There are certainly multiple solutions to this.

When you consider the fact that actually reversing the set of numbers here can be done many different

ways.

However we already spoke about some of the different ways to reverse strings.

In one of the last problems we worked on.

So this time around we're just going to kind of B-line a very direct way of reversing the actual number

and we'll focus a lot more on how we kind of work with the number in general and how we maintain that

negative sign on there.

So let's give this a shot inside my function body.

The first thing I really want to do is give myself the ability to reverse the number.

That's why I really care about here.

I want to reverse the number.

So in order to reverse the number we're going to use the same methodology that we use in that previous

section.

We're going to take the number.

We're going to somehow treat it as a string.

We'll split that number into an array.

We'll use the reverse method on it and then we'll join it back together.

So let's at least do that much and see what happens.

So I'm going to take n that's the number that gets provided to us and I want to first turn this number

into a string.

So I'm going to call and dot to straight.

So now we're working with a string as opposed to a number.

And at this point we can now use all that split reverse enjoying methodology that we saw in the previous

problem.

So I can call split to turn this into an array.

I can reverse it because it is an array.

And then I can join it back together into a string like so.

Now at this point let's just kind of make sure we get our return statement in here and I want to run

our tests and see how far this gets us I want to see what this is really going to do for us.

So back in my command line I can run my test again by pressing the enter key and it looks like ha.

Interesting.

So here is one of the tests right here.

Rather than producing the expected negative 5 negative 5 Our code is currently producing 5 minus as

a string.

Notice the set of quotes right there.

So looks like we've got two big issues on the one hand.

We're not properly dealing with the negative sign.

And on the other hand we're still returning a string here as opposed to the number that we are expected

to return.

So let's take a look at this and see what we can do.

Well in order to make sure that we return a number out of this thing we can use the parse and function.

So rather than immediately returning the result of this reversal I'm going to assign this to a variable

they'll call reversed

and then right underneath Let's return parse.

Int of reversed like so.

So now we're trying to actually pull an integer out of this string that we just produced.

I'll say this.

And let's see what happens now.

So now if we look at our test again it looks like we're passing more tests than we were before.

We still have this one test down here failing specifically around handling a negative number.

So at this point we are expected to return negative 5 on this.

But our code has produced five.

So it appears that even though we were able to somehow pull an integer out of that reversal we did not

actually maintain the sign.

So we're not including the negative side and we somehow lost the negative sign during the parse and

process.

So now all we really have to do is figure out whether or not we should get this number to be negative

or positive.

Deciding that really comes down to that input number of N so if and is greater than zero then we want

to just leave everything as is if an is less than zero then we want to multiply the result of this by

negative 1 to turn it into a negative number.

So let's try writing out that logic we can say if an is less than zero then return parse end of reversed

and we will multiply this by negative 1 like so.

So if it's less than zero return early multiply by negative 1.

Otherwise just parse the number out and we're done.

So let's try this.

I'll save the file and now it looks like our tests are passing.

Cool.

So this is definitely a working solution right here.

But clearly having these two return statements that both call Parsons isn't super ideal.

So if you stuck around at the end of the last section when I spoke about some of the little tricks that

you can use to really solve this problem in a very direct fashion.

The other the last trick that I suggested was a function that is a part of the JavaScript standard library

called Math Daut sign.

So if we pass math taught sign a positive number it will return 1.

If we pass math that sign in negative number it will return negative 1.

So rather than putting this complicated statement in here we can just dump the entire thing and instead

multiply the result of our parse in function right here.

Times math does sign and we'll pass in.

So now math dot sign is really taking the place of the if statement that we just had if and is greater

than zero it'll be positive or the result of all this will be positive.

Otherwise it is less than zero than the result of all of this will be a negative one and we'll end up

with a negative number.

So let's save this and see how we're doing.

Go.

So now we're still back to four passing tests.

But our code here is looking pretty straightforward.

Now one thing I want to throw out there.

It's totally up to you.

This is really a style thing but you'll notice that we didn't really have to come up with this temporary

variable reversed right here.

We could have easily wrapped this entire statement inside of the parsing function call.

However I think that the code right here looks pretty legible in this fashion.

And really if we wanted to kind of put everything into a one liner it really ends up being kind of nasty.

And I've actually got a example of that that I'll copy paste onto the screen.

So this would be kind of a one line solution right here.

I think that it's really tough to understand what's going on.

So personally I would really recommend leaving it as the two separate statements like so great.

So like I said this is just one solution.

There was many ways that we could kind of reiterate on this thing and change up the actual reversal

of the number.

But we already spoke about some of the different ways of reversing a string if you came up with a different

solution for actually handling the negative sign here.

We're actually pulling in number.

How do the string.

That's totally fine.

But this is definitely a solution that works as well.

So let's take a break here.

We'll continue the next section and move on to our next problem.
------------------------------------------------------------------------------------------------------------
============================================================================================================




Раздел 6:MaxChars

18. Max Chars Problem
I'm really excited about this next question that we're going to work on because the technique that we're

going to use to solve it is directly applicable to many other string related questions.

So in this one question Max Chaar there we're going to work on.

Let's open up the index not just file for it.

The technique that we're going to use to solve this can be used to solve many other string related questions

as well.

And I'll give you a list of some of the other ones that are very closely related in just a second.

First let's make sure that we start up our tests for this problem.

So at my terminal I think you know what to do by now.

We'll run just Max Chaar test dot genius dash dash watch like so you know I think I made a little.

It's not Max char's just Max Chaar.

My mistake.

Like so we should see at least three tests running.

OK.

So let's look at this problem in good detail and let's talk about the technique that we're going to

use to solve it.

So given a string we are going to return the character that is used the most.

Inside that string for example if we pass in a string of A B C C C C C will clearly C is used most frequently

inside of here.

So we see a return seat.

Likewise if we pass an apple and then 1 2 3 1 1 1.

Yeah.

These are numbers but they are inside of a string so they're still considered to be characters as far

as we are concerned.

And so clearly the most use character inside of here is one.

So we return the character or the string one not the number.

So no concern about numbers or in particular we're just saying unique characters inside of a string.

Ok so let's talk about the trick that we're going to use to solve this problem and many others like

it.

So first I want to show you some other common variations of this question.

So if you ever see questions like this on the screen right here you want to be thinking about using

this exact same technique.

And honestly I was going to put some of these other questions into this course but we would have just

been using the same technique again and again and again which would have been kind of annoying for you.

So I figured we would just do this one problem and have a good grasp on how to do it.

So if you ever see questions like the most common character on the string you see something like Does

one string have the same characters in the same quantity as another string.

That's what we refer to as an anagram.

By the way or do you ever see the question.

Does a given string have any repeated characters in it.

So anything like this anything around counting the number of characters or comparing the number of characters

between two strings.

You can always use this technique.

So let's talk about what it is here's what we're going to do for all these different problems that are

related to counting or verifying the number of characters in the string.

We are going to take our string and we're going to essentially convert it into an object where the keys

of the object are the characters from the string and the values are the number of times that that character

has been found.

So for example we could take the string Hello there.

Notice how hello there has one H.

It has three E's.

Here's what he 2E and three and he has two L's.

So with that in mind let's look at the resulting object that we would build up.

So inside of our object we would have one capital H and would have a value of 1 because that character

specifically capital H was found in our string exactly one time.

There are three E's present and they're each lower case so we would add a key of E and assign it a value

of three because it has been found three times.

Finally for l there is clearly two els here.

So we would put L in as a key and then assign a value of 2 and then we would repeat the process for

the rest of the string as well.

So when you have this kind of map right here it makes many different types of questions very straightforward.

For example if I asked you what is the most common character in the string which is pretty much what

we are trying to do right now.

Well now that we have this object we could walk through the object find the value that has the highest

there is give me find a property with the highest number assigned to it which in this case would have

been 3 and we would really know.

OK looks like is the most frequently used character.

If someone ever asks you to string a string B how the same characters at the same frequency.

Well we could build up an object that looks like this for both string a and string B and then compare

the two and make sure that both objects have the same number of properties inside of it and the same

values.

Finally does the string have any repeated characters so the words are there any duplicate characters

in the string.

Well this one's probably easiest overall.

If there's any value inside of this object with a value greater than 1.

Yeah that means that found say l twice were eat three times which means if someone asked me Does that

string have your repeated characters I would say yes that definitely does.

In this particular case.

So setting up an object like this is clearly a really strong tool for solving any type of question around

producing some counts or verification or validation of a word.

So with that in mind let's continue in the next section and I'll give you a quick overview on how we

would put together an object like this.

So quick break and we'll tackle this thing in the next section.
------------------------------------------------------------------------------------------------------------

19. Max Chars Character Map
In the last section we spoke about how turning a string into an object where the objects keys are the

letters in the string or the characters in the string can be used to solve a wide variety of problems.

In this section we're going to look at one possible way of generating this object right here.

Now if you want to give this entire problem that we're working on a go on your own and maybe even come

up with a solution that doesn't use an object like this that's totally fine.

Just pause the video here and continue on in the next section.

Otherwise let's get to this thing.

So I'm going to go ahead and use my little notepad over here to show you the solution.

So I hope to hear is that maybe you watch the solution but don't copy it down.

So maybe you watch it right now and then when you attempt the max Keres problem Remax charas problem

that we have cued up right now.

Maybe you tried to reproduce the solution from scratch at that point but of course I leave it up to

you.

All right so here's what we're going to do.

We're going to create some new string and I'll say hello there.

Just like the one we just saw in the diagram and then we're going to iterate through this string.

And for every character we're going to add that character to a new object.

So maybe you'll make a new object as well called chars short for characters.

So now there's a couple of different ways that we can take these characters and add them to the object.

We can either split the string into an array and then use a For Each helper to loop over all the characters

or we can use a four of loop to live through all the characters inside there and do basically the same

thing because we just saw the four of syntax just a little bit ago.

I think we should use four of again because it's nice and fresh in our minds.

So we will iterate through our string.

And for every character inside there we will either add the character as a property and assign it a

value of 1 or if we've already seen that character before we will add 1 to it.

So we'll save for let char of string and then for every character that we find and iterate over we're

going to add a property to chars to do that.

We'll say char's we'll use our index notation.

So this right here will return a reference to that particular character or at least its value.

Now if it's the first time that we are seeing this character we want to set its value to 1.

So if we have never seen chars at SE Capital H then this right here will evaluate to undefined.

So we need to make sure we handle that case.

So we'll say if nothing exists here right now.

Then set char's at Chaar to one otherwise assuming that there is a number already there will take charge

Chaar and will increment it by one like so.

So then at the very end we can print out charters and we end up with our object.

So we have a capital H with one.

We have three E's two l's and you get the idea.

Now the logic that we placed inside this for loop break here can certainly be condensed down from what

we have.

So a good way to simplify this would be to maybe use a tertiary expression.

We could also kind of condense this down to one line with a little bit of boolean logic and you want

let's let's see a quick example of that.

So another way of putting this logic inside if you're together without using an if statement would be

something like chars at char is char's char plus 1.

Now you'll notice this is why we can't just say add one.

Because if we try to add 1 to undefined we end up with no.

As you see right here.

So that's why we have to put in that statement to see if that value exists yet.

So one way of handling this eloquently in this particular case would be to say if adding one onto this

number resulted in a null value that's fine.

Then instead assign the value of 1 like so.

So if this is falsie then otherwise assign one to char at char and we end up with the same object either

way.

It's like I said many different ways of putting together the body of the for loop right here.

It's really up to you which way you want to do it.

All right.

So hopefully that kind of illuminates how we put this data structure together.

So at this point let's take a look at our question here and make sure it's really clear what we're trying

to do.

So inside this question member we are inside the max char folder in the index start G-S file.

We want to pass in a string to max char and then return the character that is most frequently used inside

that string.

So clearly inside the string C is used the most.

So I would expect to return see otherwise if we have Apple 1 2 3 1 1 1.

Well then we want to return one call.

So at this point we're going to take a break give this thing a shot see if you can't solve it.

And we'll go over the solution in the next video.
------------------------------------------------------------------------------------------------------------

20. Max Chars Solution
In the last section we spoke about how he can use a character map to solve a wide variety of different

string related questions a character map is an object where we take every character out of a string

we added as a key to the object.

And then the value for each for that key is the number of times that letter has been found in the string.

So hello there has three E's Inside of it.

So we have a Kievan E and assign a value of three.

Let's take this technique right here and approach and apply it to our Max char problem.

So remember inside of Max char we're trying to find the character that occurs most frequently inside

of a source string.

So definitely a problem that is well-suited to building up a character map.

So let's get to it inside of our function.

We'll start off by declaring a new variable called Char map which is short for Character Map and will

be an empty object.

Next will iterate over our source string right here and use that to build out the character map.

So we'll save for let char of string and then for every character that we receive we will add an entry

to Character Map and if an entry already exists there.

Then we'll just add 1 to the number.

So we'll say if Char map at char.

So if this exists if we already have an entry here.

Great.

Let's increment it by one

otherwise we will set char map at Char equal to 1.

So char map that char equal to 1.

Now you'll notice that I wrote this out opposite of how we just said in the example of minute ago I'm

just doing that on purpose just to give you a little bit of variety and make you use your brain just

a little bit.

So do you take note that I flip the kind of order of operations here between the two cases.

So now we should have our character map built up at the bottom of the file.

Or this function let's print out the character map that we just built just to make sure that it is working

correctly.

So I will console log char map like so let's flip on over to the terminal and see what happens.

So over at the terminal I should see my two console logs appear right here.

And so it looks like I correctly have.

Here's my character of one.

A B C D F G.

So remember this is some test input that is provided right here.

So looks like the test input has the character 1 and it's used six times.

So I would definitely say it this looks like it's working correctly right now.

All right let's take a quick pause right now.

We'll continue in the next section and we'll discuss how we can now iterate through our character map

and find the character that is most frequently used.

It's a quick break and we'll finish this up in the next video.
--------------------------------------------------------------------------------------------------------

21. Max Chars Solution Continued
In the last section we were able to verify that we successfully built a character map to represent our

strength.

Now it's up to us to somehow iterate through this character map and find the character that was used

most frequently in a given string.

So taking care of this is going to be very much like iterating through an object.

We're going to iterate through it.

We're going to try to find the value that has been used most frequently.

Now there's several different ways to iterate through an object like this and find the max value.

But we're going to take a very direct straightforward approach.

So we're going to start off by declaring to helper variables at the top of the function we'll say let

Max set that equal to zero and then let Max char and set that to an empty string.

So we're going to iterate through the character map if we ever find a character that has more uses than

max.

Then we'll set max equal to that new value and we'll set max char to a character that was responsible

for that number of uses.

So in other words the first time we iterate through say this hello world object right here we would

look at the key value pair of H and one.

Now one is greater than the initial variable of Max.

So we would say oh this must be a new maximum that we found.

So we would set max to 1 and then Max char would be set to the key at that location which is H.

We would then go onto the next value.

This one has three.

So we would set three equal to max and then Max char would be updated to e because that is the new maximum

character.

So in practice really not the worst thing in the world.

Let's give this a shot.

So I'm going to go down to the console log at the bottom and we will replace this with the new loop

to iterate through our character map.

So we'll save for let char.

And now here's something that's going to kind of blow your mind.

Notice how in the past we've been talking about that for of loop.

So the for loop is used for iterating through an array or a string or any type of iterable object.

But in this case we are iterating through an actual object like a collection of key value pairs.

So to iterate through this object or any type of javascript object as opposed to an array or a string

we instead use a slightly different kind of loop.

So in this case we use a loop that uses the for in syntax as opposed to four of the way that I remember

the difference between the two of these are just remember that object starts with 0.

And ironically they chose not to use of or you know starting with 0 to iterate through an object.

So I remember object starts with 0.

We do not use the four of which begins with 0 to iterate over an object.

Instead we use for it in.

So that's how I remember it personally.

So look at each character for char map.

Then if the char map at this particular character is greater than our Max we're going to update both

the max number and the max character.

So Max will become char map at char and Max char will become char.

So as you can guess right now when we iterate with a for in loop char right here is assigned to the

keys inside that object.

So this is not the values it is the key.

So char will be the different letters that we have added to our object.

Now after we run the loop we should then know which character is the greatest number of uses it will

be assigned to max char which means at the very end all we have to do is return Max char like so.

All right let's see how our tests are doing.

It looks like they're all passing.

Terrific.

OK.

Like I said using this kind of character map set up right here can be used to solve many different types

of string related questions.

And I really recommend you keep this technique close at hand whenever you are an interviewer they ask

you anything about strings it can be used in so many different locations.

So hopefully this has been helpful.

Let's continue the next section and continue working.

So a quick break and I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------
=================================================================================================================




Раздел 7:The Classic FizzBuzz!

22. FizzBuzz Problem Statement
The next problem that we're going to work on is going to be a lot of fun because it is the classic interview

question.

It is this buzz the question that has been asked more times than you could possibly believe in an interview

setting.

So in our physio's folder we're going to open up the index not just file will also immediately start

up our tests for Hizbullah's it as well.

So at my terminal or run just this buzz slash test that J us dash dash watch like so and then we should

verify and make sure that we see three Tests in total right now.

Two are failing one or passing OK.

Like I said this is the classic interview question.

As we said much earlier in the course one of the first sections we looked at and that one of those earlier

sections we had said that this is a problem that is really kind of challenging maybe moderately challenging

the first time you see it but as soon as you learn that little trick to it it becomes the easiest thing

in the world or so everyone claims.

So really if you haven't seen this problem before.

Don't sweat it.

If it seems challenging it's not until you see the little trick that it starts to get a little bit easier

to handle.

So let's make sure that it's really clear exactly how this problem works.

We have our first bus function down here towards the bottom when we call the fizz buzz function with

some whole number.

So some whole positive number we need to print out all the numbers from 1 to that number.

So when I say print out I really mean console logs we're going to cancel log out all the numbers from

1 to n. However for any number that is a multiple of three it's a multiple of three.

We are going to print out the string fills.

If the number is a multiple of five we're going to print out because if the number is a multiple of

both 3 and 5 then we're going to print out fizz buzz.

That's it.

So the real challenge here is I would really imagine you know how to count Konst alog you know how to

write a for loop to loop from 1 to n..

Clearly the challenge here is determining when the number is a multiple of 3 and five.

So that's it.

That's the little trick.

That's all there is as long as you can figure out exactly how to calculate a multiple of a number.

You can solve this problem without any issue.

So let's do a quick reminder on how to calculate a multiple of a given number in Javascript.

So I kind of flip back over to my little notepad here.

So we're going to use a very specific operator.

Now when I say operator I'm talking about like an addition sign a negative sign or a minus sign division

whatever it might be.

So if we say for example one missed one in this case the minus sign right here is our operator.

Now there is a very rarely used operator in the javascript world called the modulo operator and we spelled

out maade modulo like so.

So the modulo operator we can determine the remainder of a number during during division.

So for example if we took nine modulo three and returns zero.

So in this case it is zero.

Because if we divide 9 by 3 3 goes into 9 exactly three times and there is no remainder left over.

However if we divide 10 by three we'll then 3 goes into 10 still three times.

And there's one left over.

So three times three equals nine.

That is 1 away from 10.

And that's why we get a result of one over here.

If we do 11 mod 3 we'll then we're two away.

But if we go to 12 12 is again a multiple of three.

So we're back to zero.

So to determine if a number is a multiple of another we can use the modulo operator.

And essentially what we want to do is take some given number that we're trying to test use the modulo

operator with the number that we are using as the multiple.

And then the real question here that we are asking is whether or not the result to that is equal to

zero if 12 maade three is equal to zero then 12 must be a multiple of three.

However if we use 11 mod 3 this is not equal to zero.

So we get false.

So the story here is pretty much it.

This right here is the line that is the sole trick to fizz Buzz.

All you need to know is how the modulo operator works and then you can solve the entire problem.

So in practice you're going to test for each number from 1 to n and remember and is the number that

we pass in as an argument to the physio's function right here.

You're going to test to see if a given number modulo 3 is equal to zero.

And if a given number modulo 5 is equal to a given number person B is equal to zero.

And that's pretty much it.

That's the challenge here.

So I'd like you to give this thing a shot now as you're working through it.

There is one thing I want to point out here just because of how the tests are written.

Note that when you are printing out fizz and buzz and fizz buzz for multiples of three and five.

Notice that the expectation is that you're going to print out lower case things.

So lower case is not upper case for doing lower case fears here.

That is specifically what the tests are looking for.

Now the other thing to keep in mind is that you are not returning these numbers.

So if you find a multiple you're not returning it from the function you are con. logging the number.

OK.

OK.

So with that I'd like you to take a shot give it the best.

Darren can help go over the solution in the next section so I'll see you in just a minute.
-----------------------------------------------------------------------------------------------------------------

23. Solving FizzBuzz with Style
All right hopefully you had some success with putting together your fist but solution in this section

we're going to walk through the solution and make sure it's really clear exactly how it works.

Remember the whole key to the solution is recognizing exactly how that modulo operator works.

The other thing that's really important to keep in mind is that as we are iterating through our list

of numbers we want to print out the number or features or buzz or fix bugs.

So for one particular number we print out only one thing we don't print out like three and four is for

the number three right here we print out only fizz.

So let's get started.

Step one is to make sure that we can iterate from 1 to n inside of our function.

So I get to find my first bus function down here towards the bottom and we're going to set up a loop

inside of it to iterate from one to end.

Now I know that I said a little bit ago that whenever you're doing interview questions you want to avoid

setting up manual for loops.

However this is one of those cases where we really can't get around it.

We don't have any object to iterate over.

We don't have any numbers or me any array to iterate over all we know is that we want to iterate from

one to end.

So this would be a case where we kind of are in a situation where we really want to just set up a for

loop manually.

So we'll set up our for loop to iterate from 1 to eat less than or equal to N and each time we're going

to increment by one.

Now one important thing to keep in mind here is yes we do want to start at 1.

If you write a lot of four loops in your life well you might be used to saying start off at zero.

We're not starting at zero here are the directions specifically say that we are iterating from 1 to

10.

So we're going to make sure we write out our loop like so next.

What I really recommend you do an interview setting just to make sure you nail this question 100 percent

is to write out some comments to guide you.

So the first thing we want to do here is check to see if the number is a multiple of both 3 and 5.

So we're going to say is the number a multiple of 3 and 5.

Because if so we want to cancel log and then do nothing else in this step through the loop.

And that's really important.

Remember if our number is say equal to 3 we only want to print out things and we don't want to print

out the number three.

So we need to make sure that we whenever we do all of these checks we initiate the check.

We print out the statement that is required and then we do nothing else inside of the step through the

loop.

So let's get started by writing out the if statement that is going to check to see if our number is

a multiple of both 3 and 5.

So I'll say if I modulo 3 is equal to zero.

So that's going to check to see if we have a multiple of three.

And if I modulo 5 is a multiple of zero then we want to cancel log out fizz buzz like so so that's step

one.

Now one thing that I will mention right away is if you look at this and you are kind of got a thing

for numbers.

You'll very quickly realize that we only are going to meet this kind of criteria right here having a

multiple three and a multiple of five when it is a multiple of 15.

So any number that is a multiple of three and five is going to be a multiple of 15 because three times

five is 15.

So if you came up with a solution where you said I modulo 15 and left it just like that.

That's totally fine and appropriate.

This is something that sometimes people do because it is just a little bit more terse and easier to

read but honestly you're totally fine leaving it just like so.

All right.

So we have successfully checked to see if we are a multiple of three and five.

Now the thing to recognize next is that we don't want to set up a nother separate if statement.

So if we met this situation right here this condition this is the only code this council is the only

law that we want to execute.

So essentially what I'm saying here is we want to make sure that if we meet this case we don't execute

any other code inside the for loop.

And so to make sure that's the case rather than writing out a bunch of separate if statements we'll

write out a bunch of ELSE IF statements.

So we're going to see if we meet this condition if we do.

Great.

Do the console log and go on to the next step through the loop.

Otherwise if we meet this next condition execute the next console log and so on.

So for the next one we'll check to see if we have a multiple of three

and I'll add a comment here just to remind myself is the number a multiple of three.

And if it is a console log out this next we'll out in the next.

Else if if so if we have a multiple of five then we'll cancel log out buzz.

And then finally if we have failed all three if statements inside of here.

So if we are not a multiple of 15 not a multiple or three not a multiple of five.

Finally at the very end here we'll just print out the number.

And so I will console log simply.

I like so ok.

You'll notice I missed my comments on these last two cases but I think you have a reasonable idea of

what those comments would be if you want to add them in.

So this right here is the classic an imitation of this buzz.

Now you will see sometimes other situations online or other implementations that kind of condense this

code down a little bit and they might use Tzschirner expressions or some oddities around javascript

to shorten it.

But honestly at the end of the day if someone asks you this question I really recommend you basically

just do exactly this right here.

There's really no need to get fancy.

And honestly if you start to get fancy with fizz buzz that's kind of something that interviewers lock

on to interviewers like to see that you understand advanced syntax and they want to see that you know

how some neat helpers inside javascript works.

But if you start putting what is otherwise very straightforward legible code like this into some really

fancy one liner honestly it's kind of ironic.

But their first inclination and I've seen this happen so many times in person.

Their first inclination is to say something like Wow you took some really easy code and you turned in

as some fancy one liner.

That's really hard to understand.

And so it's like well you know on some questions they want you to go above and beyond and use some fancy

javascript.

But on the ones they really want it to be just straightforward and simple.

And I would definitely classify fizz buzz as one to leave as very straightforward and simple.

So I really recommend you just kind of leave it in long form like this and not try to make it fancy

or condense it down to anything else.

OK.

Let's make sure that our tests are passing.

If we flip on over to the terminal.

Yup looks like we got three test passing.

Awesome.

So again classic this was all you got to remember is how the modulo operator works as long as you do

you're going to have an easy time with this question.

So now that we've heard this buzz it's time to move on.

Let's get on our next topic in the next section.
------------------------------------------------------------------------------------------------------------------------------

24. Array Chunk Problem Statement

I'm really excited about the next prong are going to work on because it's one of my personal favorites

in as much as you can have a favorite interview question.

So inside my code editor I'm going to find the chunk folder and then open up the index G-S file inside

of it and then of course before we forget we'll also flip on over to our terminal and start up our tests

as well.

So just showing tested.

Yes.

Dash dash watch like so and just make sure that you have.

Let's see five-Test popping up.

That's how many we have for this particular exercise.

So let's look at the directions here inside the index file.

You'll find the directions at the top.

So given an array in a chunk size as arguments and so look at the chunk function right here it accepts

an array and the size as argument.

Using those we want to divide the array into many sub arrays where each subarray is of length size.

So in other words we're taking one big array and splitting it into many smaller substrates that are

all contained within one larger array.

This function is probably easiest to understand when you start looking at some examples.

So let's do exactly that.

Let's look at the first one right here.

If we call chunk with an array of the numbers 1 2 3 and 4 and specify a chunk length of 2 then we should

end up with one big array that contains smaller arrays inside of it.

And so these smaller arrays are what we would refer to as the sub arrays each separate is of length

2 because two as we passed in as the size.

Notice that the two here is specifying the number of elements that go into each chunk.

It's not specifying the total number of chunks.

So to write here doesn't mean that we should have two separate chunks.

It means that there should be two elements in each chunk.

Perhaps the next one gives a little bit better example in that regard.

So in this case we have 1 2 3 4 and 5 and we still have a chunk size of 2.

So in this case we put two elements into the first chunk two elements into the next junk and there's

only one element remaining.

And so we take that one last element and put it into its own chunk at the very end and then you can

see this repeated throughout the other examples as well.

Another good example might be the one down here second to the bottom.

So we have one two three four five and a chunk size of four.

So we create one chunk that has one two three four elements inside of it.

And the only remaining element goes into its own chunk.

So in other words if you have kind of an orphaned element or you don't have enough elements to fill

up its own chunk that's totally fine.

You just stick it into its own chunk at the very end.

So that's pretty much it.

That's the challenge.

This is definitely a harder problem to solve.

But nonetheless I'd love it if you gave it a shot.

I'm going to let you kind of take it from here.

Without a lot more input from me.

Consider this a little trial by fire.

But of course if you get stuck at all don't sweat it.

Watch a couple of minutes of the solution and then come back and give it another shot.

So a quick break for you to work on this and we'll look at the first solution in the next section.
----------------------------------------------------------------------------------------------------------------

25. Chunk Solution #1

Hopefully you had some success with that chunk problem.

This is definitely a pretty challenging one.

So if you ran into any issues hey don't sweat it.

In this section we're going to go through one possible solution to that chunk problem.

Now there are two solutions that come to mind kind of easily when I think about this problem.

So we're going to look at one possible solution in this video and then we'll look at another possible

solution in the next one.

Now I think that the difficulty between these two solutions are kind of equal in putting them together.

But I think the second solution so the one that we'll look at in a little bit is probably more challenging

to arrive at by yourself.

So this is another great example of when you know the trick things get easy.

But if you don't know the trick well life is a little bit hard.

OK.

So we're going to look at a diagram.

This is going to describe our first solution.

So let's take a look at this.

So we're going to walk through this series of steps right here.

So this is our algorithm starting at the top and going down.

And as we talk through this algorithm We're also going to kind of trace out how all these different

puzzle pieces are changing or all these different arrays are changing over time.

So it's going to be just a little bit awkward.

Hopefully you can bear with me as I tried to diagram or demonstrate this with some of these shapes.

So let's get to it.

First off we're going to assume that our chunk function gets called with some array that has three elements

inside of it.

And so this green thing right here this is the array that our function is going to be called with.

We're also going to assume that we have a chunk size of two just for the purposes of walking through

this example.

So here's the algorithm we're going to use.

We'll first start off by creating a brand new empty array to hold this kind of chunky version of our

data and we're going to call this thing chunked.

So this is like the chunked version of our array.

So we're going to represent this brand new array that you and I are going to create with this blue box

right here.

And so I will draw an arrow from that step to this blue box to just remind you hey this is the chunka

version of our array.

After creating this empty array we will then start to L to iterate through the original n chunked array

that was passed into our function.

So the unchecked array is this original one right here up top in green then for each element in that

unchecked array we're going to go through a series of steps right here.

First we're going to retrieve the last element in the blue chunk.

So the last element the element that's Furnas to the right hand side.

Now the first time our algorithm runs this brand new chunk array will be completely empty.

So when we attempt to retrieve the last element inside of it we will end up with essentially undefined

will have nothing to show for it.

So the next line is how we handle that we're going to look at that element that we just retrieve the

last element in the chunk array.

We will say that if the last element does not exist or if the last element inside the chunk Drey is

equal to chunk size then execute this step right here.

So we definitely fall into this statement right here because the last element in our chunk doré does

not yet exist for the first time we run through this.

So we're going to execute this line of code right here in this line of code says that we are going to

push a new sub array or a new chunk into the blue chunk to one with the current element that we are

iterating over which is 1.

So this is the for loop that we are iterating through right here.

So we're going to take a new sub array this kind of chunk right here.

We're going to push it in and then we're going to add our first element to it.

And that concludes our first loop through this array.

We now will will iterate through this array again.

So we're going to move on to element 2 right here.

We will attempt to retrieve the last element and chunked.

Now this time it's going to be this blue chunk that we return right here.

So this is the last element in our chunk.

So this time we checked to see if that last element does not exist.

It does exist.

So that's not satisfied.

We then checked to see if the length of that chunk is equal to our chunk size of two.

Well at present our chunk size is 1.

So we don't fall into that case.

So rather than executing this line of code we'll go down to the else case right here in the case says

add the current element which is to into the chunk the last element in the chunk Drey.

So we're going to take two and added And right there.

Finally we'll iterate through the last element inside of our unchecked array.

So this is going to be a 3.

We retrieve the last element in chunked.

So that's going to be the purple block box right here.

We checked to see if its length is equal to the chunk size.

And so now at this point in time there are two elements inside of here and we have 2 a chunk size of

two.

So we do satisfy the if statement right here.

And we're going to run this line of code so we're going to push a new chunk into chunks.

So we're going to take this new chunk shove it in there and then we'll take the current element and

put it inside that.

And now we have nothing else to iterate through with our for loop.

Our original loop right here is now empty.

We've gone through everything and we have ended up with our correctly chunked array right here.

So this is it.

This is pretty much how we're going to accomplish this.

First run through this first solution.

Now again if you came up with a different solution than this one that's totally fine.

Totally appropriate.

This is just one possible solution and one that I personally think is kind of straightforward and easy

to understand or at least relatively easy.

So let's now take a break.

We'll continue in the next section and start to code this solution up.
----------------------------------------------------------------------------------------------------------------------------

26. More on Chunk

In the last section we looked at the diagram to understand our chunk solution.

Let's now continue by coding this thing up.

So inside my code editor I'm going to make sure I'm inside of my shunk index dot js file.

I will open up my function here and we'll start adding a little bit of code.

So remember Step one is to declare a new array that is going to hold all these different chunks.

So I'm going to create a new array.

I'm going to call it chunked to say hey this is the array that holds all the different chunks of data.

Next we will iterate through our original array of elements right here to iterate through the array

we're going to use the four of helper again.

So we'll say for let element of array and then we'll execute some logic inside of here to look out the

last element inside of our chunked array.

So to get the last element inside the chunk array we'll make a temporary variable.

So we'll say last is to say this is the last element inside that array and then you get the last element

inside of there.

We can say chunked at chunked dot length minus 1 like so.

Now the next part is pretty well explained by the diagram over here.

We want to check both to see if that last element does not exist or if its length is equal to the chunk

size because if it is we want to push a new chunk into chunked with a current element that we are iterating

over.

So to accomplish that we can say if last does not exist or if the length of last is equal to our chunk

size remember chunk size appear as an argument.

Then we want to add a new element to chunked or a new chunk to chunked and put our element inside that.

So to do that we can say chunked Daut push and then rather than put a new chunk inside of it and then

add the element ID in we can do both things at the same time.

So we'll push in a new chunk and we'll immediately put our element that we are currently iterating over

inside there.

So we're doing both things in one step.

Now the last thing we have to take care of is the case in which we already have a chunk but it does

not get full.

So in that case we're going to take the current element and add it to the chunk and remember the chunk

that we're discussing is this last variable right here.

So otherwise we will last dot push because remember last year is going to be the chunk that we are currently

working with and we will put our elements into that thing.

Now the very last step and make sure you never forget this.

This is such an easy thing to forget.

Make sure that you return the chunked array at the very bottom.

So we will make sure that we return shopped like some.

OK.

So save this let's check our tests and see how we're doing.

Well hey it looks good to me.

We've got five test passing out five.

So like I said this is one possible solution.

I think that this might be the slightly more obvious one.

Are you whenever I say obvious I don't mean hey this is so obvious you should definitely get this.

I just mean to say this one is probably a little bit more evident than the alternative solution that

we'll look at in the next section.

I do consider the next solution to be a little bit easier to put together and probably easier to understand.

But it's definitely more challenging to kind of think of on your own.

It's one where you can have to sit down and kind of noodle on it for a little bit.

This kind of iterative solution right here is probably one of the first ways a lot of people will think

about accomplishing this.

Now maybe if you thought of a solution like this and you didn't take this entire hey let's look at the

last chunk and see what to do with it.

Well maybe you didn't take that approach but maybe you at least did this kind of let's iterate through

the array and consider each element.

That's what I mean by you know I think this one might be a little bit more common to see in the wild.

So this is one possible solution.

Let's continue in the next section we're going to look at the second possible solution to this problem.

So quick break and I'll see you in just a minute.
------------------------------------------------------------------------------------------------------------

27. Chunk Solution #2

In this section we're going to look at a alternate solution to that chunk problem.

Now as usual we'll make a backup of our solution.

So inside of my current index not just file I'm going to copy my first attempt at chunk I'll paste it

down at the bottom of the file just for records.

Now a comment that went out and clean up the original chunk function by deleting the contents like the

OK so just like the previous section or the previous two lectures in this video will look at this alternative

approach.

We'll take a break and we'll come back and code up the solution because I do want to give you the opportunity

to attempt a solution with this other fashion if you want to.

So let's get to it.

All right now knowledge of this second solution.

Like I said it's a little bit harder to come at this solution on your own unless you are very familiar

or have very recently at least how this function in mind one particular function that has to do with

arrays and this function is called sleights.

So if we call letters dot slice.

So this is a function or a method that exists on all arrays.

We can pass in some start index.

So let's say I start index of 0 and then as the second argument some and index.

So maybe I'll put in three like so.

So this says starting at element 0.

Give me a copy.

That's very important.

We are taking a copy of every element inside of letters from 0 to element 3 but not including element

3.

So in this case element 3 would be the letter D right here.

So take everything from 0 up to element 3 but not including it.

One very common mistake around slice is thinking that the second argument is the number of elements

that we want to slice out of the array.

That is not correct.

If we change say the first Delman right tool 1 we're now taking everything from Element 1 up to but

not including element 3.

So clearly the second argument is not a length here.

If it was a length then we would still see three elements inside our result over here.

So with this slice method in mind we can start to think of a alternative approach to the chunk problem.

So again we're going to kind of sketch this out with a diagram.

I know this is kind of sloppy to do with the diagrams but frankly I can't do animations and you know

fancy Illustrator or what have you whatever you would use to make illustrations so I kind of like just

drawing it out keeps it simple.

So again we're going to start off by creating a empty trunked array and that's going to be our blue

box right here.

Then we're going to create a index variable.

So just some random variable.

We're going to call it index and we're going to start it off at 0.

We will then create a for loop or be a while loop and this while loop will run as long as index is less

than our original arrays length.

And then here's where things get interesting.

Inside this while loop we are going to take a slice out of our original array starting at index and

ending at index plus size will take a slice out of it and then we will push that into our chunk array.

So let's put some numbers to this thing for the first go through.

We're going to start off with the index of 0 and we have a chunk size of two.

So we're going to take a chunk size from 0 to.

And we're going to put that into our array right here.

So our a slice from 0 to 2 on the green array would include everything from 1 to 2 right here.

So take that slice it puts it into our chunked array element one element to we then add size to index.

So chunk size to index.

So the second time around we then restart our while loop right here.

Index would now be equal to 2 and we'd then repeat the process.

So we had now attempt to take a slice from two to four.

And in this case we don't have elements going up to 4.

So it just gives us everything left inside the array.

And we would end up sticking everything in like so.

So I think as far as the code goes with this solution it's probably far less code that we have to write.

And there's really kind of less edge cases that we have to worry about but it really does.

It's all predicated on your knowledge of the slice method.

If you're not familiar with slice in the interview setting.

Well then this would be a hard one to kind of pull out of a hat and imagine if you did come up with

a solution.

I've got to like hats off to you like nice job coming up with this one because this is definitely not

a solution that I think I would come up with on top of my head personally.

So now that we have a better idea of how this works let's take a quick break and then put together the

implementation in the next section.
--------------------------------------------------------------------------------------------------------

28. Even More on Chunk!
All right let's give a shot at our second implementation here by using the slice function.

So I'm back inside my chunk file I'm going to open up my function and we'll start off by following some

of the blueprints that we left over here on the diagram.

So we had said that we would create an empty chunk array and we would create an index variable starting

off at zero.

So inside of chunked or something inside of chunk we'll create chunked which will be our empty array

and it will create our index variable.

Now index is going to be changing over time.

So we're not going to use a concert keyword here.

Instead we use a let keyword because this is a variable that we want to allowed to change over time.

Next we'll set up our while loop.

So we want to run this while loop as long as index is less than the original arrays length.

So I will say while index is less than array length and then inside of here's where the magic really

starts to happen first we'll write out the slice statement.

So this would be the statement that we'll take a slice out of our original array right here.

So we want to slice everything from index to index plus size.

That's the magic that's the hard part right there.

Array that slice produces an array that contains some number of elements out of the original array right

here.

So we can take this slice that gets produced and just stick it directly into the chunked array by using

the push method.

So we'll take this whole thing and stick it into chunked by saying chunked dot push like so and then

make sure you're close off the parentheses on the other side.

Then immediately after that after we do our slice statement right here we need to move on to the next

index.

So we're going to take our index variable and we'll add size to it.

So we're not incrementing by one here where incrementing by the size variable because you want to essentially

take big scoops out of the original array over time.

So say index plus equal size and then remember that one very important step that I would never want

you to forget.

Make sure you return chunked at the bottom OK.

Let's check our tests and it looks like they're still all passing.

So I think you can agree with me that this is visually a kind of more straightforward solution at least

in terms of lines of code.

And as long as you understand how slice works it probably is a little bit easier to understand what's

going on rather than the solution that we came up with before where we iterated through the entire array.

Again I think this would be a harder one to come up with on your own so if you didn't come up with this

hey don't sweat it.

Remember this course is all about just giving you these little tricks and tips because that's how you

get better over time.

You just see more problems.

You learn tips like this and you apply them to future problems that you see.

So let's take a break right now.

We'll continue in the next section and start looking at our next problem.
--------------------------------------------------------------------------------------------------------------
==============================================================================================================

Раздел 9:Anagrams

29. What Are Anagrams?

Our goal here is to check to see if two strings are anagrams of each other.

Remember an anagram is where we take one string and then generate another string out of it that has

the same number and quantity of characters.

So for example if we took the string rail safety and jumbled those letters into this string fairytales

they both use the same number in quantity of each character.

So for example I will find exactly 1 are in both strings.

I will find two ways in both strings and so on.

You get the idea.

Now some special directions on this question in particular is note that we only want to consider characters

we don't want to consider spaces or punctuation like say ex-school exclamation marks or anything like

that so we can completely disregard exclamation marks and spaces.

In addition we want to consider capital letters to be exactly the same as a lowercase character.

So the second example right here is a great example of both those two rules.

So you'll notice right above we have real safety and fairytales are anagrams.

The second example right here has still real safety but with capital letters and exclamation marks.

However we should still consider this to be an anagram of the lowercase fairy tales.

Now just to make sure that you start down the right path.

I want to give you a couple little tips for dealing with these kind of edge cases around characters

and not spaces or punctuation.

And also a quick tip around capital letters as well.

So let's flip over to my browser really quick.

We're going to look at some examples here.

So the first thing I want to give you a quick note on is on the Indiana documentation we have Regg axes

which are short for regular expressions regular expressions can be used to manipulate strings very easily.

And in this case we can use a regular expression to very easily remove all the spaces and exclamation

marks from a given string.

So in this article I'm going to scroll down a little bit and one of the items inside of here right here.

So backslash w specifically shows us how to match only characters and completely disregard any type

of space or any type of punctuation or other symbol for that matter.

So let's see an example of this in practice as a quick example let's say maybe we have a string called

Word and it is the string.

Hi there.

All capitals with a lot of exclamation marks and a space in between right here.

So we can very easily remove the space in all the exclamation marks from this thing by calling word

dot Daut replace and they'll make use of a regular expression inside this.

So I'm going to place a forward slash a square bracket a carrot backslash w a closing square of race

slash G.

And then we will replace any characters like that are that are found with an empty string.

And so you can see that very easily that removes all the extraneous characters from the strings so it

gives us something a little bit more cleaner to work with.

Now the other thing to keep in mind is that we only want to work with lowercase characters.

So a very easy way of making sure that we are working with a lowercase string of beats of chain on the

method to lower case like so and so essentially with these two methods right here we can take a string

that is capitalized with spaces and punctuation side of it and reduce it down to just the bare characters

like so.

So I really expect to you will end up making use of these two methods right here and your solution.

So essentially copy these things down because I really expect you're going to need them.

Now the other thing I want to mention just as a reminder about how we'd generally like to solve any

type of question involving strings and comparison between them is to generate character maps and that

was something that you'll recall we did earlier on in this course.

So just as a suggestion.

One possible way and this is just one way there is more than one way to do this question but one possible

way is to generate a character map out of both the strings you are given.

So for example if we are given the strings hello and I don't know what this is supposed to be.

Li Li Ho I guess I don't know if we build a character map out of both these.

We would end up with 1 h one e two l's and 1 0.

And we would get the exact same character map for Leo as well.

So we could iterate over one of these character maps and compare all the letters inside of it with all

the letters and the other one and the quantities as well.

So I'll leave that one up to you to kind of get through a little bit and figure out.

So there is one last little gotcha around the character maps that you're going to generate here.

If you decide to go with this method let me show you what this kind of edge case is when I just told

you that you would want to compare these two character maps.

You might have thought OK we can iterate through this object right here and then compare all the properties

and values with the properties and values in the other object as well.

So there's one little edge case that I want to throw out there just so you are aware of.

Imagine the case of we were going to compare these two character maps.

So notice I just change the diagram the word over here on the right has changed to close.

So has an extra s on here.

Now imagine if we wrote a loop to iterate only through this object if we only iterated through this

object we would look at the character H see that it has one use and compare it over to this object we

would say OK this one has h as well and it has one uses well within repeat the process for E.

They're the same l they're the same.

Oh they're the same.

And that's it.

We've now finished iterating through this object.

But notice how we completely missed the fact that this other character map has an extra s on it.

So one possible way of solving this problem is to compare first this character map to this one and then

iterate through this character map and compare to this one.

However there is the easier or kind of a little shortcut that we could use to avoid that.

So we don't really have to do a comparison one way on a comparison back to the other.

If you want to know what that little trick is I'm going to say right now what we can do is count the

number of keys that are present inside of one object and compare it to the Keys that exist inside the

other.

So for example this key over here has four legs or letters inside of it.

This one over here has five.

And then another very obvious way of handling this would be to count the length of characters inside

this string and compare it to this one over here.

So just two ways of addressing that issue.

OK.

So we've laid out a couple of notes here.

Now this anagrams question is a rather challenging one.

So do give it a shot but as usual if you get stuck feel free to check out the solution and we'll walk

through how to solve this thing together.

So quick break and we'll continue with the solution in the next section.

--------------------------------------------------------------------------------------------------------------

30. Solving Anagrams
I'll read my friends hopefully anagrams was not too bad.

This is a rather challenging question.

It is challenging but it's also one that I can almost guarantee that you would see in an interview setting.

So if you go on like 10 interviews I would personally be surprised if you didn't get asked this question.

So it's definitely a very good one to keep in your back pocket because you never know when it's going

to be asked.

So let's talk about her solution here by using character maps.

We're going to build a character map out of string A and string B and then we'll compare all the characters

inside those two maps together.

So let's start off by giving ourselves a little bit of space inside this function.

Now we're going to need to make a character map out of both of these things right here.

So the first thing I'm going to recommend is we don't really want to build two for loops to iterate

both through string A and string B instead.

A really easy way to save ourselves the pain of having to write two separate four loops to iterate through

each string right here would be to write a helper function to build a character map for us.

Now if you didn't make a helper function if you wrote out two character map assemblies inside this function

already that's totally fine.

But the interview setting interview is kind of like to see you create helper functions and it kind of

also allows you to better segregate or compartmentalize your code which is always helpful in sort of

an interview.

I have some other tips around creating helper functions that we'll talk about later on in the course.

They're actually kind of a great thing to keep in mind in an interview setting.

So let's first start off by making a helper function here.

And we're going to use this helper function to build a character map for a given string.

So we only have to write this logic one time and then we can use both on string A and string B will

say function build char map and we'll pass a string in to that function.

Then inside of here we'll create an empty object that will serve as our character map we'll then iterate

through our string and for every character inside there will add it to our character map.

Now one other thing to keep in mind is that we had said that our string needs to be only considering

lowercase characters and we also need to strip out any spaces or any punctuation.

So we certainly could do something like create a cleaned string ahead of time and do the Ragg X and

the two lowercase call right here.

But one easier way of doing it or maybe not easier but a slightly more compact way would be to tuck

that kind of Clean-Up logic directly into a for loop itself.

So let's look at what that might look like.

You could say let char of string dot replace.

So this is where we're going to do that replace in lower case logic logic just right here in line with

the for loop.

So we will replace forward slash square bracket.

Carit backslash W..

And then on the other side of the square brace we'll put a forward slash G.

So note that everything inside of your code editor should very likely turn into a slightly different

color when you've got this regular expression put together correctly.

So any time that we find a character that is not a number a character Kapell character or a lowercase

character we want to replace it with nothing or essentially an empty string after we've done that Clean-Up

logic.

Well then take the entire string and turn it to lower case like so you no open up our for loop.

Ok so now we're iterating only over the portions of the string that we really care about and remember

how we put our character maps together.

We take our character map we assign a key to the character map of the current character that we're looking

at and then we increment the value out that character.

So we'll say char map at char is char map at Char plus 1 and then we need to handle the case in which

this particular character has not yet been assigned to the character map.

So to say or one like so then very important.

I can't stress this enough because when you're in a high stress setting like interview or even when

you're practicing these problems yourself at home.

So easy to make tiny little mistakes so I I know it might be annoying for me to remind you all the time

to get the return statements in here but honestly you have no idea how often people just honestly forget

to put in a return statement so I will harp on that throughout the course.

I apologize if that is annoying.

OK so we've got our helper function here to build up our character map.

Now we can use it to produce a character map both string a and string B.

So let's declare a variable let's call it a char map will be build char map from string a and b Schar

map will be build char map from string B.

So we've now got these two character maps and it's now up to us to compare the two of them together.

The other thing that we still need to keep in mind is that kind of edge case that we mentioned at the

end the last video where if we only compare this object to this one we might miss out on some extra

entries inside the second one.

So I had mentioned that an easy way to solve this is to either compare the length of the two character

or the two strings.

If we do that do you remember that you would have to compare the length after subtracting out spaces

and punctuation.

So if you want to take that approach you can do the same kind of replace in two lowercase for both strings

up here and then compare the length of the two of them.

Another possible approach would be to look at the number of keys inside of both these maps and check

to see if they are identical in length.

So that is the approach that we're going to go with so we're going to pull out all the keys from both

these objects right here and we'll count the number of keys that is contained in both.

If you've never pulled out the number or the schism if you never pulled out the keys inside an object

before that's totally fine I'll show you how to do that.

Let's look at a quick example.

So if we have an object that would call just O.B. J.

And it has keys a b and c we can get a list of all the keys inside this object by calling object.

Notice that is a capital O object.

Keys will cast an object like so.

So that returns an array with all the keys from our object.

If we then call DOT length on that.

Well then we can very easily tell how many keys exist inside of our object.

And so this is the solution that we're going to use to address this problem of some extra character

existing in one character map or the other.

So we'll get the number of keys inside this character map the number of keys and this character map

and then can compare the two together.

So in practice will put a little if statement here will say if object we use for aid char map length

is not equal to object.

Keys for the char map length.

Well then we must know that we do not have an anagram because they have a different number of characters

or maybe a better way of putting that would be to say one character map has an extra character type

that the other one does not.

So if that's the case we'll just immediately return false from this function.

Now if they do have the same number of characters that we want to proceed with the map checking process

in which we will look at each one of these characters and compare the number of uses that it has to

the other map most part might sound like it's kind of challenging.

You know this I know that when I kind of see that with words you know I put it in a plain-English it

sounds like it's something is challenging but honestly I think you know how to do this I think this

is something that you definitely can do what we have to do here is to iterate over one char map look

at every character inside of it and then compare it to the other Charmel.

So we're going to iterate over a char map and really we could iterate over either one it doesn't really

matter here we just have to pick one.

In this case we'll iterate over a char map.

So save for let char and then don't forget here a little.

Gotcha.

And if we are iterating iterating over an array We use of.

But if we are iterating over an object we use in and remember that what's the term for it not anagram.

We're we're working at anagrams.

I know it's going to come to me.

The little trick for remembering which one to use.

If we are iterating over an object We use of which is really confusing because 0 starts where object

starts with oh so you would think that you would use of to iterate through an object but that's not

the case.

So for an object we use in which is kind of doesn't line up with the first letter in that word right

there.

I know that's probably an awful way of remembering but that's what I use.

So look through a char map and if a char map at char is not equal to the char map at char then something

must be wrong.

So let's say we're iterating through a char map and the first character that we look at is the letter

A.

We say how many times has a been used inside of HRO map if it has not been used the same number of times

and of the term map.

That means that something must be wrong or these two things do not line up at all.

So in that case we can't immediately return false

OK.

Now the last thing and again I know I'm harping on the return statements here but this is another very

easy one to forget.

Notice how we set up here inside the directions that we need to return true if they are anagrams and

false if they are not.

So we've handled the cases in which they are not anagrams by basically returning false.

And the thing that we cannot forget is that if we succeed in both these checks right here that means

that they must be anagrams.

And so in that case we should return true.

Like so.

OK so this is our solution this is solution number one for solving anagrams.

Let's check our tests.

It looks like they're all passing which is fantastic.

So I think that is going to work out just fine.

Now in the last video I had mentioned that this whole anagram question and the two solutions that we're

going to look at is kind of nice because it frames some later content that we're going to discuss in

the course.

So I want you to kind of look at this solution right here.

Very quickly when we look at it you'll notice that if we consider the number of times that we have to

iterate through either these streams right here we iterate through string a one time to build our character

map we iterate through string B one time to build our character map and then we iterate through one

character map to do the final comparison here.

And so I just want to very quickly point that out because we are going to come back to this question

or this solution right here later on in the course and I'm going to just kind of point out some interesting

things about the way that we solved this problem right here.

And the way in which we solve it in the next section because we are going to look at a second solution.

So if any minds let's pause right now we're going to continue the next video and we're going to look

at another way of solving this problem that is far far easier.

But it does run into some interesting issues that like I said we'll kind of consider later on in the

course.

So a quick break and we'll tackle that second solution in just a moment.
--------------------------------------------------------------------------------------------------------------

31. Another Way to Tackle Anagrams

All right.

Time for a solution or two to anagrams.

So this one's going to be a little bit more straightforward.

Well I should say a lot more straightforward but like I said at the end of the last video it will run

into some interesting performance concerns.

That is something that we're going to kind of use to frame another topic later on in the course.

So the first thing we're going to do is a little bit of clean up of our indexed not gigas file.

So I'm going to take both the anagrams function and the build char map function.

I'm going to highlight it all.

I'm going to cut it.

I'm going to move it to the bottom of the file and I'm going to comment both those functions out.

So I do want to keep these around just for record keeping.

Honestly it's for you for the future when you come back and review this stuff if you choose to.

But we'll keep it there.

And then we do need to redefine the function anagrams because we cut and pasted the entire thing.

So call string A and string B like so.

OK.

Seligson.

Now the second solution for handling anagrams.

Like I said is going to be a little bit more straightforward but like many many things that we've seen

inside this course it all depends upon knowing one little trick.

So let me show you a little trick.

It's going to flip on over here.

I'm going to make an array and then we're going to look at one specific method that exists on array

an array that will make solving these anagram things pretty straightforward.

So let's make an array of numbers and I'll give it about ten thirty five negative ninety one 10000 where

that is.

So here's the interesting function.

I want to show you where you look at numbers dot sort.

So when we sort in array it will take all the elements in the array.

And your javascript runtime will do its best to figure out how to somehow meaningfully sort the characters

or I should say the elements within that array now sort cannot only be used with numbers.

It can also be used with characters as well.

So if we had instead like Z c b d y and then we sort it we end up with alphabetical order.

And so this alphabetical order is what really forms the basis for this alternative solution to anagrams.

So here's we're going to do.

We're going to take our two inputs.

So in this case like maybe rail safety and fairy tales we're going to clean up both strings by replacing

or I should say removing any spaces or punctuation.

We're going to lowercase both strings and then here's the magic part.

We're going to sort both strings.

So when we sort both them no matter what characters we have inside they will end up in the exact same

order.

If the two sorted strings are then completely identical then we can say that we have an anagram and

so when you take this solution we you and I don't even have to do some four or Luper iteration or anything

like that to look at every single string.

We can just sort both these strings and then say that's it.

Compare the two.

We're done.

I think the best way of covering this solution will probably be to write out some code and then we can

copy that code over to this little editor over here and see it in play.

I think that will be the best way of handling this.

So let's get to it.

So again I'm going to make myself a little helper function to automatically kind of clean up each of

these strings.

So remember that kind of replace statement and the two lowercase statement.

And in this case doing the sorting of the string as well.

So I don't want to duplicate that logic inside of this anagrams function so I'll make a helper function

to do all that for us.

So don't I make helper function called Clean string.

It will be called with a string.

We're going to return the string.

We're going to replace and this will be our regular expression again.

So do forward slash square brace square bracket

carrot backslash W..

And then on the other side of the square bracket forward slash G and we'll put an empty string inside

there as a second argument.

Next we'll do a two lower case and now before we attempt to sort this thing remember we just looked

at the sort method that is a method that belongs to arrays not strings.

So we do have to temporarily turn this string into an array sort it and then turn it back into a string.

So we will split this thing on an empty string we'll sort it and then we will join it back together

into a string.

So that's a lot of statements chained together into one.

Remember when we consider chaining of methods in javascript we read it essentially from left to right.

So first we call replace then we call to lowercase on that then split then joint Simien then split then

sort then join.

I think maybe as a quick little test we should copy this over to that little code editor and just see

how this thing works.

So back over here I'll make a short string let's say Konst as TR is b c r c d do a real example.

Hello there.

So then if I paste that snippet.

So here is string replace to lower case all that stuff.

This is what we end up with right here.

So if we then consider some anagram like let's say string two and this one is there.

Hello.

So these two are clearly anagrams of each other.

Remember we are completely ignoring any punctuation.

And so if I then do string two and then that whole chain loops let's clean that up.

There we go.

So now I've got two strings I can very easily compared to each other and in this case you can see very

plainly.

Yeah they've got the same characters in the same order so they must be anagrams.

However if I start to add in characters to one of the other.

Well this is clearly no longer an anagram because these two sorted strings over here are no longer equal.

So now the last thing do is to figure out how to actually do that comparison between the two strings.

So again you might be thinking OK we have to loop through one string and we have to compare every character

to the other string.

Well no it's actually a lot more straightforward than that.

We will call clean string will pass in string a and then we're going to make it take advantage of the

equals equals equals operator.

So compared the cleaned up string a string the end if the two are absolutely identical.

Then we must have an anagram.

So essentially what we're doing with this line right here is to compare these two strings together.

So of course if we wrote out let's do this actual statement if we wrote out is that equal to that well

then we get true.

So that's essentially what we're taking advantage of here.

We don't have to compare this in character by character.

We're going to say hey is this string identical to this string.

Yes they are.

OK well then we must have an anagram.

And of course last thing never forget it.

Don't forget that return statement.

Most important part.

OK.

So this is the alternative solution.

You know this is another one where once you see the trick once you understand OK we can split it into

an array sorted and then join it back together and then compare the two results.

This is a real easy you know maybe relatively easy solution to remember probably a little bit easier

than remembering how to build a character map on the fly.

So yet again out of so many examples that we've already seen in this course and so many that we will

see as we go through.

Once you've done these problems one time you learn that little trick and you'll be able to solve it

more easily in the future on an interview.

Now very last thing I need to save this file and we'll check our tests.

So back at the terminal it looks like all six Tests are still passing here.

Fantastic.

Great.

So this has been the anagram problem again.

Very common one that I would really expect to see in an interview setting.

Let's take a break and we'll continue to our next question in the next section.
------------------------------------------------------------------------------------------------------------------------
========================================================================================================================


Раздел 10:Sentence Capitalization

32. Understanding Capitalization

The last problem that we worked on was a little bit more challenging.

So in this section we're going to go live take a little bit of a breather with a slightly more easier

problem or at least one that is certainly short in nature.

Not many lines of code are required for this one.

So inside of my exercises folder I'll find the capitalize directory and open up the index file inside

there or then change on over to my terminal and I'll make sure that my tests are running over here by

running the command just capitalize test.

J.S. dash dash watch and we should see about three or four tests start to run.

So it like yeah three tests right here.

So let's look at this problem.

Now this one is a little bit more straightforward but I think that it's one that appears at first glance

to be very easy but in practice it does require at least a little bit of thought.

So the goal is to write a function that takes a string.

We want to capitalize the first letter of each word in that string and then return the capitalized version.

So for example a short sentence which is all lowercase should turn into Kapolei short with the last

sentence with the capital S..

So essentially just capitalize the first letter of each word.

That's pretty much it.

Like I said at first glance it looks really easy but once you start pulling together well it might get

a little bit more challenging.

Now I'll tell you right now that there are two distinct solutions that we're going to look at this problem.

The first one is going to will say that the first I'm thinking of them out of order here but I'll say

that the first one that we're going to look at is pretty concise.

It's rather few lines of code and it's rather easy to read.

But that solution requires a pretty good knowledge of the JavaScript standard library for working with

strings.

The second solution.

The second one that we're going to look at is kind of easy to reason about but it does require a kind

of nasty looking for loop and it's kind of hard to tell exactly what's going on with it by just looking

at the code.

So I'm telling you right now that you can either take a slightly easier to read solution by having a

good understanding of the JavaScript standard library or you can take a slightly more challenging to

read version that just kind of brute forces it and makes it happen.

So before I let you go I do want to give you a little tip or two on how to approach that kind of easier

to read solution.

And I want to point out to you a couple of methods that belong to the standard library that you might

want to be aware of.

So the first method that we're going to look at and again we are at the India and India documentation

page is the slice method belonging to all strings.

Remember slice can be used on a string.

It will take some number of elements out of that string.

The first argument is the index of that string to start from.

And then there is an optional second argument of the end index.

If you don't provide that second argument right there then the rest of the string is just automatically

included.

So where would this be useful.

Well let me show you a quick example of it.

Let's imagine that we have a word of simply there.

If we do we're slice with simply one.

It gives us everything after the T.

Now if we wanted to get just the t we can look out word at 0 and now the part that you really need to

be aware of.

Remember we have access to the to upper case function like so.

So very quickly I think you can see how we can take a lowercase word like this and start to capitalize

just the first letter.

So here is clearly a capital T.

Here's the rest of the word and I'm sure you can figure out how to join those two together.

So these two methods right here will lead you towards a rather straightforward solution.

Again this is not the only solution you can take a little bit more brute force one and this but certainly

give this a try.

So I'm going to let you kind of roam free on this one.

Give it a shot and I'll catch you in the next section and we will go through the first solution.

So quick break and I'll see in a minute.
-----------------------------------------------------------------------------------------------------------

33. Capitalization Solution #1

OK hopefully you had some success with this problem.

Like I said you might have found that it is a little bit more challenging than it appears at first glance.

However I do hope that you came together with a good solution in the section we're going to walk through

one possible solution very quickly.

We'll then take a look at an alternate solution in the next video as well.

So for this first solution let's look at some pseudo code that will kind of guide us in exactly what

we're going to do.

We're going to start off by making an empty array that we're going to call words.

This word's array is going to store the end result of the final kind of capitalized words that we are

dealing with after we create this.

Words.

Empty array.

We will then take the original string that was passed into our function and we'll split it by the space

character to get an array of words.

So each of those words are what we're going to try to capitalize.

We will then loop through that an array.

We will uppercase the first letter of each word.

We will then join that first letter that is now capitalized with the rest of the word.

And then we will push the result into that original words array that we created at the very beginning

after we loop through each word.

We will then join the words array together into a string and then we'll return it from the function.

So that's the general idea here.

Let's give it a shot.

Back inside my code editor I'll get myself a little bit of space.

We will declare an array of words that's going to start off as empty.

We will then loop through our string.

So we do need to split it by spaces.

Remember if you split by spaces we can do so by.

Let's say we have Konst sentence and our string is something like.

Hi there buddy.

We can call a sentence dot split and then rather than splitting on an empty string as we have done many

times in this course we will split by a space character instead.

And so now we're working with three individual words.

And that's what we want to do here.

So we're going to save for.

Let word of string dot split with a space.

So now whatever string gets passed in here assuming it is a sentence that is split by spaces they will

be split up by this split statement.

Next we will take the first character of each word so word at 0 and we will uppercase it by calling

two upper case then we will join it with the rest of the word and we can get the rest of the word so

everything minus that first character by using the slice function.

So we'll say word dot slice with one which means give me everything from the element at index 1.

So that's not the first element that's the second element.

Everything from index 1 onto the last character in the word.

So we're going to join us to get two together and then we will push the result into our words array.

So I'll say words.

Push and push the results into that.

Then finally at the very bottom after we have iterated through all these different words we will take

that word's array we will join them together with the space character.

So note that again this is not an empty string.

Here we are joining all of these different words together with the space character.

We will make sure that we return the result.

So let's see how we're doing.

OK.

Three-Test passing looks good to me.

OK.

So like I said this is the easier I think or maybe the more direct easier to read solution of the two.

Let's take a pause.

We're going to come back in the next video and we're going to look at another solution that is just

a little bit more effort goes into it.

But it's one that I think is much more easier to arrive at or I think that one it's easier to kind of

picture the other solution.

It is harder to code.

That's what I mean to say.

So let's take a quick break and then attempt that solution in the next video.
---------------------------------------------------------------------------------------------------------------

34. How Else Can We Capitalize?

In this video we're going to take another look at the capitalized function and come up with a slightly

different solution.

So as usual I am going to back up my result here by copying it down to the bottom of the file and commenting

it out.

I will then clear out the contents of the capitalized function like so.

All right let's look at a diagram that's going to help us understand this alternative solution.

So here we go.

Cascio here's a serious sequence of actions this time around.

We're going to start off by creating an empty string called result.

So notice that in this case we're creating an empty string not an array.

We are then going to iterate through every character in the string for each character.

We will look at it and we'll say in the character to the left of the current one.

So whatever still left is that a space if it is a space then we're going to take the current character

that we are iterating over.

We'll capitalize it and we'll add it to the original result string.

Otherwise if it is not a space to the left of the current one then we'll just simply take the character

and added to result without capitalizing it.

So essentially we can imagine a string.

Say hi there.

When we look we iterate through this thing and let's say we look at the character eye right here.

We'll look at the character to the left of it.

That's an H.

It is not a space.

So we're going to say no problem.

Just add in to the result string.

We'll then move onto the space.

We don't care about the fact that this thing is a space.

We're going to look to the left of it see that there is an eye there and we'll say OK that's an eye.

We don't need to worry about it.

So we'll take this character and add it into result then we'll move on to t with t look to the left.

We'll see.

Oh you know what that is a space.

So we're going to capitalize T and then add it into the result string.

Now this solution right here has one very big weakness to it.

One very big weakness.

I'm going to ask you if you can kind of find it right now based on a description I just gave you.

The problem with this solution is that it doesn't work well with the very first character.

So when we are capitalizing a sentence the very first character should always be capitalized.

So if we try to look to the left of the first character well there's nothing to the left and so we will

never attempt to capitalize it even though it absolutely should.

So 8 easy way to solve this is to say that when we create this initial string result rather than creating

it as an empty string we should create result which is the first character of the input string capitalized.

So that's how we're going to get around that little limitation when we create this first result string

the very the only content it's going to have will be this first character or just going to immediately

capitalize it.

Then when we start to iterate through the rest of this array of characters here we'll start with the

first character or I should say the character at index 1.

The second element and consider everything from here moving forward.

So the downside to this approach is that it will require a manual for loop.

We cannot use a for loop in this case because a for loop is always going to attempt to iterate through

every character.

And in this case we don't want to iterate through every character we want to skip that first one.

So little bit of a downside here.

But such as the way.

All right.

So let's give this a shot.

Back over my code editor will first declare this starting string that we're going to call result.

So say let result and it's going to take the first character out of string and automatically capitalize

it because that first character we always want to capitalize.

So we'll say string at zero dot to uppercase like so.

Now we can iterate from one to the length of the string.

And for every character will look to the left of it and decide whether or not we need to care to capitalize

the current character.

So we'll say four letters.

I equals one.

I less than string dot length plus plus.

Now we'll look to the left.

We'll say if at string I minus 1.

So this is to the left of the current character.

If that thing is a space then I want to take the current character that we're looking at.

I want to uppercase it.

We have two upper case with a capital C and then I'm going to add that on to the result string by saying

result plus equals like so.

If the character to the left of the current character is not a space well in that case we want to just

add it on to the results string by saying string as I like so.

And now if you look very carefully at my function I'm missing the most important parts.

The return statement down at the bottom don't forget it.

So will return results.

All right let's look at our terminals.

Our tests are doing looks good to me.

So yeah this looks like a reasonable solution here this solution.

I'm not super happy with personally because it is kind of weak against you know assuming that that first

character always needs to be capitalized.

You know what if for some crazy reason we are attempting to capitalize a Spanish string or something

like that.

You know I say Spanish because they've got you when they do a interrogative sentence they start off

with a question mark like you ok tall like so.

So clearly in this case that first character we wouldn't really want to capitalized because it is a

question mark so you know but hey I'm not I don't think we can really clear claim that this solution

would address that as well.

I guess I'm just not super happy having this thing being hardcoded to always catalyze the first character.

I don't know just kind of natural engineering judgment.

I feel like it's a little bit off anyways.

At the end of the day I would still claim that this solution is harder to take a glance at and really

understand what's going on.

I think that the solution right here.

The first thing we worked on is very legible and I think that it would be pretty reasonable to hand

this solution to an engineer.

Ask them what is going on.

And I think they'd be able to give you a reasonable answer as to what's happening here and I don't think

that's really the case with the solution up here.

But hey to each their own.

OK.

So that's their solution to the capitalized sentence function.

Let's continue with our next example in the next section.
----------------------------------------------------------------------------------------------------------
==========================================================================================================

Раздел 11:Printing Steps

35. The Steps Question

I'm really excited for this next problem because the next problem we're going to work on is very closely

related to the one after that.

So we're going to have two questions in a row that are extremely closely related.

The first version is going to be kind of a easier version of the problem and then the second one is

definitely much more challenging in my opinion.

So we'll get kind of like the warm up and then the real deal immediately after that.

Now even the warm up is still kind of a hard problem and it is also definitely a problem that I think

is very common to see our interviews.

So they're both very useful but it's going to kind of prep us for the tougher ones.

So I think it will be a nice little build up.

So inside my code editor I'm going to find the steps folder and then I'll open up the index file inside

there.

And I think you know exactly what else we need to do.

We'll start up our test with steps test Scott J J.S. dash dash watch lifeso and we should see a number

of tests running in this case about four by the way just to clarify the reason I always point out the

number of tests is just to help you make sure you don't make a typo in like you know the test file name.

If I do a step slash test dodgiest then it's going to say Oh hey I can't find any tests to see you know

that's why I always happen to mention that.

Anyways let's take a look at this problem.

So the directions are to write a function which is kind of already done for us that take an argument

of a positive number.

Or in this case really an integer n so some positive number the function should then cancel log.

So key statement there we need to console log a step shape whatever that is with and levels using the

pound character.

So in practice you know the directions are kind of hard to read.

It's a lot easier to just look at the examples right here.

Basically is what we want to do.

So if we call steps with two I want to see like pounde and then on the next line pound pound and so

they're supposed to kind of form a visual staircase you know where the steps are the actual pound symbols

here.

That staircase is a little bit more evident on some of these larger number ones down here so like you

know first step second step third step fourth step the number just to be clear is the number of lines

that we want to log.

So we pass into I want to see two lines of steps we pass and three we've got step one step two step

three.

The other thing that is extremely important and the other thing that makes this problem a little bit

more challenging is the fact that we if we have like just one step right here out of two total there

has to be a space character to the right of it.

See there's a space character right here with Steps 3.

We should have a pounds and then one space and then two space.

So you can very easily kind of quickly realize that the number of characters in the strings is always

going to be square.

So we've got three console logs down for end of three and we have three characters from left to right.

So character one character or two in character three that's really important.

Don't forget that if you only log out just the bare minimum here of just the pound symbols the tests

are going to fail so the tests specifically want to see the correct number of empty spaces to the right

hand side.

And that was important because like I said the next problem that we're going to work on is very closely

related.

And the next problem is going to kind of build on this idea of making sure that you actually print out

your steps here.

So make sure you do that.

OK.

So that's the problem.

In this case I think that this is one that really just requires a little bit of thought on your end.

So there's not necessarily any big tips I want to give you ahead of time.

I'm going to I'm just going to let you give this one a stab.

Remember that much earlier in the course we walk through the technique of placing a debugger statement

so that you can kind of work with your code and see what it's doing.

And remember the directions for that are in the diagrams for this course.

This is a problem where I very highly recommend you use that debugger technique if you get stuck because

it's going to be really easier to help you figure out exactly what's going on as you run through your

code.

So let's take a break here.

Give it the best shot you can.

Remember if you get stuck.

Don't sweat it.

Just go solution Watch a minor to the solution and then take another stab at it on your own.

So quick break and we'll go over the solution in the next video.
--------------------------------------------------------------------------------------------------------------

36. Steps Solution #1

All right hopefully you had some success with this exercise.

One quick thing that I want to mention here is that the intent was that you should be making multiple

console log statement calls.

So we are not assembling one string and then escaping it with like a newline character at the end.

We are making multiple strings and cancel logging each of them.

When I say multiple strings I mean one string for each kind of set of steps here or each level to the

staircase.

So if you saw some error message saying Hey I expected you to call stairs more often or something like

that that's probably why you were seeing the message.

Make sure you are logging each independent level.

OK.

So in this section we're going to go through one possible solution.

I think that this is definitely the easier to come up with solution that we're going to go through first

after we look at this solution.

We'll then take a look at an alternate way of solving this by using a little bit of recursion.

I think that the recursion solution here is ultimately maybe a little bit easier to come up with and

put together.

However it does require to kind of use your recursion skills to think of which is definitely quite challenging.

So anyways we'll do the iterative solution first and then take a look at the recursive solution.

So let's look at a diagram that's going to help us understand this iterative solution.

So the first thing to recognize here is that we are kind of dealing with a matrix of sorts or kind of

like a to d array.

We're not really working with the race here.

We're always working with strings.

That's what we are assembling.

But it's helpful to just kind of think of it in terms of like indices.

It's going to make it a lot easier to come up with the actual solution.

So here's the idea.

First we want to recognize that we're going to have some number of columns in the rows that we want

to iterate through.

So this would be row one right here and then row 2 and row 3 and then we are also kind of going to want

to iterate through some number of columns so call them 1 call 2 and column 3.

I came up with the nomenclature saying that we will reflect the current row that we are iterating through

with a variable that we're going to call I.

And then the current column with a variable that we're going to call J.

One very easy way to make your solution look much more straightforward and you what I think that we'll

probably end up doing this rather than calling is i and j.

Because that's kind of tough to remember.

Let's call this like row and column that makes life a little bit easier.

I think that's going to be a little bit better.

OK.

So then mind let's take a look at exactly how we're going to do this.

First we're going to write a for loop the first for loop that we're going to write is going to iterate

through all the different rows that we have.

We're going to iterate from 0 to N and we'll call this you know we'll say specifically iterate through

rows then for each row that we are considering.

So let's imagine this particular row right here.

We are going to start off by creating an empty string that we'll call stare.

Now Syria is meant to be singular like just stared by itself to indicate that this is one individual

row that we're looking at.

Then we're going to iterate from 0 to and again in this case this second for loop right here is meant

to iterate through all of our different columns.

So from left over to right then inside this inner loop will say if the current column that we are looking

at is equal to or less than the current row we want to add a pound.

So this is kind of like the big jump in logic right here.

This is kind of tough part is this if statement.

So I want you to look very carefully at this thing right here.

We have columns 0 then column 1 column 2.

Let's add a little bit of numbers on here just to make that all that easier.

So do a copy so we'll say see 0 meaning column zero.

I'll put that right here and then we'll put rows 0 right there and then I'll just do two others with

this nomenclature we'll put our one right here.

We'll put still sees zero right here because we're still in column 0 and then just one more we'll put

Rozier show over here and see one right here.

So when you start working on these problems where you are kind of iterating through two sets of rows

and columns especially I honestly I want to use more generic terms but any time instructing in terms

of row and column you want to start seeing if you can see a pattern of any sort here.

And so if I start thinking about a pattern between which of these squares or which these characters

are supposed to have pound which are supposed to have a space.

The first thing they start to notice is that we want to have a pound.

If C has a value that is equal to or less than R and we can see that in a very quick action here.

So C is equal to our.

So we get a pound.

In this case C is less than our So we get a pound.

But over here C is greater I said poun excuse me C is greater than our row.

So we get a space instead and that's the pattern that we're following all throughout this thing.

So even when we start going down to the very bottom right corner down here.

So down here we would be working with column two and road 2 right here.

So still we are less than or equal to the row count.

So we're still going to get a pound down here.

So that's basically the row that we're going or the rule excuse me that we're going to use if we do

not meet this if statement right here.

Dan Rather than adding a pound we must be on this kind of upper right hand triangular section up here

in which case we want to add a space rather than a pound and the last kind of Keats.

The problem here is that after running through this for loop where we iterate through all the different

columns we will take that stair or that kind of row representation of this one line that we have and

we will con. log it.

Then we go through the next iteration or move onto the next row we're going to read it clear that Stehr

variable as a new empty string.

So that's very much the solution.

Again this is just one possible solution.

There's definitely more than one way of doing this but I think that this is a relatively straightforward

way of doing it.

So let's take a quick break right now.

We'll continue the next section l put together the implementation for this solution.
------------------------------------------------------------------------------------------------------------

37. Steps Solution #1 Continued

In the last section we looked at one possible solution to the steps problem and this section we're going

to start to code up.

We'll get through this solution pretty quickly and then we'll move on to an alternative solution that

I think is a little bit more interesting in the next section.

So let's get through this one.

Now I want to use the steps that I've written out over here so we can very easily read through them

as we put together the solution.

So I going to kind of place my Windows ever so slightly so you can see both them at the same time throughout

this course.

You've seen me put together several diagrams like this that kind of use pseudo code to walk through

a solution.

I hope that you're definitely getting a sense of how you might put these together yourself in an interview

setting.

Anytime you're in an interview setting especially at a white board I highly highly recommend.

I can't say enough.

I highly recommend you try to write out a possible solution with pseudo code or like basically plain

English before attempting to code it on the white board.

When you use pseudo code pseudo code to outline your solution it's going to more easily communicate

what you're trying to do to your interviewer and your interviewer might be able to help you catch errors

rather than if you went straight into a code solution and they're both helping you try to catch errors

but also understand what the heck you're trying to write with code.

So in general I highly recommend you try writing out a pseudo code solution.

All right let's give this a shot.

So we're going to start off first by iterating from 0 to N and this is intended to be the current row

that we are operating on where row is like one string set OK.

So we'll say four let row equals zero row less than an ROE plus plus.

And then inside of here for every different row that we are going to operate on we're going to create

a completely empty string.

A brand new string that we're going to call stare.

Now we could call Stehr anything else.

Honestly I just you know maybe you would be better to call it step or something.

I thought Sarah was still reasonably related to the problem but different enough from the function name

of steps like steps and step there a little bit too close.

So I would definitely not you step personally so we'll say let's stare because going to be an empty

string.

Next we're going to iterate from zero to N and this is intended to be our iteration through all the

different columns that we're going to work on.

So for left column starting at zero column less than n column plus plus.

So for each column we're going to write an IF statement we're going to say if the current column that

we're looking at is equal to or less than the current row.

So if the current column is less than or equal to the current row then we want to add a pound symbol

to the stair string.

So we'll say stair plus equals pound.

If column is not less than or equal to RHO then we're going to instead add a space.

So else stare plus equals space and make sure you have a space here not an empty string.

It is supposed to be a space.

Make sure you have a character inside there.

Finally after we process one entire row.

So this is the row processing step right here we have processed the entire row.

We have now assembled a full stair string.

We need to make sure that we can still log it it's console log Stehr make sure that you are logging

Stehr still inside of the road for a loop because we want to end up with an number of console logs like

in the case of passing and for here we want to end up with four console logs.

So I don't want to put the console log at the very bottom of the function.

I want to still be inside of my for a loop so that I get one console log for each row that we are attempting

to assemble here.

OK.

So this looks good.

Let's save this we'll run our tests and see how we're doing.

So back over here in my terminal you can see that we got a lot of the console logs from the testing

code and I've got four test passing which definitely makes me feel like we've got the right solution.

So this is looking pretty good.

This is one possible solution.

If you are in an interview setting this is probably a type of solution.

I recommend you go for.

It's very easy to reason about.

It's easy to troubleshoot.

Pretty reasonable.

Having said that we are going to look at an alternate solution in the next section that uses a little

bit of recursion.

This next solution is going to be a little bit more tricky and just because it is tricky I generally

recommend not going straight to the solution.

In an interview setting unless you are specifically asked for a recursion solution nonetheless we haven't

spoken a lot about recursion yet inside this course.

And so this is going to be our first good taste of recursion which is a topic that we'll be discussing

a pretty good amount throughout the course as well.

So let's take a quick pause and then start to tackle that second solution in the next video.
---------------------------------------------------------------------------------------------------------------

38. Step Up Your Steps Game
In the last section we looked at an iterative solution to the steps problem in this section.

We're now going to continue by looking at a recursive solution to this.

Now if you're here in this course and you're preparing for a professional javascript interview I am

going to assume that you have seen recursion before at least once.

Nonetheless we will do a very quick review just to make sure that we are on the same page.

Well then look at a couple of general tips around recursion and then we'll come back to this problem

and figure out how to tackle it.

So let's do a quick review first with recursion.

We always start off with some type of function.

So let's imagine we've got a function called about print number about that.

Let's imagine that we want to make a recursive function called Print number.

We should be able to pass this function a number and it will print from that number down to zero.

So we'll assume that we always pass the thing a positive number.

Let's write out an example of that.

So let's pass it like the number 10.

So I'll say that to succeed in this problem.

I want to see a console log from 10 all the way down to 1 or 0 1 and the other.

And the first thing that we always do with a recursive solution is to identify what is called a base

case the base case is the case in which we decide there is no more work for us to do.

And it's time to return and stop the recursion process.

And so without even thinking about the term base case or anything like that.

Think back to the description of this function I just gave you two seconds ago I said we want to print

from whatever number is passed all the way down to zero and then at zero we stop and we do no more work.

So to think of a base case in this situation I would say that if the number that is being passed to

this function right here is equal to zero.

That means there is nothing else we need to do.

We have hit the base case and we want to stop recursion.

So let's write that in here.

Let's imagine that print number gets called with some number and as an argument we will check to see

if n is equal to zero.

And if an is equal to zero then we are going to return and we're going to do no more work during the

recursion process.

Nailing your base case like this is one thing that is absolutely critical during the recursion process.

I really encourage you to spend a lot of time in general thinking about your base case.

It's way too often that people start to think about the base case only at the end.

And if you think about the base case only at the end Well usually it means that if you try running your

function before then you'll end up in a infinite recursive solution which is always nasty to try to

debug.

So we start thinking about your base case from the get go after checking to see if we've met the base

case.

We will then do some amount of work and then call our function again.

So in this case the work that we want to do is to print out the current number.

And so I'm going to print out with a log.

And then the last thing to do is to call our function again when we call the function again.

It's extremely critical to make sure that we have changed the arguments in some fashion.

If we call print number again with an We're going to immediately and are seemy we're going to enter

an infinite loop because we have not changed the arguments and the exact same code path will occur.

So I'm going to be 100 percent sure that I would to change the arguments they're going to call print

number with here.

I'm going to make sure that the change that I'm making will somehow eventually get r r and number here

down to zero.

So specifically I mean to say I want to make sure I subtract 1 or subtract some type and number.

OK.

So when we call print number again and this of course right here is the actual recursive step because

we are calling the function that defines that this function call is defined in again then we see our

numbers printed out here.

Now you will notice that you see two if you're using this tool or if you're just looking at my screen

you'll notice that we get two sets of prints from 10 down to 1.

That's just because of the way that this tool right here behaves.

The code that we have is 100 percent correct as just because the way that this tool works to make stuff

print out nicely that you see the log out here twice.

OK.

So what are some takeaways that you can immediately notice about recursion from this process right here.

Here they are.

So the first thing that we really want to do is to identify the bare minimum pieces of information that

represent what we are trying to accomplish.

So in this case the bare minimum of minimum piece of information that we want to pass from loop to loop

or from I should say call to call a recursive function is the current counter.

I did not pass along some extra piece of information like what the number was the last time it was called

or some object that we're not doing anything with.

I identified just the bare minimum information that was needed to call our function again and progressed

towards our base case.

The next thing to keep month recursion is to always give yourself some reasonable defaults to those

minimum pieces of information.

So in this particular case we had said that we were going to provide the number and then always subtract

1 to get towards our base case right here.

But let's imagine that maybe we had said well maybe an additional requirement of the print number function

was that it should be to be called with some number to decrease and by each time.

So in other words maybe we don't want to always decrease by 1.

Maybe we want to decrease by some other argument here that you know me we'll call mentor or something

like that.

So this second step right here giving reasonable defaults make sure that if there are any optional inputs

you give some reasonable default input to them.

So in this case I would want to maybe default the value of deck to be one.

And then I could very safely use it down here.

Print number and even if someone didn't pass in that debt variable or the deck value.

I've got some reasonable default to make sure they don't accidentally fall into some infinite recursion

situation right here.

For example I can very easily show you if I were to I'm not going to because my browser would lock up

but if I were to delete this declaration right here of deck or if I were to not default it to be one

then every single time we called Print number we would take an minus deck.

Deck would be undefined.

If I didn't defaulted to be one and would we would then call print number again and would probably be

like not a number or something like that.

And so we would never hit the case where an equal zero in return.

So make sure you have some reasonable default in here to safely handle your recursion.

The next thing to do during the recursion process always remember to check that base case inside the

base case you want to see is there anything left for us to do.

If there's no work that's it we're done.

OK.

Don't color function anymore and return if we do not meet the base case then we want to make sure that

we actually do some work.

We call the function again and when ever we call the function again this is a really important part

when ever we call the function again we want to make sure that we have changed our arguments in some

fashion.

The arguments have to change if they don't change.

That means that we're very likely going to end up in an infinite recursive solution which is again something

we don't want to deal with.

OK.

So with all this in mind let's take a quick pause.

We're going to come back to the next section and we're going to apply these rules right here to the

steps problem and we're going to come up with a recursive solution.

So quick break and I'll see you in just a minute.
---------------------------------------------------------------------------------------------------------------

39. More on Steps
In the last section we got a very quick review of recursion.

Let's now take some of these lessons right here and apply them to the steps problem at hand.

So I've taken one of the diagrams we were looking at previously and I pulled out some very interesting

pieces of information.

My goal here was to identify the base case and I also wanted to identify the remember bare minimum pieces

of information that represent our problem.

So let's take a look at some of these different notes that I made right here.

OK.

So the first big note right here is our base case.

So if we imagine that we still have some row counter that we're going to pass during each recursion

step then if we increment row each time we kind of progress down here when ever row is equal to N and

member and was deciding how many steps we have in total then that means that we have hit the end of

our problem.

So this was something that we noticed with our Interesse solution as well.

Remember we had the for loop where we iterated from an up to or something from 0 up to N and as soon

as we hit that we said okay that's it.

No more work for us to do.

So essentially I think that our base case here is to say if we have some row piece of information that

is being incremented from 0 to 1 to 2 and eventually to 3 as soon as we hit 3 that means nothing else

for us to do.

Now the next kind of interesting note that I made about our interim solution here was I noticed that

the stair string remember the stairs string kind of represented a row and all the elements within that

row.

If that row has a length of N So RHO means length of and or a stair string has a length of.

And it means that we are at the very end of the row and we are ready to print or do console log out

that row.

So if we have a string with one element to element 3 element inside of it three is equal to and equals

three.

That means that the stair string is ready to be printed.

Now the last very important note here is that if the length of the stair string so if the length of

the string that is being used to generate or it's that string is being used to represent the row here

has a length that is equal to or less than the current row that we are working on.

Then we want to add in a pound.

Otherwise we're going to put in the space.

We saw this exact same thing just a moment ago when we were looking at our iterative solution.

So remember back over here we had said that we had that inner for loop we had the inner for loop that

iterated through our list of columns and if the column counter that we had inside there was less than

or equal to the row counter then we would use a pound sign.

Otherwise we would use a space.

The interesting thing about this solution right here is that you can kind of very quickly tell that

this for loop right here.

It was made to iterate from 0 to an but we actually have another piece of information inside of that

interim solution that mirrors or kind of encodes that exact same counter the length of the stair string

right here the length of it was always equal to the current count column that we were iterating over.

So back here we were looking at the column counter to decide whether or not we wanted to use a pound

or a space but for our recursive solution we're going to instead look at these stair string to decide

whether or not we want a pound or a space.

OK.

So these are the three big things that are going to help us put together our recursive solution.

So we're now going to flip back over to our code editor and we're going to put this thing together.

Now as we write the code for this we're going to kind of speed through the implementation because honestly

writing out recursive stuff is challenging to explain to say the least.

So it's more important that you understand these kind of base cases right here and that you get a sense

of how to kind of discover these on your own once you can think of your base case life gets a lot easier

and you can start to put together this implementation.

So anyways let's just put this thing together and see what it looks like.

So back inside my code editor I'm going to take my whole steps function I'm going to copy it.

I'm going to put it down at the bottom the file and comment it out again just so I have a nice little

backup then scroll back up I'm going to clean out the steps function.

So it's now empty.

All right.

So the first thing we're going to do here is we're going to define our base case and we're going to

check to see if the base case is satisfied and if it is we will return.

So I'm going to check to see if n is equal to Roe and if it is I'm going to immediately return now.

Right away you'll notice that there's no variable inside of your called row.

So let's say that every single time that we call the steps function one very important piece of information

that we always want to pass along to every function call it steps is the current row that we are operating

on.

So as an argument to the steps function I'm going to add in row now the first time that steps gets called

we can assume that we called like that steps of three.

Remember that is exactly what the directions up here said it said Write a function that accepts a positive

number.

And so I'm kind of arbitrarily deciding that there is an additional argument I want to add into this

function call.

Now just like we saw a moment ago over in the code editor over here we need to make sure that if row

is for some reason not defined in our function call we need to give it some default argument.

Otherwise we might get some really unexpected behavior.

So to handle it first time that steps is called Where presumably Roe will not be passed along.

I'm going to default the value of row to zero.

So this means right here I want to start on the very first row where the top row of our problem.

OK.

The next thing that we're going to do is we're going to examine our second case.

The second important note here this one right here we're going to write in some code that checks to

see if the length of the stair string is equal to a length and be equal to the variable and if it is

then that means that we are at the end of the row and we should probably print out the stair string.

So the next thing we'll do back over here we're going to check to see if an is equal to stare length.

And if it is then we need to assume that we are at the end of this particular row.

And we should print out the stair variable.

Now again you will notice that we have not yet defined stare.

So satyr is another piece of information that I really think that we need to share in between function

calls.

So as an additional argument I will assume that we are going to call this thing with a stare argument

and I'm going to give it an initial default value of an empty string.

So by default nothing is nothing is inside of stair.

Now the only thing we have to take care of now is figuring out how exactly we are going to decide to

call steps again in the future and how we are going to make changes to stare and row.

So at some point in time we need to increment row right here.

And at some point time we need to add a character onto stair.

I can ask you a question here.

When do you think we need to increment row row needs to be incremented when we hit the end of a row

like when we have completed a stair and we just wrote an if statement for that right here.

So when ever we have hit the end of a row we're going to cancel log out stare and then we're going to

call steps again but this time around we're going to increment the value of rho.

So after we hit the end of the stair we'll console log stair and then we'll call steps still with N

but with RHO plus 1.

Now you'll notice that I'm not going to provide a third argument here because when we move on to the

next row I want to use an empty stare again and song and rely upon the fact that we are using a default

Stehr value of empty string here.

I could very much just as well do something like this.

You know I could pass an empty string manually but it's not necessarily necessary because we've already

got this default value set up here.

Now the other thing to keep in mind is that if we hit the end of the row as indicated by this if statement

and we Consolo this thing and we call steps again we don't want to do anything else inside this function.

So if we meet this case right here there's nothing else we want to do.

So when I call steps right here I'm going to make sure that I just return right away.

Now we don't necessarily have to return the value of steps that's not necessary.

You know if we wanted to we could put return down on the next statement because we are not returning

anything here per se.

I just want to point that out.

Not really important either way.

Just one thing to keep in mind.

OK so we've handled the case that we have completed all of our work.

We've handled the case where we've hit the end of a row.

The last thing we have to do is handle the case in which we are still assembling our stair string and

remember the big thing to keep in mind for that was that if the length of the stair string is less than

or equal to the row that we are currently working on we're going to add a pound.

Otherwise we're going to add the space.

So for that we can add in a little if statement will say if stair length is less than or equal to Roe

then we want to add a pound onto stair so we can say stair plus equals pound.

Otherwise we want to add a space like so now the very last thing keep in mind here the last line of

code we need to write.

Notice how the only points and right now that we do any type of recursion is if we've hit the end of

a row but we still need to make sure that we recurse through a row as well.

So after we have appended on some character to the stair string We then need to call steps again and

that's going to start the entire process over again.

So after we do that statement we will again call steps we'll pass and we'll pass and row and notice

that we are not going to change the value of Roe here because we are still working on the same row.

And the last thing we'll do is pass and stare.

Okay.

So I know this has been a little bit complicated but I think that if you really think through these

steps they make a lot of sense.

The problem with recursion is that arriving at which steps to put together is really challenging.

You know this is the kind of thing where you when you see the solution you can go like oh that makes

sense.

But before you see it it's the hardest thing in the world.

And that's why recursion is kind of the story is difficult to pick up.

All right let's do one last run through here.

So the first some we call steps and I'm going to move steps 3 up here by the way make sure you get rid

of that don't want to throw off any tests.

So make sure you dump that statement.

So the first steps we're going to have and of like 1 2 three four 5 whatever it might be will have a

roll of zero.

We'll have a stair of empty string.

So a 0 0 empty string is an equal zero.

No it's not because and is equal to 1 2 or 3 or whatever is an equal to stared at length.

No it's not because there is still an empty string.

OK.

Well don't go down here is stared at length less than RHO will start at length zero RHO is equal to

zero.

So yes it is equal to or less than.

So we're going to add a pound to stare.

We then call steps again.

So we go back up to the top again we have and of one two or three whatever it is we have a row of still

zero.

But now Stehr is a pound.

This case doesn't apply.

This case doesn't apply.

We hit here again Stehr Now now has a length of 1 1 is not less than or equal to Rho.

So we fall into this case here.

We add on a space to stare and then we call steps again.

So at this point in time Stehr is now equal to pound space RHO is still equal to zero and is still equal

to 1 2 or 3 or whatever.

So this no longer not not relevant not relevant.

We hit here again stared at length will be too.

So we fall into adding a space again we call steps again.

We now add on an additional space and this is the last step we'll go through right now.

We call steps again.

We have let's say three in this case RHO is still zero Stehr is now pounde space space.

We checked to see if and is equal to a row.

No it's not.

We checked to see if N which is three is equal to stared length which is three.

Yes it is.

OK.

So we console log out stare.

We then return from this function.

So we do no other work inside of here.

We call steps again but this time steps is now have steps of an equal to three and RHO is now moved

on to one.

The entire process repeats until we hit this case again and then eventually RHO is incremented up to

three.

We checked to see if any is equal to three.

It is.

And so we return here.

All right.

So that's a full run through.

Yeah recursion is real nasty.

Like I said earlier my big tip to you.

In an interview setting if you get asked anything about recursion try to put together the solution first

and then look to refactor it over to recursion it will make your life easier.

In fact when I put together this recursive step solution right here that's exactly what I did.

I put together this eritis solution.

I looked at which variables were changing and then I realized OK like we can probably do at x y z and

I identified that base case and it made life a lot easier.

If you asked me to put together this recursive solution from the get go yeah I would have a tough time.

Probably like most other people in the world.

So I really recommend if possible you try the solution first just to get your mind in the right place

and then go to the recursive solution.

Now lesing I want to mention here.

Completely optional.

But if you wanted to we could definitely shorten this statement down here with a little bit of a turner

expression.

So this is totally optional.

This is 100 percent equivalent syntax spital just kind of condensed down our solution.

We could say something like Konst add equals square dot length less than three goals to row.

And then if this expression right here is true we would assign a pound to add.

Otherwise we would assign an empty string to add and then when we call steps we would pass and stare

Plus at.

So in this case add a short for like character to add.

OK.

So I think that's the only factor that I kind of want to do here to shorten things up.

And of course I bet we could maybe shorten up one or two things here beyond this but I'll leave that

up to you.

OK.

So that's pretty much it.

That is our recursive solution.

We will look at recursive recursion again in this course several times.

Again I can't say enough.

It's one of those things where you just have to see it many many times before you start to get a feeling

for yourself.

Now I did forget to do one thing.

I'm going to check my tests.

Yeah they're still passing.

So we're all good there.

OK.

So I think that's enough on recursion.

Let's take a break and continue on to our next problem in the next section.
------------------------------------------------------------------------------------------------------------
============================================================================================================

Раздел 12:Two Sided Steps - Pyramids

40. Pyramids Vs Steps

The next problem that we're going to work on is going to build directly off the steps problem.

So we're going to take care of it right now while we still have the steps problem fresh in our mind

inside of my exercises directory.

I'll find the pyramid folder and then open up the index file and then of course will also start up our

tests as well.

So at the command line just a pyramid pyramid test Geass dash dash watch.

And let's see how many tests we have.

All right.

So now you got about four tests running.

All right let's take a look at this.

So we're supposed to write a function that accepts a positive number and the function should cancel

log a pyramid shape with an levels using the pound character.

Make sure the pyramid has spaces on both the left and right hand sides.

So this looks very similar to the problem we just worked on the steps one.

However now it's not only one side that we want to put these kind of spaces on both sides.

So we are now forming a pyramid shape.

So definitely you can very quickly see why this is very much so similar to the problem with it we just

worked on the steps one.

So methodology will be very similar but now it's going to be up to you to kind of figure out some very

interesting edge cases around this one.

So I'm going to give you a little bit of a head start here.

Beyond the fact you know saying obviously go back and look at the code from the steps problem we're

going to look at a diagram that's going to kind of help you focus in on a couple of different areas.

So we looked at one diagram very similar to this for the step problem.

This time around I've kind of removed some information and changed some stuff around to accommodate

the differences for pyramid.

So I think that the general algorithm that we used for the solution for steps is still going to work

here.

So I think that we should still iterate from 0 to n so and here being the total number of rows that

we have.

So we'll start off at 0 1 2.

Then for each of those rows I think we'll still create an empty string.

But now things start to get really interesting is that inner for loop.

So we're going to iterate from 0 2.

I don't know if you're going to have to figure that part out.

That's going to be one of the challenges here.

In addition once you figure out exactly what balance you want to iterate to for that inner for loop

you are also going to have to do some very interesting logic to decide whether or not the given column

should have a pound.

So remember previously it was a pretty easy determination for us before when we were doing the steps

we said if the current column is equal to or less than the current row yes we want a pound.

So this time around it's going to be a little bit more involved than that.

I'm going to leave it up to you to figure out exactly how to do it.

One tip that I will give you just so you are aware that this exists.

And I really want to just give you a quick example of it.

Remember that math floor is a function.

So if you use math floor it will take a decimal number and it will rounded down to the nearest integer.

In this case 5.

So I don't know maybe they'll be helpful for you depending on how you tackle this.

Maybe it won't.

I just want to remind you that that function exists.

So that's what you're going to have to do.

You have to do a little bit of work to decide whether or not a given column should have a pound.

Otherwise everything else is going to be pretty darn similar.

Now I do want to focus on one thing here.

Remember previously and was determining the number of rows and columns but like we just said now that

enter number or that inner for loop or the number of columns is going to be not exactly identical to

three.

So this is an accurate diagram for and 3 because we have three rows here.

But you can see that there's clearly more than three columns.

And if we start to think about the different pyramid shapes that we might have you know put some of

them together here.

Here is the pyramid shape for any equals two.

This one has three columns years and equals three.

This one has five columns and we can go to any of those four and this one has seven.

So in each case here you can see that the number is changing.

Yes it's changing by two each time.

But you know I'll leave it up to you exactly how to calculate it.

So just keep that in mind anyways.

Give this a shot.

Obviously again you draw upon your experience from the steps problem quite a bit as you're working on

this one.

I will say that we are going to go over the iterative solution first.

So I recommend you put together the iterative solution first and then we'll take a look at the recursive

solution after that.

So if you want to just do one or the other totally fine.

I leave it up to you anyways.

Quick break.

Give it a shot and we will look at a solution in the next section.
--------------------------------------------------------------------------------------------------------------------

41. Pyramid Solution #1


In this section we're going to start to look through the iterative solution to the Paramount problem.

So let's get started.

Now the first half of this solution is going to look very similar to the steps one.

So we want to make a for loop that's going to iterate over each row of our output.

So very similar to what we did before.

Well write a for loop and iterate from row equal to zero row less than an ROE plus plus.

So that will take us from row 0 all the way up to and minus one for each row that we create.

Just like before.

We'll make an empty string here.

Now previously we call this empty string something like steps or something like that.

This time around just because we're working with a pyramid I'm going to call this string level to represent

a level of the pyramid.

If you want to go with stair steps or whatever we use totally fine there is no difference.

Now inside of here is where the real magic begins.

So this is where things start to get a little bit different from our initial steps.

Solution in sight here we want to iterate over all the different columns inside of our pyramid.

And like we said at the end the last video the number of columns is not equal to N like it was before

with steps.

So this time around we have to say somehow produce four.

And he goes to we need to get three columns for any equals three we need five and so on.

Now one thing I would really caution you against really try not to look at the relation between each

of these levels here like we're not trying to really derive a pattern from three going to five because

you could very quickly be thinking OK I just need to like add to to something every time.

And that's not correct.

We don't want to think about the difference in rows.

Irks me the difference in columns each time.

We're really trying to think of is how N is related to the number of columns.

So I don't want to compare three to five and try to figure out some pattern there.

I want to look at two to three three to five and four to seven and try to figure out some combination

or some pattern between each of those pairs of numbers.

So the relation between these you know there's not a super easy way to lead into this I'm going to tell

you what it is essentially the relation is we're going to take in we're going to double it and then

subtract 1 and that will give us the total number of columns so we can test this out very quickly in

our heads.

So two times two is four minus one is three.

So that works out two times three is six minus one is five.

So that one's good.

And then two times four minus one is seven.

So that's pretty much it.

We're going to iterate from 0 2 to two times and minus 1 and that will give us the correct number of

columns.

All right.

So back over here we'll write out our inner for loop will save for left column equal to zero column.

Less than two times and minus one column plus plus.

Like so OK.

So this will take care of our correct number of columns.

Now very quickly we start to run into the next big issue.

So previously when we worked this problem when it was all about steps we had a very clear and easy comparison

to make.

We had said that if the current column is equal to or less than the current row we should add a pound.

But this time around it's way different we've got a much more complicated calculation going here.

And really I'm not sure how much we can just do a very simple comparison between the two to figure out

what to do here.

In particular in this case we have some like range in-between here that we need to somehow figure out.

So this is another location where the math starts to get a little bit hairy.

Let's do a quick code up over here and figure out exactly what we need to do.

So essentially going from 0 1 2 3 4.

So from values 0 1 2 3 4 we need to make sure that number two or kind of value.

Number two in there gets a pound.

So I'm going to kind of make do a little pretend over here.

Let's say our columns are 0 1 2 3 and 4 and then our ROE.

Let's get some identifiers here.

Our row at this point is zero.

So I need to somehow relate these two sets of numbers together to make sure that I somehow can pull

out a pound for this index right here and spaces for these other areas.

And then if RHO was one then I would want to make sure.

So just to be clear that would correspond to this second row right here if RHO is equal to 1.

So in that case I would need to make sure that I can somehow produce a pound here a pound here a pound

here.

But then space's on the ends and then of course for RHO equals two.

Everything needs to be a pound.

So we need to figure out some relation to essentially generate that kind of stuff.

So here's my thought.

I think that what we can do is calculate the midpoint of our array right here.

So we'll calculate the midpoint.

Like what is the very center index of this thing.

If we can figure out the center index then we can say that take row number of elements on either side

of that Centerpoint and make those into pounds.

So with words that's really confusing.

So let's look at what this looks like in practice.

So first I want to get the midpoint of columns right here to get the midpoint in and when I say midpoint

I'm typing it like the index.

So in this case I had one index of two.

So I need to somehow turn zero one two three four or five into two.

So essentially you know let's just get to the point here.

Essentially we can do math.

Floor two times and minus one and then divide that by two.

Where and is the number of elements Hursey the number of total rows that we're working with.

So if we wanted to only consider the actual number of rows here it would of course be we're dealing

with five elements divided by two and then we'll take math top floor of that and that will give us a

second element to Spickler that two times and minus one.

I made a mistake right there this is the final solution.

I didn't mean to go that far forward.

Let's just forget we saw that and just think about five divided by two.

So now we can think of two and zero elements on either side should also be made into a pound as well.

So only element 2 in this case should be made into a pound.

If RHO goes to 1.

Then I want to take essentially math floor and math for floor plus 1 and math out for floor minus 1.

So elements in position 1 2 and 3.

So 1 2 and 3 should be made into pounds.

So hopefully that makes a little bit of sense here.

Again this is kind of getting into you know challenging stuff as far as some of these math calculations

go.

Let's try coding this up and I think it'll will start to make a little bit more sense.

So back over here the first thing we're going to do is to calculate the midpoint of our row.

So the midpoint of our row is going to change depending on N and that's why we had that two times and

minus one calculation in there for a second.

So we're going to say the midpoint is that index math Daut floor two times and minus one divided by

two like so.

So that's the midpoint index.

Now the other thing to keep in mind here is that we are iterating through this list of columns.

So in truth you know we don't really need to be calculating midpoint every single time here.

We could actually calculate midpoint at the very top of our function because it's only ever going to

be reliant upon and is never going to change.

So let's pull midpoint out to the very top up here.

And then inside of our loop all we really have to worry about is watching for row number of elements

to the left of midpoint and row number of elements to the right of midpoint as well.

So in code that would look a little something like this will say if midpoint less minus II is less than

or equal to you know not.

My mistake Roe if midpoint minus Roe is less than or equal to Culham.

And if midpoint plus Roe is greater than or equal to column then we want to add a pound.

So this if statement right here is going to make sure that the current column that we are looking at

is within the bounds of midpoint minus Roe and midpoint plus Roe.

So this is a check right here to make sure that we are inside of some bracket of numbers.

So if we meet that condition we'll add in a pound.

Otherwise we'll add in a space like so.

All right.

I know that was nasty but we did get through it.

I am pretty confident that if you look at these numbers a little bit they will make sense.

So do you know if it still seems a bit confusing do you try writing it out on paper.

You know for all the matters and I think that you're going to get a hang of it pretty quickly.

So here's our for loop inside of there we assemble one rows worth of numbers or one levels worth of

numbers.

So after that for loop just like before we will cancel log out level.

So let's see how we're doing with our tests back over here.

Looks like we've got 4 tests passing.

All right.

That was a challenging one but I think that steps gave us some pretty good preparation at least to pull

it into kind of two separate problems that we had to worry about.

So this looks good.

Let's now continue in the next section.
--------------------------------------------------------------------------------------------------------------------------

42. Pyramid Solution #2

In this section we're going to look at the solution to that pyramid problem by using recursion.

Before we get started.

Quick pause I wanted to tell you if you had any difficulty with the recursive solution to the steps

problem that we worked on just a little bit ago I really encourage you to give a shot at doing pyramid

on your own with the recursion solution because you essentially already know how the recursion solution

is put together.

All you really have to change is some of the bounds or some of the like you know essentially the range

of numbers that we're considering with this new solution for Paramount.

So this would be a great opportunity to practice some recurrent related stuff on a problem that you're

already kind of familiar with.

Now if you're to give it a shot or if you don't want to you know whatever it is no problem we're going

to go through the recursive solution right now.

So as usual we're going to make a backup of our pyramide function.

So I will copy the whole thing go down the bottom.

I'll paste it here it is right here and commented out.

I'll then go back up and I will clean out the pyramid function.

So now we've got only pyramid and the export statement right here.

All right.

So in general the recursive solution is going to look very similar to the recursive solution for the

stairs problem.

So the first half of this we're going to speed through pretty quickly.

And then as soon as we start getting into some pyramid related stuff will slow down just a little bit.

So just like before we're going to take special note of our argument list up here.

We're still going to hold onto the value N we're still going to worry about which road we're currently

looking at and we're still going to want to consider some given level here as an empty string.

Now the most important thing as usual and we want to make sure we spend careful thought on this even

if we are speeding through a recursions solution we always want to make sure that we set up our base

case correctly.

So just like before.

We're still going to watch for when Roe is equal to and if Rose equal to N..

That means we're all done with recursion.

We need to return and stop calling pyramid anymore.

Now note that Roe is still equal to and here because and ultimately was really describing the number

of rows we want in the last video when we spent some amount of time figuring out how to calculate the

number of squares going this way right here.

That was all about calculation calculating the column direction.

So Roe is still always going to be at a maximum of three.

It's the width of this thing that's going to start to change in nature.

Speaking of which that's going to be relevant right now because the next statement that we're going

to put together is going to detect when we are at the end of a level.

So at the very right hand side over here remember the maximum column length are the maximum number of

columns that we can have in a row is determined by the calculation two times n minus 1.

So essentially we want to check to see when our string the level string has a length of two times and

minus one.

If we are at that length then it's time for us to cancel the level and move on to the next row.

So we'll say if level length is equal to two times and minus one then we need to console log the current

level and move on to the next row.

So we'll call it pyramid with an will increment row by 1 and note that we are definitely in a place

the return statement here to make sure that we don't do any other work inside this function.

OK.

So that's looking good.

Now the last third to this thing is where things start to get a little bit more hairy.

Remember that the last third here is really intended to to decide whether or not we need to add a space

or a pound to the level string.

Now previously we had that very simple calculation to worry about how we had to worry about was if the

length of our string was less than or equal to Rho.

But this time around just like we had to kind of struggle a little bit with the solution this time around

we have to again calculate that midpoint and then decide if the current element that we were considering

is within that range of the midpoint.

So just like before I know the description on this was a little bit challenging but we still want to

do this kind of midpoint calculation.

We want to consider the row that we're on and then mark every element that's within some range of that

like plus or minus some amount to be a pound.

Otherwise it should be a space.

So let's look at the math for this first.

We'll calculate the midpoint which will be math floor two times and minus one and then another.

Outside of this first set of parentheses right here.

Remember order of operations will divide by two.

So that will give us our midpoint index.

Next we're going to put together an if statement to decide whether or not we're going to add on a pound

or a space.

Now rather than do our actual function call to the next pyramid call inside the if statement I'm going

to make a temporary variable called add at is going to contain the character that we're supposed to

add to our level string.

It'll make sense in just a second when we put down this if statement.

So we'll say if this is the nasty part.

So pretty big comparison we've got here.

If midpoints minus Roe is less than or equal to level dot length.

So remember in the recursive solution we determine which column we are currently operating on by looking

at the length of our level string.

So if the length the level string is less than or equal to or greater than or equal to the difference

between midpoint a row.

So it would essentially take care of making sure that we are you know on the right hand side of this

barrier right here.

And then we'll do the opposite side as well.

So Iand if midpoints plus RHO is greater than or equal to level length

then we will add in a pound.

So the second portion of the statement over here.

So this portion right here is making sure that we're still to the left of this found right here OK.

So now we're going to decide which character to add or I should say we just did.

We're going to sign the character that we should add to the variable add.

So in that case it's going be pounde.

Otherwise you want to get a space in there and of course to make sure that this is a space character

not an empty string.

So that's by the way why we use this temporary variable add right here.

It's just to assign the character.

We should add in and then down underneath all this stuff that's going on right here.

We will then start off our next call to pyramid.

So pyramid and is always going to be unchanged.

We are not going to change Roe because we are still in the middle of a road here on this bottom third

and then the last part we're going to make sure that we take this new character that we just generated

and added on to our level strength.

So we'll say level plus add like so

just one.

Let's see this.

Check our terminal.

Looks like I completely forgot to start my tests.

Mr. Arty's back up we'll see how we're doing.

All right.

Four test passing out of four.

Not bad.

OK.

So this has been our recursive solution.

Again this was pretty good practice because we got to see kind of more straightforward application of

it with the steps problem.

And then we got to redo it over here with pyramid but with some added complexity on top.

Both these problems.

I know I say this all the time throughout this course.

I know I said oh yeah this is a real common problem.

But again all the problems I picked for the course are of course common problems.

I really do expect you to see an interview.

And so proms like this one right here that are kind of concerned with spatial things and you know laying

out objects and spaces or whatever it is.

Common interview questions you'll see even though yeah of course you know no one ever had no one in

front end engineering ever is going to do some stuff like this.

I know.

You know that's a totally separate discussion that we haven't really touched on in this course.

I know that most These questions are totally bogus and not relevant to relate to a real job at all.

But you know that's just life.

I could we could talk for hours about that.

Anyways this has been a recursive solution.

Let's move on to our next problem in the next section.

So see you there.
-------------------------------------------------------------------------------------------------------------------
===================================================================================================================

Раздел 13:Find The Vowels

43. Get Your Vowels

Let's move on to our next question.

This next one is going to be rather easy.

Really very very easy.

But it's one that I've seen asked in preliminary interviews more than one time.

So what the heck let's just get through it.

Inside my vals directory I'll open up the index file and then of course we'll flip on over to our terminal

and start up our tests with just vowels test dot J us lunch like so and we should see four Tests.

Very good.

OK.

So we'll flip back over to the index dot just file.

Let's look at the description for this problem.

So we're going to write a function that's going to take a string and scan return the number of vowels

that are used in that string.

And if you are a foreign English language speaker of English is not your primary language of vowel is

any character a e i o n u.

So essentially we pass a string like Hi there.

Lis has one vowel two and three.

So we would return three for the next one.

Why'd you ask.

We have one two three and four.

So we were turned 4 and then the last one down here.

No vowels so we turn return y.

When I was back in elementary school we were always told like why is a half vowel.

I guess that's not really a thing anymore so you know we're not going to count y.

Who knows.

Anyways as you might guess this is not the hardest problem in the world.

So I encourage you to give it a shot.

We will look at two different solutions.

One is going to be an iterative solution and the other one is going to use a regular expression.

So if you are not up to speed with regular expressions this would be a great time to get a little bit

of practice in.

So give it a shot and I'll catch you in the next section and we'll go through the iterative solution

first.
---------------------------------------------------------------------------------------------------------------------------

44. Finding Vowels

In this section we are going to look at an iterative solution to the vowels problem.

Now this interim solution will be pretty darn straightforward.

So we're going to create a counter variable at the top will initialize it with a default value of zero.

We will then iterate through all the characters inside of our string.

If a given character is a vowel we will then increment the counter and at the very end of the function

will return that counter.

So not that bad.

Let's first start off by creating the counter variable.

So I'll say let count starts off a 0 and then we will iterate through our string.

So say for let char of and one thing that I want to point out here the directions didn't really indicate

if we wanted to consider capital avowals or not.

I think that it's entirely safe to assume that you want to include capital avowals and our fellow counting

here.

So we'll make sure that we lower case the string right before we iterate through it.

So say string to lower case and then we'll put some logic inside of here to decide if we're working

with a vowel.

And then afterwards we will return count.

OK.

So now the real thing that we want to care about here.

You know the real question is how are we going to check to see if we are working with a vowel.

Well you might be thinking hey let's put down a bunch of if statements.

If char is equal to A or if Char is equal to eat and so on.

Well we can definitely do that.

But that leads to some pretty nasty looking code with all these statements put together.

So I want to show you a little helper method that is included with all strings and all arrays as well.

That's going to dramatically simplify this.

So we'll look at a very quick example of it over here at my code editor.

I'm going to create a string.

Let's call it simply word and I'll give it the content.

Hello there.

Now a method that this string has is called include.

So I can Coale word dot include and then I'll pass in some substring that I want to see if it is included

in this string right here.

So maybe 0.

What do we get from that scares me.

Includes not include includes There we go.

So we're done includes We pass an O and yep there's Owen there so we get back.

True.

And then we can do something like capital F that's not in there.

We can do a substring like so.

So EHLO Yep that's unhealth right there.

So essentially using this includes method right here we'll go a long way towards helping us very elegantly

figure out whether or not a given char right here is a vowel or not.

So right above our for loop we will make a string that is going to contain all the different vowels

that we want to consider.

So I can say Konst.

Ideally I would really want to call this thing vowels.

But the function is already called vowels so we'll call this slight you know checker I don't know I'm

making it up and I'll make this a string.

So h e i o u like so now inside the for loop we can say if Sheckler

dot includes char then counter plus plus like so.

So if the character that we're looking at is included in this string right here then we're going to

increment the counter.

We'll iterate through all of our different characters and then eventually return it.

Now one thing I want to point out here is that using a string in this fashion right here is kind of

misleading.

You know it's not really the most clear thing in the world to any future developer who looks at this.

They might look at this and say oh is the order of characters here really important.

So even though we can use a string of characters to use this includes method I would probably recommend

that instead we should use an array as the kind of root comparison thing.

So arrays also have this includes helper method on it as well.

Let's see an example of what that would look like would be something like a b c c.

There we go.

And then we would want to see if C is included in the word array and Yezidis.

So if we use an array like this I think that life just becomes a little bit more clear for future engineers

who are working on this problem right here.

So maybe a e i o and you like so in addition this would also allow us to put in like discrete substrings

if we ever wanted to were kind of multi-character strings like if I ever wanted to.

For some crazy reason look for ABC is like.

Put that into this array.

I could not very easily do this same thing with only a single big book string.

So just one thing to keep in mind as well you know that's the kind of thing that interviewers want to

see you having consideration of.

To be honest.

So even though it might seem like this is overkill discussion for a function check and see if we avowals.

Honestly it's kind of a good discussion point to have during an interview.

All right.

Lesson do is make sure we're passing our test here.

Let's check the terminal and it looks like we are failing here.

Counter is not defined.

My mistake I'm incrementing counter right here is should be simply count and back over here.

We're now passing our tests.

Very good.

OK.

So that's one possible solution.

Now there is another solution that is much more condensed than this right here.

So let's take a break and we'll check out that alternate solution in the next section.
--------------------------------------------------------------------------------------------------------------

45. Another Way to Find Vowels

In the last section we went through an iterative solution for the vals function.

We're now going to replace this with a slightly more condensed version so I'm going to copy this thing

down to the bottom the file as usual.

Commented out just to leave a backup here and then I'm going to clean out the contents of the vals function.

Now this alternative solution is going to make use of a reg X expression or a regular expression.

So using a regular expression here in my opinion is so easy it's almost like cheating.

So what we're going to do is to look at the string we're going to call the match method on the string

matches used to see if some possible thing right here is included inside of this string.

So we can pass in a regular expression and this regular expression is going to check to see if we have

any values inside of here.

So our regular expression is going to have a pair of square braces when put in square pair of square

braces like this where essentially saying hey if this string contains any character that is inside of

the square brackets right here then let us know.

So we're going to put in all the characters that we care about a B.

I knew you'd think that we're going to do is to add on two options to the X itself.

Both G and III the G.

Regular Expression right here make sure that we don't stop at the first match that we find inside of

our string.

So if there are multiple vowels of some type in there we're going to attempt to find them all.

And then the right here stands for insensitive or case insensitive.

So remember before we had to manually turn our string into a lowercase version of itself the right here

will automatically take care of cases for us.

Now just one little odd thing about this match function right here.

If it finds any matches it will return an array of all the matches that were found.

So we will return that and assign it to a variable called matches.

But the part that's kind of awkward is that if no matches are found then match will return.

No instead.

So in other words matches right here will be either an array or no.

So we need to handle both cases appropriately.

We're going to use a turner expression for this.

So we're going to look at the matches variable if matches is no no considered to be a falsie value if

it is an array then that is considered to be a truthy value.

So for the first part of our turn an expression will say if this thing is a truthy value.

So if it is in an array then I want to return matches length otherwise it matches is null or if it is

a falsie value then I want to produce 0 and then ultimately we really want to just return the results

of the Turner expression.

So make sure we put the return keyword in there as well.

All right so we'll save this and let's see how we're doing now.

So still for passing.

Fantastic.

Again this is definitely more concise but it really is kind of predicated on you really closely understanding

exactly how a match works especially the fact that it returns no if no matches are found.

Personally if I were you I would probably stray towards this interim solution.

It's very clear and you can have some side discussions with your interviewer like the one that I just

mentioned at the end of the last video where using an array here is kind of the checker thing rather

than a string is beneficial.

So really up to you.

But honestly I think that the kind of value or the solution down here is probably the safer bet.

OK.

This has been a nice little breather Meisl easy one.

Let's now continue with our next exercise in the next section.
------------------------------------------------------------------------------------------------------------------
==================================================================================================================


Раздел 14:Enter the Matrix Spiral

46. General Matrix Spirals

Let's move on to our next problem inside my code editor I'll find the matrix directory and then open

up the index geas file inside there and then of course we'll also very quickly start up our tests with

just matrix test stuff.

J.S. dash dash watch like so and we should see about four Tests pop up.

Yeah here we go.

So four tests running.

Very good.

All right.

Let's look at these directions.

The directions say write a function that accepts an integer n and returns and end by and spiral Matrix.

Well those directions are not very helpful.

So let's look at the examples right here instead.

So the idea is that we're going to call the function and then we're going to return a two dimensional

array or an array of arrays.

So notice how there are two arrays inside of one larger array.

Here's the outer array right here.

And then we've got two arrays inside of it.

The reason that we call this thing a spiral matrix is that we're going to start off from the number

one and then going around clockwise in a spiral fashion.

We're going to count up from 1.

So we start off at 1.

We go over to two down to three over to four with Matrix 2 right here it's a little bit hard to see

the pattern.

It's a little bit easier to see the pattern with Matrix 3 and Matrix 4.

So let's look at this over here we start off at 1.

We go over to two three down to four five over to six seven eight nine.

And so you can kind of see the incrementing values here.

They form a spiral of sorts.

That kind of spiral from the outside into the center of the matrix and it's a little bit easier even

with Matrix 4 down here to see that pattern.

So we go one two three four five six seven eight nine 10 11 12 and then we spiral in to 13 14 15 16.

So we go in this clockwise spiraling in fashion the last number that we're ever going to print out inside

of here will be.

And squared.

So for example we have four here.

So the last number that we will print out inside if you will be 16.

Three times three is nine.

So that's going to be the last number.

And then two times two is four.

So that would be the last number.

Now let me tell you right now this is a very challenging problem.

This is tough because there are a lot of different variables that are going to be flying around inside

our solution.

Nonetheless this is a problem that you can be expected to be asked inside of an interview setting.

And I can tell you that from experience unfortunately because I have been asked this question right

here and it's really tough to do on a white board.

I got to tell you.

So this is a great example where it's extremely important.

Before you attempt to attempt to solution to get to to get out a sheet of paper or to you know draw

a diagram on the white board or whatever it is and try to draw out exactly how you're going to try to

tackle this.

This is a problem where if you just start writing code you're going to have a very tough time and I'm

pretty convinced that this is a nearly impossible problem to solve.

If you just immediately start writing code without putting some thought ahead of time into how you're

going to solve it.

So let's take a quick break.

We're going to come back in the next section and I'm going to give you a couple of notes on exactly

how to solve this.

So come back to the next section.

Don't attempt a solution just yet.

We'll look at a couple of different aspects of this problem and I'll give you some tips on exactly how

to approach it.

See you in just a minute.
--------------------------------------------------------------------------------------------------------------------

47. Spiral Solution

In the last section we started looking at the spiral matrix problem.

We're now going to continue by looking at some notes on a possible way to solve this.

So let's take a look.

So this is the general notation that we're going to use as we look at our solution.

So the outer box here is meant to indicate the outer array and then each of these inner boxes indicate

the sub array that are inside of it.

So this would be one subarray right here with the values 1 2 3.

Then the next subarray is right here.

And the final one right here and then all three Subah rays are contained within this outer array.

So then mind let's take a look at our diagram.

All right.

So this is a nasty thing right here but it is a nasty problem.

So I'm going to give you a kind of cursory description on the algorithm here.

I'm not going to try to walk in great detail through every step right here.

But if you want to look at these notes right here remember you can always pause the video and take a

glance at the diagram or all the Corson's diagrams or inside of the accompanying get repository which

was linked at the start of this course.

And so you can always go back there and take a look at these steps right here.

I would love to walk through all these steps verbally with you.

However if I start essentially reading these off it gets really confusing very quickly.

So you know honestly it's probably best that you might sit down and take a look at the steps here on

how we might solve this.

This solution is 100 percent predicated on this idea of maintaining some counter variables that reflect

what starting column we are working on and what end column we are working on along with the starting

row and ending row.

So the idea here is that we are going to have some integer values that keep track of the current index

that we are trying to fill inside of our matrix.

So we might start off with a start row equal to zero.

And that means that when our algorithm first starts off we want to look at row 0 and start attempting

to fill values inside of that row.

Then the last row that we want to be concerned with would be wrote two down here.

Notice that these are not necessarily hardcoded values.

I'm assuming that we have an an equal to 3 right here.

So if we had an equal to 2 or equals 4 or 5 6 whatever this and Roe value right here might change.

And so you're probably going to have to do a little bit of math to calculate exactly what the end Roe

should be depending on the value.

And that is passed into the function the start column is going to be some counter of sorts that decides

what value or what index we're currently trying to fill out for.

On the left hand side that will start off as zero.

And in the end column will start off as 2 as well.

So the general idea here is that we're going to make a series of four loops.

So here's one for loop right here.

Here's one for loop right here.

And then I did not show the other 2 for loops that you'll have to make on here inside of each of these

four loops.

You are going to iterate from some start column up to some end column and for every value or every index

between Start column and column you will insert some value into the matrix So for example the very first

lubra here will iterate from start column to and column.

So from zero to two and then at every step throughout that loop you will attempt to insert some value

on this first starting row right here after you have filled out these first row right here.

Or in other words after this first loop has completed running you can then increment the start row value.

So we could increment start row by 1 and it would say all right this is now the first row that we want

to be concerned with.

So essentially after you fill out the first row with one two three you don't worry about the first row

anymore.

You are now only concerned about this remaining part of the matrix.

So now the start row right here would be equal to 1.

You would be looking at this element right here.

Then fill this one out fill this one out and then you would decrement the end row to over here.

And so essentially these starting and ending counters that we're looking at right here are going to

be changing over time to essentially set the bounds of what portion of the matrix you are trying to

look at at any given time.

These directions right here probably give a very good direction or a good idea to you of exactly how

those bounds are going to work.

So again do look at the steps right here.

Now the last thing I want to mention to you is that I highly highly recommend that you create the results

set from the very beginning.

And when I say resultset I mean the empty array of arrays.

So build that at the very start of the problem and do not attempt to start to insert arrays as you are

iterating through this thing much easier to build out the empty arrays at the very start and then insert

numbers into that.

Okay.

So I know that this is a very tough problem.

It really really is very tough.

But as soon as you see the solution I know it's going to make a lot of sense.

So I encourage you to give this a shot.

Do the best you can.

All right.

Do the best you can come back in the next section and we'll walk through the solution.

So quick break and we'll take a look at this thing again in the next video.
--------------------------------------------------------------------------------------------------------------------

48. More on Spiral

Hopefully you had some success with a solution if you didn't.

If you struggle with the problem that's totally fine.

It's really what I would expect to be honest.

I'd be really surprised if many people got this problem correct on the first time through.

This is one of the classic problems where the first time you do it it's really hard.

But then we attempt the solution a second time.

Life gets a lot easier just like every other interview problem there is.

And that's why you're here you're here to practice the problem one time so that when you go and do it

in an interview setting it's much easier.

OK.

So let's start going through our solution as we go through the solution.

I'm going to be tabbing back and forth over this diagram quite a bit.

I know that's really distracting in a video.

I apologize for that but I want to use this diagram a lot to really show you exactly why we are writing

the code that we are.

So let's get started by doing Step one right here which is to create an empty array of arrays called

results.

That's step 1.

So inside my function it creates an empty array.

And then the number of sub arrays that are going to be pushed into this thing is dependent on the value.

And so I want to have an number of Subway's inside of results.

So we're going to have to iterate with the for loop from 0 up to N and for each step we're going to

push in an empty substrate into results.

It's all save for LeT I equal 0.

I less than an A-plus plus plus.

And then for each step we'll take the results array and we will push in an empty array.

If we we're now to con. log out results we would see something like four.

Let's assume that we have an end of two right here.

We would see something like this.

So for an end of two we would have two empty Subway's inside of one larger one.

Now a key behavior or a key feature of arrays that is really important for our solution here is the

fact that we can't assign values to indices inside of an array that have not been initialized.

In other words you know let's look at a quick example of this.

In other words if I declare an empty array right here so has no spaces inside of it no values nothing.

I can freely assign some value to say Index 3 and if I now print out a.

Notice how that value was assigned to index 3 right here.

I did not have to push this value in or I did not have to in it and shift the value into the array.

I can just freely assign any value to any index inside an array that I want and it's a very important

thing to keep in mind.

The solution here.

OK so back over here.

So our next step is going to be to create a counter variable.

Starting at 1.

So I will say let.

Counter equals 1.

So that's going to be the thing that actually keeps track of what number we are attempting to push into

our results array right here.

The next thing we're going to do and I did not specifically put this on the diagram right here.

We are going to create a number of variables that keep track of the current column.

The start column.

The end column the start row in the end row that we are trying to consider at any given time.

The start column and the start row will always be initialized to zero but the end column and the end

row their values will depend on the value of and that is passed into our function.

So to calculate the end column in the end row will take N and subtract 1 from it.

So to calculate this matrix right here or to produce this one we would have been given an end of three.

And so the last index that I want to say give me the last.

Next I want to consider would be and minus one.

So three minus one would be two.

So with that in mind let's declare those 4 variables we'll say start to call them is going to start

off at 0 the end column that we want to consider.

During this first run through will be and minus one the start row will be zero.

And the end row will be and minus one.

It's now going to move on to the next step here which is to somehow make sure that we are going to execute

all of this code right here.

As long as this statement is true.

So that's a classic case for a while loop.

We're gonna use a while loop here.

We're going to say while start column is less than or equal to column and blah blah blah we want to

execute these code blocks right here.

So let's write out that while loop will say while.

Start column is less than or equal to and column and start row is less than or equal to and row execute

some code inside of here.

So just to make sure it's really clear at this point start column and column start row and row all these

little counters things right here.

They're going to change over time so these are not fixed values that we just assigned right here.

We are going to change the value of start column start row and so on to indicate which row which column

and so on.

We are currently working on it.

Any given time.

Now that we've got our while loop put together we're going to start on our first for loop.

The first for loop right here is always going to be responsible for assembling the top row of our solution.

So this first row right here.

After that we will define the next for loop the next for loop will always be responsible for defining

this row on the right hand side.

And then there's the two other four loops.

I did not indicate on the diagram right here.

One of them is going to be always responsible for assembling the values here on the bottom and then

the last one we always responsible for assembling the left hand side of our solution and then we'll

enter the for the while loop again at the very top and this first for loop will then be responsible

for assembling the top block here.

So essentially we've got these for four loops in each of them is responsible for assembling a different

side and then each time we progressed through the while loop we're going to be constraining these start

row and row start column and column to control what section of The Matrix.

Each loop is attempting to create art.

So let's get started with this first for loop right here.

So for the first for loop I'm going to get my self comment here.

I get to say this thing is responsible for the top row we are going to iterate from I equal to not zero

but our start column.

So we're going to iterate from our start column which is going to start off at zero right here.

We are going to progress through this for loop as long as I is less than or equal to end column and

for every step through we will increment by 1.

Now inside of that for loop at every step along the way we are going to assign some value to the results

section or the results array excuse me.

So at our results start Roe at I we will assign the counter variable.

So inside of your results at start Roe at II we will sign the counter and then immediately afterwards

we will increment the counter and then after the for loop.

And this is the really critical part right here.

After we put the last line of code or this next line of code will take a second to kind of iterate or

to kind of imagine this first for loop and what it's really doing for us.

So after the first loop we will then increment the start row.

So merely after the for loop we will increment start row start row plus plus like so OK so we've got

one for loop put put together here.

Let's look at this on the diagram and really picture what this thing's purpose is.

So we are iterating from start column to end column.

We then put something into our set and then we increment start row.

So let's see what the result to that is.

So we are going to increment from zero up to 2 at every step along the way.

So from 0 1 to 2 we are going to look at our results set at the results set at the index 0 or essentially

start row and at the particular step through the four that that we are at we will assign the counter

variable.

So we start off at index 0 for start row 0 for II which is right here.

We assign the counter variable within increment by one which moves us over here.

We assign the counter variable we increment by 1 which moves us over here and we assign 3 at that point.

We have now iterated all the way from the start column to the end column.

So we're all done with this first for loop right here.

We have assembled the top row so we exit this first for a loop and then we execute this next line of

code which is to increment the start row.

So start row has served its purpose.

We have assigned everything in this first row right here.

So we are now going to increment start row by 1 which means this is now the first row that we are going

to be concerned with inside of our solution.

So now start row is going to be one.

So now let's consider the next for loop that we are about to put together.

We are now going to iterate over from start row to end row.

So from 1 to 2 inside of there we're going to look at results I at and column.

So now we have flipped our indices here and column.

At this point inside this for loop and column is always going to be equal to 2.

And we're going to have values of i ranging from 1 to 2.

So essentially this for loop right here the next one we're going to write we are going to iterate from

results at one at two.

So results 1 2 and that would be this index right here.

We will then increment I buy one and that will then move us on to results at two at two and for both

those steps we will assign our counter variable.

So let's go through that process right now.

I know this is some pretty crazy stuff but you know this is the kind of thing that you've got to answer

in the interview to get those very high paying jobs.

All right.

So this is going to be our right column.

We're going to iterate from i equal to our start to Roe.

So remember we are iterating from 1 to 2 now because we want to go from this spot to this spot.

So we're going to start at our start Roe we're going to iterate as long as I'm less than or equal to

end Roe and will increment by one each time.

And then for every step along the way we will sign results at I at the end column equal to our counter

variable and then we will increment our counter variable by one.

All right.

So again this is taking us from this spot right here to this spot right here.

Now immediately after we achieve that after we get through that for loop we have now taken care of this

entire column right here.

So we no longer need to consider this column.

So we're now going to detriment and Roe.

So we're going to take and Roe we're going to shift it over one to right here.

So now and column is going to be equal to 1.

So now we need to repeat these 2 for loops right here for the other two sides specifically this bottom

row and then the left column over here.

Now again I did not put the for loop on here but I think you get the idea of what's going on.

So for the end Roe we are going to want to iterate from the end column.

So we're going from right to left.

Now we're going from the end column down.

So we are now decrementing we are decreasing here we are iterating from the end column down to the start

column for every step along the way we are going to assign some results and then results right here.

And then we will detriment our and Dreux.

So Andrew will be subtracted by 1 and we would now be considering just this row right here.

So let's give that a shot.

All right.

So this is now going to be our bottom row.

And for this thing we're going to say from left I equal to and column.

So we're starting off right here at our end column as long as I in this case.

We are decrementing this case so we're going to flip a lot of these conditions we are recommending from

I down to zero.

So as long as I is greater than or equal to our start Roe are just not our start our start column.

Typo.

So from I.

As long as it is greater than or equal to our start column of zero right here.

So from this guy over to this guy and then every step along the way we are going to subtract 1 from

my then inside of here we'll say results at and Roe.

So that's where you're looking at this suburb right here sort and Roe at I are going to assign counter.

And then we will counter plus plus.

And then the really critical part right after the for loop right here and I just realized we made a

mistake on the for loop right above.

We'll fix that in just one second.

So Meely after our for loop right here we need to make sure that we move our end Roe up.

We have now taken care of everything inside this and Roe.

So we're going to shift it up by one which means we are going to subtract 1 from and Roe.

So I will say and Roe minus minus like so okay.

Really important really important to be back in here for a second.

I completely neglected to update our our coal encounter right here.

So for that second loop for the second loop right here that we just put together we needed to detriment

the and row really after it was at.

Now we need to decorate the column that should be document and column.

So the end column was over here.

We need subtract one to get it to this column right here.

So we are going to add column minus minus like so.

All right.

Last step here I promise I know this is brutal but very last step.

So this is going to be our For loop for the start column.

So this is going to be it's kind of boring on this three by three 1.

It would have been a little more interesting if we had a four by four matrix to look at but we are now

going to iterate from essentially right here up to here.

So we're going to go from our end Roe down to our start Roe.

So we will iterate from let by equal to you and Roe I greater than or equal to start Roe minus minus.

And then for every step along the way we're going to do is to assign results.

I would start calling because remember we want to assign at column zero right now.

And we're going to sign the counter here and then increment the counter and then Amilly afterwards.

We have now taking care of our start column right here.

So we now need to move it in words over here.

So I'm going to increment start column by 1 so start column.

Plus plus like so OK who.

That's nasty.

But that is all.

That's it.

That's it right there.

So after we finish that start column we will then go back up to the top so we will execute the while

loop again.

We will check to see.

Let's check all of our bounds here.

So we now have a start column of one and column of one.

This should be and column one right here in the Start column one.

So all of our columns are now one.

So we're only looking at this right here.

So we'll now check the while loop will say is Surt column less than or equal to and column.

And yes it is they're both one and start row less than or equal to and Roe.

And yes they are because they're both equal to one.

So we're going to execute all of our four loops one more time and it's probably going to be this for

loop right here that captures that very last placement of the number.

So we'll start off with one here.

One less than or equal to and column Yes it'll be this one right here will assign that very last number

will not satisfy any of our other loops inside of here.

And so will you will then exit our for loop or see me exit the while loop and then the very last thing

we have to do is return our resultset.

All right let's our test see how we're doing.

So over here it looks like my tests are running which means I probably have a typo somewhere due to

an infinite loop.

So let's check our solution here really quickly I'm going to check against my notes just to make sure

we've got the right thing.

I start Ro and column and row and then start column plus plus.

All right so we definitely have a typo somewhere here.

What we need to restart the test that's what it is.

So if your test stopped running is probably because they entered into an infinite loop.

I mean a restart my tests by running just matrix tests J us dash dash watch.

There we go.

All right so that's the problem we've got an unexpected token here somewhere with the counter.

Here it is right here.

Fix that.

And now the tests are passing.

OK I know this has been a brutal section.

I know this has been very brutal.

If you are not able to follow through all the way.

I really recommend you go and check out the get hub repository for this code and walk through the code

and take a look at all the balance on these four loops.

Honestly this problem it does make a lot of sense.

As soon as you understand how we are defining the start column and column start row and row variables

and then kind of constrain their solution window over time to spiral inwards.

That's what this problem is all about.

It's all about recognizing that you want to have some variables to keep track of the current range that

you're trying to fill in on the matrix at any given time.

Again I know the solution has been kind of brutal to be honest with you.

I have recorded this solution four times now and I think that this one has been the first sign that

actually came across at least somewhat clearly.

So I think this is going to be it.

This is the video you're probably going to be watching.

I tried recording this three other times and it really just didn't quite work out.

So hopefully this has made some sense.

So at this point hopefully you've got some idea of how this solution is put together.

I would really encourage you to maybe delete the solution entirely and try it again you know put the

solution together on your own at least one time so you can feel at least somewhat confident.

In an interview setting of communicating to an interviewer about what's going on here I'll get so a

very tough problem.

But we have seen it one time so you've got at least some idea of how to approach it.

Let's now take a break.

We're going to continue the next section and start working on our next problem.

So see you in just a minute.
--------------------------------------------------------------------------------------------------------------------
====================================================================================================================

Раздел 15:Runtime Complexity

49. What is Runtime Complexity?


We've now gone through a number of different problems in this course and along the way we have seen

many problems where we put together many different solutions.

So in some cases we did two solutions or even three solutions in some cases as we compare those different

solutions.

I need a very personal claim.

And I said oh yeah I think this solution is better than this one because it is easier to code or it's

easier to come up with or it just looks better.

However there is another way of comparing all these different solutions or algorithms that we are writing

that is much more concrete than what I was telling you.

So in this section we're going to start to investigate this much more concrete way of deciding what

given solution is better than another.

So this is where we are going to start to talk about something called runtime complexity runtime complexity

is a term that we use to describe how performant an algorithm is.

We use runtime complexity to compare different solutions to a given problem or different algorithms

for solving a given problem in the context of an interview.

So in the context of like you going and interviewing with someone you are going to be asked very frequently

in many different interviews many times you're going to be asked what the runtime complexity of a given

solution is.

So usually I interviewer will ask you a question you will solve it on a computer or on a whiteboard

and then they will turn to you and say OK what is the runtime complexity of the solution.

You just did.

So the real goal with runtime complexity for you and me like in this course right now our goal is to

make sure that you have the ability to identify a given runtime complexity.

That's our goal.

That's what we're trying to learn here in this video.

In the next few.

So just keep that in mind.

Now when we talk about runtime complexity we're really asking a very discrete question here we are saying

how much more processing power do we need to run a given algorithm or a given solution.

If we increase the number of inputs into our algorithm.

So let's look at some examples of this right here and try to answer this question let's look at some

examples of some problems that we have worked on and try to figure out what their runtime complexity

might be.

So the first problem we are going to look at is the string reverse problem we worked on.

And let's pull up the code from that very quickly.

So back in my code editor I'll pull up reverse string.

Here it is right here.

And I want specifically to look at the iterative solution that we put together that used a for loop.

So for this problem right here we said that we would have some input string and then to execute our

algorithm or our solution here.

We iterated through each character of that string exactly one time.

So it would be fair to say that as we started to add one additional character to the input to our algorithm

or like the actual input string that we threw in there we had to do one additional step of work.

So for each one character one additional step.

So that meant that we had a very linear runtime we would refer to that as a linear runtime because there

is a direct one to one relationship between the number of input elements that we got into our algorithm

and the amount of work that we had to use to process it.

Many of the problems that we've been working on so far have been linear runtime but we've also had a

good example of another problem.

Actually several of the problems we've worked on that had a slightly different runtime one that was

not linear.

So let's look at an example of one of those.

So here is the steps algorithm that we worked on.

And let's pull up the code from that one as well really quickly and come back out and I'll pull up my

steps code.

Here it is right here.

And I want again specifically to look at the solution with for loops.

Here's the for loop right here.

So the for loop we took some input n right here and then based on the input n we had to nested for loops

right here.

So one nested inside of the other that meant that as we started to increase the value N into our algorithm

we had to do significantly more things each time and was increased by 1.

So when end was equal to 2 we essentially had to do four things we had to produce one to three four

characters when Ed was equal to three.

We then had to do nine things and one end was equal to four we had to do 16 things.

So in this case there's clearly not a one to one relationship between the input to our algorithm and

the number of things we had to do or the amount of processing power that was required in this case the

number of things that we had to do was an squared or we had to do essentially end times and things to

execute our algorithm.

So when you have to do end times and things we would refer to this as an end squared runtime complexity

or a quadratic runtime so we'd get these kind of different terminology for identifying or runtime.

We get both this kind of equation looking thing right here which is the end squared.

And we also have this kind of nomenclature or a kind of the verbal form I would identify this as quadratic

in this case.

So let's take a break right here.

We're going to continue in the next section and we're going to look at several other very common run

times and also start to talk about how we can identify the runtime of a given algorithm.

So quick break and I'll see you in a minute.
---------------------------------------------------------------------------------------------------------------------

50. Determining Complexity


In the last section we started talking about runtime complexity and we took a look at our reverse algorithm

or string reverse one and these steps algorithm we had said that because the string reverse algorithm

had to do one additional unit of work for each character that was added into the input we would have

a linear runtime because there was a one to one relationship between the amount of work we do and the

input set then for the steps algorithm we had said that each additional piece of input that we got or

each increment to it I should say in this case meant we had to do and square more things so we had to

do significantly more work.

Each time our input increased.

Now one thing I want to make really clear here because some of the nomenclature that I've used is not

super obvious.

Notice how during our steps algorithm when we were putting it together we had that input or the input

argument was called n this and right here of four or three or two.

This is a different and than the end that we're using over here to specify a runtime.

So over here the input to our algorithm.

This might have been better indicated as like you know a number of steps or something like that we could

call it steps maybe that would have made life a little bit more clear.

So the two are not the two are related but I'm not saying that it's the same exact number.

That's all I mean to say.

OK so let's now continue by looking at some very common run times that we will use to identify many

different algorithms.

So here's some notes on some different run times that we're going to see in the wild.

These in general are really the Algor are the seeing of the runtime.

You want to keep in mind there are other runtime that exist.

There are other types that you have to do a little bit of math to calculate but in general many of the

different interview questions you will be asked will fit into one of these buckets or some combination

of two and we'll talk about some of the rules around when you might combine two and all that kind of

good stuff.

So I know that you know it's really boring when a presenter reads notes directly off a slide or a diagram.

Nonetheless I do want to quickly read through some of these descriptions right here because a lot of

them contain some very important notes.

So we're going to start to talk and talk about this first run time and then go down towards the bottom.

So let's first start talking about constant runtime cost runtime means that no matter what our input

set is or no matter what input we give to the algorithm it's always going to take the exact same amount

of time to execute the algorithm.

So for example if we came up with some amazing magic algorithm that does not exist but if we came up

with some amazing magic one where we said as the length of string that we put into our string reverse

function changes it's always going to take exactly the same amount of time to reverse it.

If we came up with some magic algorithm that did that we would refer to that as constant time.

However such an algorithm doesn't exist as far as I know for a string of verse.

So we don't really get to do that easily.

All right back here.

So Constantine we really see this as the Holy Grail and many times in an interview setting there might

be some way to execute some problem or to solve some problem in a kind of easy way or there might be

some very easy solution that might take say linear time or quadratic time.

But your interviewer will say oh I specifically want you to solve this problem in constant time.

So there are several problems that kind of fit into that category and your interviewer might ask you

to target a solution that meets one of these specific times.

The next one is logarithmic time.

So log right here stands for logarithm.

It's like you know the math term taking the logarithm of a number we have.

We will have a runtime of logarithm or logarithmic time if we double the number of elements that we

work with are working with or if we just increase them.

But that doesn't exactly double the amount of work that we have to do logarithmic run times are most

important.

Whenever we start looking at any type of search algorithm.

So searching through a sorted array of data we can always assume that that might take an algorithm that

runs with logarithmic time and that's an important assumption especially as we start to try to calculate

the runtime of different algorithms.

That's another note that we'll talk about in just a little bit as well.

Linear Time is one of the more common run times that you're going to see and a lot of interview questions

especially the more simple or straightforward ones with linear runtime you can easily identify this

by seeing if you are iterating through some collection of data.

So for example in this course so far every problem that we have had where we had to iterate through

some string in some fashion every single one of those has all been when your run time.

So in each of those we had to iterate from zero to some length of some collection like an array length

or a string length or whatever it was.

And in each of those we were probably working with linear runtime again just like we were talking about

with the reverse string function in the last video.

Anytime you have linear time you are saying that if we add one element to our input set it's going to

take one unit of performance or whatever you want to call it one unit of more time to complete the algorithm.

Now the next one guy to look up the term the technical vocabulary term for this one I don't really like

that name right there cause causal linear time whatever you want to call that basically Antibes log.

And so this would be a runtime complexity that we would see if we start to increase our input set to

our algorithm but increasing that input set by 1.

Increase the amount of time it took to to execute the algorithm by one plus a little bit.

So one plus a little bit for every element we add to our inputs set a very good example of this would

be any type of or I should say any type but many different sorting algorithms that we might work with

are usually going to be working with and times log and runtime.

The next one is quadratic time here.

So we just saw an example of quadratic time with our steps algorithm here.

We had said that as soon as we started to increase or add one element to our input to the algorithm

it started to take dramatically more time to produce the result set a very easy way of identifying an

algorithm that uses quadratic runtime is what I like to refer to as the hand shake problem.

So an easy way to picture this.

Imagine a group of people standing in a room.

If you send some additional person into that room and you introduced that new person to everyone else

and you had them like Shake hands that would be essentially an end squared complexity.

So each additional element that we add to a given collection has to touch or somehow iterate over or

somehow deal with every other element in the collection.

So you can kind of remember that handshake problem as an example of quadratic complexity as another

person was added into the room.

They then had to shake hands with every other person and every person in the room had to shake hands

with everyone else finally exponential time.

So this is absolute assurances.

Worst case is not quite worst case but it's one of the worst cases that we're going to be considering.

So if we start to add a single element to a collection the processing power significantly significantly

starts to increase.

And so this is not any type of algorithm that starts to use exponential time is one that we absolutely

positively want to avoid and we will see an example of exponential time in just a moment with one of

the problems that we're going to work on.

If you start to suggest an exponential time solution to a problem in an interview that is a very big

deal that's a very big bad deal to clarify.

Very bad thing if we are able to identify an algorithm as requiring exponential time we never want to

propose it as a real solution to a problem.

In an interview you definitely can you know use it as a solution to get started but very likely if your

interviewer is proposing a problem or asking you a problem and you're thinking oh this will probably

take exponential time to solve.

Chances are there's going to be a much better way of solving it.

I can just about guarantee you.

And that's what a lot of interview questions all revolve around.

Your interviewer will ask you a question that might require exponential time or quadratic time.

And so it's relatively a not very efficient algorithm and you might be able to identify a solution very

easily that uses one of these.

And your interviewer is going to expect you to say Oh well I can think of a solution that uses this

but I can also think of this much more challenging and difficult to implement solution that might take

linear time.

That's what they're really asking.

In those situations they want to see that you can recognize an algorithm as being inefficient and come

up with some more efficient algorithm out of it.

OK.

So this has been a quick review of some of the very common runtime that we will see in action.

Let's now take a quick break.

We're going to continue in the next section and talk a little bit more about some common tips that I

have for you about identifying runtime complexity.

So quick break and we'll continue with this in the next video.
---------------------------------------------------------------------------------------------------------------------

51. More on Runtime Complexity

In the last section we spoke about some common runtime complexities.

We're not going to continue about by talking about some odds and ends around runtime complexity.

So just some things I think you should really know about it.

The first thing I want to discuss is Big O notation.

So Big O is another way of referencing runtime complexity.

So your interviewer after you finished some algorithm they might ask you hey what is the runtime complexity

of your solution.

They might also ask you what is the big O of your solution.

Either thing that they ask.

They are both asking what is the efficiency of your solution.

You know what is the runtime of your algorithm.

Big O notation is a way of writing out this runtime complexity that is commonly seen in the academic

world.

So for example linear runtime could be indicated by writing Oh and it's called Big O because it's literally

a big O of n.

So if you see all events like this that indicates linear run time all of one would be constant.

Of and square to be quadratic.

So essentially when you start seeing these big O's with some kind of little equation inside of it we're

really still talking about these different run times over here.

The term Big O in general means something slightly different in the academic world but in an interview

setting any time you hear runtime complexity or Big-O notation or anything like that they're always

asking you what is the run what is the efficiency of your algorithm.

Now the next thing I want to tell you about is some tips around identifying runtime complexity.

So for identifying complexity or number.

This is what you're going to be asked in an interview setting for identifying the stuff.

I've got good news and bad news.

The good news is once you get some experience with it it gets pretty easy.

The bad news is that like many other things in the interviewing world there's not some magic formula

that you can just be given that 100 percent of time always correctly identifies the runtime complexity

of something.

It's something where you have to have a little bit of experience you have to look at some different

algorithms and just get a sense of what's going on.

There's really not a hard and fast rule of exactly how this stuff is done.

So I'm going to give you some tips right here on some common complexities and how you can identify them

as we go through many other algorithms and solutions in this course.

We will also spend some time to discuss their runtime complexity as well so that you can start to develop

that sense of what runtime complexity is and how to really determine it.

So let's go through some of these really quickly.

Again I know it's really annoying when a presenter reads directly off a diagram but you all add some

extra words in here and each of these.

So the first one is if you ever see yourself iterating through a simple for loop with like a single

collection.

Great example of which would have been our reverse string algorithm back here.

So we had a simple for loop more or less iterating over a fixed set of records.

Right like just these characters right here.

When ever you see that chances are you have linear runtime extremely likely so simple for a loop probably

means you have Brunt's seemy linear runtime complexity.

The next thing to keep in mind is OK well if we are only iterating through say half a collection like

if we only look at half a string.

Does that mean that we are using a runtime of like end divided by two.

No there is no such thing as like end divided by 2 or 1.5 times n or two times and or three times then

in runtime complexity.

Take any of those numbers like any of those what we refer to as constants and you always drop them out

of the equation.

So any time you see a for loop iterating over a closed set of data even if it stops early even if it

says I'm only going to iterate through like half this thing it's still going to be a linear runtime.

So always drop out those constants.

Another thing to watch for is if you are iterating through two different collections of data.

So imagine for example if we had said Okay write an algorithm that reverses two different strings two

different strings reverse both them in one function call.

That would be an example of iteration over two different collections of data into separate separate

for loops.

So you would have one for loop to reverse the first string and then one for loop to reverse the other

string so those would be two separate for loops.

In that case we would introduce an additional term into our runtime complexity.

We would say something like that has runtime complexity.

And plus him.

So the end in this turn right here is meant to indicate the runtime or the performance impact of the

first string.

And then we would introduce this second term right here to represent the second string.

Because in theory you could be passed a very very short string for the first argument to your dual reverse

function and then a extremely extremely long string for that second argument or that second string.

And so we would want to separate those two out and say OK we are reversing two separate completely different

strings.

One might be short.

The other might be long and so we would want to represent those separately.

In general you know this is not only applicable to two strings.

Anytime you are iterating over or processing two completely different sets of data you'll frequently

see the runtime complexity split out to two separate terms.

Now the next one is very closely related.

If you ever see nested for loops a nested for loop is like a big O Take a look at that right there you

know it's a big red flag.

If you ever see nested for loops iterating over the same collection.

So this same collection of records very likely that you have quadratic runtime or and squared complexity

and a great example of this was the stair algorithm.

And the are seeing the steps algorithm right here heres the steps algorithm.

So we had one for loop right here.

And the second one nested inside of it.

Another great example of this was the it algorithm that we put together.

So here's pyramid.

Here is the iterative solution right here.

Oops there we go.

So here's the iterative solution.

And we very clearly had one for loop where we iterated from zero to some target number and then inside

of that we had another for loop that it rated from zero to some upper bound up here.

So any time you see these nested for loops huge red flag.

Extremely likely that you might have and squared runtime very closely related.

That again is if we have two nested for loops.

But each one is iterating over a different collection of data a different collection.

In that case just like we said a moment ago with two separate strings we might have one string or one

collection of data that's very short and the other one might be very very long.

So that would no longer be squared because we have two different collections of data and they might

have different requirements for different lengths and each of them.

And so we would reflect that as being End Times.

And remember that's not quite so different than squared.

Remember that squared is simply end times and as well.

So it's really the same thing here.

We are specifically saying hey there's this other set of data that is not related to.

And it's called em.

But still for every record in and we have to also iterate through him.

And so that would be an example of end times in complexity.

Now the last two here are two that are great shortcuts to have very close at hand.

These are very very commonly used.

Any time you ever see any requirement in assorting or a problem for sorting any requirement whatsoever

you can essentially just assume that it's probably going to be and log and run time.

So every sort.

Operation the best runtime complexity we can have for sorting something is an log.

And so if you have an algorithm where you have to sort something chances are you will probably see a

term like this inside there.

Then the other thing to keep in mind is sorting Sumeet searching through a sorted array.

So if you have an array of say numbers or a collection of anything that is sorted in some fashion and

you have to search through it chances are you have a log and runtime complexity from that operation.

So I mean again anytime you see sorting or searching you likely will have something related with one

of these run times right here.

So just something to keep in mind.

OK.

So that is a quick list of big tips to watch out for when identified runtime complexity.

Again this is something where you just got to have a little bit of experience you've got to do it.

You have to be told OK here's the algorithm Here's what the runtime complexity is and you have to develop

your own feeling for how it actually works.

It's not something where I can just give you hey here is the absolute you know rule of thumb to use

100 percent a time that doesn't exist for this.

Unfortunately I wish it did.

Now the very last thing I want to tell you about kind of a last minute thing I'm going to throw in here

is space complexity.

So we've been talking about runtime complexity which is a reference to the performance of an algorithm

in terms of processing power.

Another thing to are that you might be asked an interview setting is the space complexity of an algorithm.

So space complexity is extremely similar to performance but it is a reference to how much RAM or memory

or space an algorithm needs to complete a given task.

In general you can really apply a lot of the same rules around runtime complexity to space complexity.

Great examples of this would be something like reversing a string.

In our case for every additional character that we added into our input set we had one additional character

that we needed to return in the output set of data.

And so the amount of memory that we spent was linear because for every one additional character we needed

one additional element in our string to be added.

Another good example of this would be the steps algorithm.

We also looked at.

So in this case we had said that for each increment of these steps argument we had to do.

We had to printout to a dish or some number of additional items in our resultset.

So not only do we have to process more data or we had to iterate through some loop more times.

Our resultset also had significantly more entries inside of it.

For every record that was added in.

And so this will be a great example of quadratic runtime for space complexity as well because you can

see very clearly right here.

For two we had to produce four items so four elements in memory for three we needed nine elements memory

and for four we needed 16 elements in memory.

Now the space complexity and runtime complexity are not always going to be identical in many cases they

might be very different.

However you know again we'll see some examples of different complexities over time I will say that space

complexity is less frequently asked in an interview setting than time complexity.

So if you're going to spend any time doing any studying or anything like that I really recommend pushing

all your time towards studying up on time complexity of post as opposed to space.

But honestly once you understand one really well usually you can pick up on the other pretty quickly

as well.

So just keep that in mind.

OK.

So this has been a lot of discussion around runtime complexity.

A lot lot lot.

So let's continue the next section we're going to start looking at some more algorithms that start to

get into this world of runtime complexity.

So let's continue in the next section and we'll start looking at some more complicated algorithms.

So quick break and I'll see you in a minute.
---------------------------------------------------------------------------------------------------------------------
=====================================================================================================================

Раздел 16:Runtime Complexity in Practice - Fibonacci

52. The Fibonacci Series

Now that we have had an introduction to runtime complexity we'll begin working on another question that

is great for profiling differences in runtime complexity between different solutions.

So inside my code editor I'm going to find the folder and open up the index dot JSE file and then as

usual We'll also start our tests.

So at the console run just fib test us dash dash watch like some.

And we should see about six or so test passing right now or see me six total right now.

All right.

Let's take a look at the problem we have to work on.

So the goal of this function is to printout the nth entry where an is an argument to the function of

the Fibonacci series the Fibonacci series is this ordered list of numbers that you see right here that

Fibonacci series can be characterized by taking two numbers adding them together to produce the next

century.

So to look at this and diagram format we usually kind of take these first two numbers right here of

zero and one for granted because there's no previous numbers for it that we can add together.

So for this third element right here we would look at the previous two numbers zero and 1 we would add

them together and that gives us one then for this element right here.

We would add one plus one that gives us two for this one we have two plus one that gives us three 3

five is three plus two.

And so on.

You get the idea.

Now the Fibonacci series extends past 13 of course.

So it goes on as far as you want but this is the general pattern that we need to be aware of some just

showing the first couple of elements out of it.

Our goal with this function right here is to make sure that we return the nth entry.

So usually the way that we solve this is by generating the entire series all the way up to the nth entry

and then we return that entry.

So it's really tough to just say oh yeah I want to just generate this number right here.

Really.

Usually end up having to generate all the entries up to that number.

And then you can return that one.

OK.

Now there are two solutions that we're going to look at for Fibonacci in the next section we're going

to look at a solution that uses an iterative solution.

And then after that we'll look at a solution that uses a recursive solution.

So if at all possible if you've already seen this problem if you've done it before.

Go ahead and give a shot at the iterative solution for the next section.

If you've never done it before.

Just give it your best shot and try any solution you can think of.

So let's take a quick break right now.

Give it your best try and I'll see you in just a minute.
---------------------------------------------------------------------------------------------------------------------

53. Fibonacci Series Iterative Solution

Hopefully you had some luck putting together the Fibonacci series solution.

In this video we're going to go through an iterative solution that uses a for loop to return the nth

value from the Fibonacci series.

So here's the general plan.

We're going to create an array.

We're going to assemble all of the numbers up to entry n.

So let's assume it's supposed to be this entry right here that was given for N.

So produce everything up to that element right there and then we'll return it.

And that's pretty much it.

So let's give this a shot inside of my fit function.

I'm going to declare an array that is going to hold a series of numbers.

I'm just going to call it result.

Like so now the big trick behind this iterative solution that uses a for loop.

This is the big trick.

Again all these problems have a trick.

The trick is to recognize that these first two numbers inside of here cannot really be effectively generated

by a for loop or anything like that.

Remember the algorithm that we're using here is to say look at the previous two numbers add them together.

And that gives us in the element that we want to add to the series.

So for this number and this number there is no previous two entries that we can add together.

However you and I always know that there are going to be zero and one.

So the best way of handling this is to just manually insert 0 and 1 into this result set.

Now to produce this third element right here we can add together zero on one to produce 1 and then continue

on throughout the rest of the series just like that.

So we will use a for loop that is going to iterate from equal to 2.

So we're going to start off at two because we want to produce this element first and then we're going

to iterate all the way up to N.

So right out for left eye equals two.

I less than or equal that and I plus plus like so then inside of the for loop itself we need to pull

out the previous two records in the result array.

So the previous two records and then we will add them together and push that into the result set.

So we'll say constitute a equals result and we can either to get the previous two records and here we

can either look at the variable I subtract 1 and then subtract 2 or we could take result length minus

1 so it can be either resultant length minus 1 to get the previous record or we could take I minus 1.

Either way is totally fine.

I think we'll go with I minus one just for fun here and then B will be result at I minus 2.

So this is for Sanja loop runs now.

I will be equal to 2.

So a will be receiving the second element which is 1 and then B will be calculated by taking two minus

two.

That gives us zero.

That's the first element in the result set which is also 0.

We will then add these two numbers together.

So A plus B.

And then we will push that into the result array like so.

OK.

So this is going to generate our Fibonacci series all the way up to entry.

And now the last thing we have to do is return entry and from our result set right here.

So down below you can simply return result at an all right.

So let's save this and see how we're doing.

One other quick thing I want to mention by the way another thing we could do done here rather than saying

resulted.

And just to get the last entry we could have simply said result of length minus 1 to get the last record

to leave to you.

Again either way is totally fine.

So let's see our terminal is doing and yeah it looks like we've got the correct values here.

So all tests are passing great.

So this is the iterative solution to this problem.

Now I want to ask you right now do you have any guess as to what the runtime complexity of this is.

So the runtime complexity we can either take you know a very cerebral cerebral thought here or we can

use some short shortcuts.

So if we were going to take the more cerebral kind of academic approach to this I would say well for

every increase in n we have to calculate one additional number.

So as an increases by one we have to do one more calculation and that's never going to change.

So I would say this is linear run time.

The more kind of short cut way that we might arrive at that is to say well we've got a simple for loop

and it looks like we are always starting out at some fixed number always incrementing by one and we're

always incrementing up to this fixed target.

So another way could be to just say Well looks like we've got a for loop that iterates over this kind

of close set one for one.

So chances are it's linear run time.

So it's going the two ways that I might approach approach that.

Okay.

So this looks good.

Let's now take a break.

We're going to come back in the next section and we're going to put together and it a cursive solution

to this problem and that's where some of this runtime stuff the runtime complexity is going to start

to get very interesting.

So quick break and I'll see you in the next video.
---------------------------------------------------------------------------------------------------------------------

54. Fibonacci Series Recursive solution

In the last video we put together an iterative solution for the Fibonacci problem.

We're now going to continue by putting together an alternative solution that solves this by using recursion

instead.

Now of course as usual we will make a backup of our iterative solution here.

So I'm going to copy our previous effort.

I'm going to move down to the bottom of the file and paste it and then comment that thing at all then

go back up to the original implementation of top and delete the contents of the function.

OK.

There we go.

Now before we put together this recursive solution I want to tell you kind of a funny story that I think

is great commentary on the state of coding interviews in general and this is something that we've been

discussing all through the course so I have worked at a company in the past years ago where every interviewee

that came in every engineer who was interviewed they would all come in and we would we would always

ask them the same problem.

We would ask them Hey Saul Fibonacci using recursion and I got to tell you there was two types of engineers.

There was two types.

There is one type who could solve it.

They did a great job.

You know they solved it using recursion and then the other type the other engineer they could not do

it for the life of them.

And you might be curious what the difference between those two engineers was and this is for my own

practical experience I'm very much convinced of this.

So what was the difference between the engineers who could solve it and couldn't solve it.

Well at the end of the day there was one simple difference.

The people who could solve Fibonacci using recursion had already seen the problem before.

That's it.

So this is the classic problem where if you see it one time you say OK.

Yeah it looks reasonable.

I can memorize that and then you say OK that's how assaulted not using recursion because it is a classic

example of recursion.

However if you've never seen it before it's so incredibly unlikely that you will come up with a solution

to Fibonacci using recursion that I'm about to show you it's my opinion it's just really challenging.

Extremely unlikely.

I'm sure there are people out there who have came up with the solution independently but I am very much

convinced that this is an example of a problem where you've either seen it or you haven't.

So I'm very happy you're here watching this lecture because it means that you will see the solution

and you'll be able to answer this question when it comes up in your own interview.

By the way Fibonacci series is a incredibly common question to be asked.

So this is definitely one to keep in your head.

All right so let's do this because of what I told you.

You know this is a problem where you've either seen it or you haven't.

I'm just going to put the code up here for the solution and then we'll talk about the disk the solution

and how it works.

Like I said it's really challenging to come to this solution on your own.

My personal opinion of course.

So we're going to say if an is less than to return an and then Otherwise we want to return fib and minus

one plus fib and minus two and that's it.

That's the solution right there.

So let's flip on over to our terminal I'm going to save this file a flip on over to the terminal and

I'll verify.

Yeah it looks like our tests are still passing here.

So very good.

Well kind of very good.

So why does this work.

You know there's a couple of different things to talk about with this Fibonacci solution right here.

The first thing I want to do is tackle it from kind of the recursion side and understand how the recursion

here works.

After that I want to come back to a solution and talk about the differences between this one and the

one we worked on before.

From a time complexity standpoint.

So understanding this recursive solution right here is really challenging unless you put it into diagram

format which I've done.

So let's go take a look at that diagram.

Now before we do one thing I want to point out here is the only time in which we appear to actually

return a number from Fibonacci.

Right here is when and is less than 2.

So when and is equal to zero or one that's the only time that we're going to return an actual discrete

number.

So with that in mind this is what I want you to be aware of right here when we call Fibonacci with zero.

We get back zero when we call Fibonacci with one.

We get back 1.

Those are like very discrete numbers that we definitely get every other call to Fibonacci like if we

call Fibonacci with 10 or five or six.

Well it means that we start entering into this recursion and that's when we start having to think about

OK how do all these function call stack up and eventually give me a result.

So then mind let's take a look at a diagram that's going to help us kind of understand what's going

on here.

All right so at the very top we have an imaginary function call to Fibonacci with an input of five.

So as you just saw you know let's take five right here and let's go back to our code and think about

what would happen.

So we called fib with five is five less than two.

Well no of course it's not.

So we call Fibonacci with four and five with three so that results in two function calls.

And that's what I'm reflecting this diagram over here.

Here's Fibonacci being called with for years Fibonacci being called with three.

Now in the case of four.

Let's walk through the case of four.

So fib of four or an equal of four is for less than two.

Well again no it's not.

So we call Fibonacci with three and Fibonacci with two.

And then the process repeats itself for the rest of this tree right here.

So eventually we get down to the bottom of the tree and eventually we hit that case.

And it's less than two.

And we start to actually return some numbers.

So that is these blue squares right here.

All these blue squares.

This is where we actually return some numbers.

Now as you saw just a second ago right here.

So whenever we call Fibonacci recursively we are adding the result of those two together.

So at the end of the day you can kind of imagine that all these blue squares right here are eventually

going to be added up and total together.

So let's take all these different blue squares right here and take their sum.

So specifically what calling Fibonacci with this particular number would result in.

So when we call Fibonacci with one it returns 1 if we call Fibonacci with zero return zero.

So we don't really care about Fibonacci with 0 because it returns zero.

So I'm going to just kind of like gray those out.

All we really care about here is calling Fibonacci with one.

So when we call it with 5 it eventually results in Fibonacci being called with 1 1 2 3 4 5 times.

So we can add together one two three four or five.

OK.

So Fibonacci of 5 should be five.

Let's go back to our diagram right here.

The sequence right here so element 0 1 2 3 4 5.

So 5 is 5.

That is definitely the correct answer.

So that's how it works.

Basically we keep on calling Fibonacci with smaller and smaller numbers until eventually we meet this

base case right here and start to return some actual value.

Now that's kind of you know easy to think of for the fifth five case let's look at just one more case

here.

When we call for the notchy with an input of six.

So here's what the diagram looks like with six.

And yes this took me a couple of minutes to make to make this diagram right here.

But whatever.

So we called Fibonacci with six.

That of course results in a call to Fibonacci with five and four.

And then we go down this tree and eventually we collect all these 1 terms and add them all together.

So we get 1 2 3 4 5 6 7 8 8 is our total.

Let's go look at our series again.

We get 0 1 2 3 4 5 6.

So calling Fibonacci with six should return the six element in the series which is 8 and that's exactly

what we got from this result of adding these all together over here.

So that's how the recursive solution works.

Does that sound confusing.

Well I very much should.

I really think that it should.

I can't imagine why an interviewer would ask this thinking that someone's just going to bust out Fibonacci

on the fly with this recursive solution right here.

You know honestly a lot of interview questions especially coding questions are not so much designed

to test your ability to generate solutions.

There are more testing just to say hey do you have the common knowledge that we expect someone interviewing

with our with our company to have.

In other words I'm kind of convinced that people are asked for the notchy here just to make sure that

you know you have seen the problem Fibonacci before.

Because if you haven't seen it maybe that's some commentary about your experience in the computer science

field or you know something I don't know.

That's the only reason I can personally really imagine that Fibonacci is asked in a recursive type of

context.

Anyways enough of my ranting here.

You know obvious is a question that gets me a little bit upset.

I have been asked this question in an interview and you know I did pass it solely because I memorize

the solution not because I understood at all how the recursion was working and so I guess that's why

I get frustrated the question because it really proves nothing about your interviewee.

OK.

Anyways enough of that.

So I do want to have a good discussion about time complexity for this recursive solution right here

because it's actually quite awful and you might be surprised to see how bad it is.

So this whole time complexity discussion around Fibonacci I think perhaps that's why interviewers ask

this question because it is a great problem to kind of profile your understanding of algorithm performance

and time complexity and all that kind of good stuff.

So let's get to the next video we're going to do a kind of deep dive on time complexity between these

two solutions.

And we'll talk about some possible solutions to improve the time complexity of a otherwise very slow

algorithm.

So quick break I'll see you in the next video.
---------------------------------------------------------------------------------------------------------------------

55. Memoi-....Mem-...Memoization!

In the last section we put together a recursive solution to the Fibonacci function.

And I got to reveal some of my baggage around recursion just kidding.

Anyways in this video we're not going to continue by discussing some of the performance characteristics

of this recursive solution right here compared to the previous iterative solution we put together.

So really quick while we still have the recursive solution implemented I want to flip on over to our

tests running in the terminal you might have noticed that for each test that we're running here.

So here's one test is another issue is another.

Sometimes we can see the amount of time that that test took to execute printed off to the right hand

side.

If the test takes less than one millisecond the time is not printed.

So we run it again we might see that some of these tests randomly appear to take slightly longer than

one millisecond.

But most interestingly you'll notice that when we tried to calculate the Fibonacci value for 15 it ended

up taking just over 1 second total.

So that's kind of surprising because we've got one two three four.

These all appear to have been computed rather quickly like right around one millisecond.

But then by increasing up to 15 it took about a thousand times longer to compute really 1000 years one

millisecond years 1000 milliseconds that's a thousand times longer.

So what's going on here.

Why are we seeing such a dramatic increase in time for such a small increase in the value that we're

trying to compute.

Well let's look back at our diagrams a little bit and try to figure out what's going on.

So here's the diagram that we're looking at just a second ago of a call to the Fibonacci function with

five as the argument.

So when we called Fibonacci with five the Fibonacci function itself is being invoked many many times

automatically.

So each of these boxes right here represents one function call to Fibonacci during our with a recursive

solutions let's count these out.

We've got 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15.

So we've got 15 calls to the Nazi function with 5.

Let's now compare that to the Fed six function call over here.

So notice how 5 5 is still right over here and we just said that that was 17 calls total or 15 whatever

it was i already forget.

So we can imagine this is 17 calls or whatever it was.

And then when we also add in this additional 5 4 right here we have to call because we're now dealing

with the basics.

We now have an additional 1 2 3 4 5 6 7 8 9 10 calls so 17 calls for 55 and then 27 total for that 6.

This is what we refer to as back over here on our diagram.

Exponential run time.

So for each additional element that we add into our collection or for each increment of the value N

to our function we're experiencing a dramatic increase in the number of function calls that are required.

Now in my notes right here I say very clearly.

Oh yeah the processing power required doubles as we just saw.

It does not exactly double.

It actually slightly less than doubles.

But the idea is still very similar here.

For every additional element we're getting a dramatic increase in the number of function calls or essentially

operations required to calculate our value that we're trying to determine.

So our recursive solution that we're working with right here is what we would refer to as an exponential

time solution.

Remember like we said a moment ago when we were first discussing exponential time any exponential time

algorithm you create is an automatic no no.

We never ever want to accept an exponential time algorithm as a solution to an interview question.

If you came up with this solution right here and then your interviewer said Gee how long will this take

to run if you put in like five of 50.

And you said oh I don't know but you know whatever we can probably just sit around and let it wait.

Well Fibonacci 50 is going to take an extremely long time to be calculated.

So be aware that any time we start seeing a exponential run time function it usually means that there's

a different solution we can put together that might be much more efficient in nature.

So in this particular case you know let's say that you were sitting with your interviewer and they said

hey give me the recursive solution to Fibonacci.

And you came up with this right here.

They very likely will say to you.

Hey what do you think the runtime of this would be.

The answer that you want to give is what's definitely to be exponential because for every increase in

N we are going to get a dramatic increase in the number of function calls that we get.

So here's what's going to happen next.

And we've discussed everything to that point.

The next thing your interviewer is going to ask you is OK well is there any way we can improve this

recursive solution here to not be exponential run time.

Is there any way we can you know put in some additional fixes to make sure that it is not ex-special

runtime and you might say oh well we could do the iterative solution which we already discussed was

linear runtime and you know what maybe they'll let you get away with that.

But if your interviewer says is there anything we can do here to improve the runtime of this algorithm

they are looking for you to say something very particular.

OK here's what they're looking for you to say they want you to say well you know I'm looking at all

these different function calls because we know when we call like fibbers 6 we're calling Fibonacci all

these different times.

And when you start to look at this chart right here you start to realize that the function is being

called many times with identical arguments.

So for example here is 5:3 being called one time over here.

5:3 also gets called right here and right here here is fib to fib gets called with two over here over

here over here and over here.

So clearly our Fibonacci function is being called multiple times with identical arguments.

I've taken the liberty of kind of graying out a lot of boxes here.

And I actually I just realized I missed one let me do this one too.

So all of these greyed out boxes that you see or duplicate calls to the Fibonacci function with identical

arguments.

So if there is some way that we could avoid all these extra function calls then if we the Fibonacci

was six we would really only have to worry about doing all the computation stuff for 5 5 4 3 2 1 and

0 exactly one time and then all the other times you know maybe we could figure out some kind of clever

solution there.

So in other words or let me kind of cut to the chase here and say we are.

Interviewer asks you if there is some way to improve the runtime of our solution.

What they want to hear is this word right here.

Now the bad news is that I can't pronounce this word.

I'll be honest.

It's like I can't even it's memoir Mentawai memorize memorization.

You know what.

Go look up the pronunciation on Google.

Memoization What if for whatever reason I just can't do it anyways.

This is a term for something that we can do in with a function call that essentially does this right

here.

So when we memorize a function there we go that's it.

Memorize when we memorize a function we're going to record the arguments of each function call so we

can record the arguments we're going to run the function and then we're going to store the result of

that function call.

So we've got some like little table in memory that says hey our function was called with this number

and when it was and returned this result and then here's the key.

If that function ever gets cold again with the exact same arguments rather than running the function

again and doing the entire recursion process all that crazy stuff rather than duplicating all those

results.

Instead we're going to turn that result that we had computed previously.

So what does that look like in practice.

Well basically just like we saw in the diagram over here we're going to say OK whenever we try to calculate

fibs 56 we're going to immediately make a call to fab five that's going to make a call to four.

And so this is the first place where it's actually meaningful.

OK so let's concentrate on this right here.

So we're going to call Fibonacci with for you and I are going to write some code that is going to say

oh it looks like our Fibonacci function is being called with an argument that has never been called

with before which is for.

We will then run the Fibonacci function with four.

We will take the result from that and we will store it in some special location.

And so you and I will know that if Fibonacci ever gets called with 4 again we have already run that

situation we've already ran that scenario.

We don't have to execute the function again.

So if Fibonacci is ever called again with the number four we're not going to run the function itself.

We're going to go off to that special place in memory and retrieve that pre-computed result.

And so in practice here's Fibonacci four over here.

After we do that kind of caching layer as soon as we go over here and see Fibonacci 4 over here we are

going to say oh we don't have to do the recursive call here.

We don't have to go through all these additional function calls.

We've already ran Fibonacci with four and we already know what the value is or what that should be returning.

And so let's just return that right away rather than spawning all of these additional function calls.

So by doing this memoization process or by cashing all the results that come out of the function we

can dramatically dramatically improve the run speed of this function.

Now the one thing I want to be aware of here this is the very exact answer your interviewer is looking

for.

If they ask you how can we improve the runtime of this recursive solution right here.

They're asking you for a wise solution.

Now this is not something that's only applicable to Fibonacci.

There are many other interview questions or algorithmic questions I should say that can be answered

through this exact same memorization process.

So this is a great little tool to have in your back pocket because I can almost guarantee you you will

have an interview with someone who says hey this function looks really slow how can we speed it up.

And one of your first tools you want to reach for in that case is this memoization thing I'll get.

So enough talking about memorization.

Let's take a quick break.

We're going to come back in the next video and we're going to write some code to memorize this Fibonacci

function right here.

So I'll see you in just a minute.
--------------------------------------------------------------------------------------------------------------------

56. I Believe Its Memoization!

In the last section we spoke about how we can use memoization to dramatically improve the performance

of our recursive solution right here.

Remember I can't say this enough.

It is so incredibly likely.

In an interview that an interviewer is going to ask you to write out some problem or solve something

and then they are going to say to you how can we improve the performance of this thing.

If they see that it is entirely likely not 100 percent in time but it's very likely that they are referring

to memoization.

So this is a rather important technique.

So stay tuned and let's get through this thing.

Let's first start off by looking at a diagram that's going to help us understand how we're going to

set up memoization our Fibonacci function.

So you and I are going to write a function that we are going to call memo lies.

So we're going to write a brand new function.

This is going to be a generic memoization function.

When I say generic I mean that we can use this function that you and I are going to write not only for

this Fibonacci thing but for any other function that requires memorization as well.

So I'm going to show you a technique that you can just repeat in any interview setting and it's probably

going to work just fine.

OK.

This memoization function is going to be a function.

So this is a function right here.

We're going to call it with a slow function like our slow version of Fibonacci.

So we're going to take the slow version of Fibonacci.

We're going to pass it into this memo wise function and then the memorized function is going to return

a fast memorized version of for the notchy some of the words we're calling a function with a function

that returns a function base.

There's a lot of functions floating around here.

That's all I mean to say.

So let's put together some code to kind of set up this system right here.

So I flip back over the first thing I'm going to do here is to rename our existing function to slow

fib.

So I want to make sure it's 100 percent clear that this is the slow version of our function.

So I'm going to call it slow fib then right above it.

We're going to declare our minimalize function.

So this is the memo Lizer we're going to pass a function to it.

It's going to return a new function that has dramatically speeded up.

So whenever we call this thing we're going to pass a function into it.

So we will receive that as an argument called F.M. short for function then we will return a new function

right here.

So this is going to be our dramatically faster one this is going to be the one right here that is supercharged

and is much faster than the base version.

Now to give you an example of how you would actually apply the singing process or in practice excuse

me.

So we've got a slow here right here and we've got minimalized right here.

So an example of how we would use this thing in reality would be to do something like Konst fib equals

Mentawai is slow fib like this.

So we take our slow function we're going to pass it to memorize and then that's going to return a new

function assign it to fib.

And then we will export that minimalized version from this file.

So now all you have to do is add some implementation to minimalized right here.

So remember that the entire idea behind memoization is that we declare some storage area some place

where we can record all the arguments that are used to call the function and the respective result from

all those function calls.

So right above our return statement right here.

I'm going to declare a little object that is going to store all of our calls to the fast version of

our function.

I'm going to call it cache because that's essentially what it is.

It's a record of all the previous calls to this function and their respective results.

Next we're going to receive some arguments into the inner function right here.

Now this is the part that's really hard for people to understand.

OK so let's really focus on what's going on here.

When we called them Semmelweis we return a function.

So this anonymous function right here is fib right here.

This is the same as this thing.

So at some point time we're going to want to call fib with like 5 or whatever it might be right.

So this anonymous function right here is going to receive the arguments that were actually intended

to be sent to the slow fib function.

So we do not necessarily know how many arguments will be passed to this function right here because

we are making a generic version of memorize you and I know that yeah we're going to use it with Fibonacci

right here which only ever gets one argument.

But if you and I want to reuse this thing again in the future with some other function maybe it takes

two three four however many different arguments we need to code this thing to assume that we might be

receiving multiple arguments.

So to do that we're going to use a little bit of yes 6 or E.S. 2015 code.

We're going to say Dot dot dot X when we say dot dot dot ARGs that means I don't know how many how many

arguments this function will be called with.

Just take all the arguments and assign them as an array to this variable called ARX.

So this is kind of some defensive coding right here we are saying I don't know how many arguments a

singular receive all right now the next thing we're going to do is really check to see if this function

has ever been called with this particular set of arguments before.

So we're going to look at the cache object.

We're going to look at the key args and if something exists there then we're going to immediately return

that like so.

So this is the actual caching part.

This is the part where we say hey have you ever have we ever called this function with this particular

set of arguments before and store the results in this cache object.

If we have then just return that right now and don't do any other work and especially don't call the

original function.

So this is the actual caching mechanism in place right here.

Now if we get past this if statement then it means that we've never called our function with that set

of arguments before.

So we need to make sure we call that function take the result and cache it inside of our cache object

right here.

So we're going to say Konst result.

So this is going to be the result of calling our slow fib function.

We're going to call the original slow food function which remember was this argument efen right here

and then whenever we call a function with an array of arguments which this is right here we have to

use the Apply helper.

So this is a little bit of back to basics with javascript right here.

Zarian apply can pass in.

Yeah we're going to pass on this and Ark's like so if apply right here is a mystery to you.

I really recommend you flip on over to the Indian Web site.

Remember that's the Mozilla developers network Web site and read up on Apply a little bit because it

is kind of integral into how we make sure we call Ark's here.

Next we're going to take the result from calling our slow fill function and store it inside of our cash

object.

So we'll say at in the cash object at the key args store the result that we just created and then right

afterwards we'll return the result.

Okay.

So I know this is some crazy code right here.

This is bringing back flashes of that spiral matrix project we are problem we worked on earlier.

But nonetheless this is a working very generic minimalized function right here that will work for many

different functions that you'll create.

Let's go check our test now and see what's happening.

So in our test file when I run the tests you can now see that's the wrong set of us.

There we go is the right set.

So you can now see that we can correct the Fibonacci or calculate the Fibonacci value for 15 basically

instantly.

Now thanks to this memoization process.

Now I really do think that it still might be a little bit confusing on exactly how this is working.

So I'm going to do a quick review on how memorize works right now.

If you've heard me talk enough about it in years thinking like steamin I get it.

I understand memoization that's totally fine.

Pozza video.

Move on to the next section.

Otherwise we're going to do a quick review.

OK.

So quick review.

We had said that hey Colin's slow fib all the time recursively is extremely slow.

We need some way to improve the performance.

So we came up with the idea of saying before we actually call the slow fill function we are going to

create a little data store or a little cache object the keys of that cache object will be the arguments

that we were trying to call slow fib with and remember that are the arguments when I say arguments I'm

talking about like some number here 0 1 2 3 4 5 whatever it is.

So if we've never called Slow fib with a particular number and before then we will call slow fed then

we'll take an and the result and store it in this cache object.

And that's what we're doing with this statement right here.

But if we have called for slow feed before with some of the given value n then we'll look into our Cache

object we'll find that and then return it instead.

So the whole idea here is that we are just avoiding calling the same function multiple times with one

or something with the same set of arguments each time.

All right.

Now there's one other quick thing I want to mention here.

Something it's not super super great.

Notice how we renamed the function here to slow fed but inside that function we called fib.

So we're not technically calling the function from within itself.

You know we're calling this like kind of pseudo non-existent function.

So a slightly better way of putting this together would have been to leave this thing being named as

fib.

And then to just reassign overfed right here.

So this would have been a little bit better.

So now we have a function named fib and it's really clear to everyone like hey this thing exists here

is where it is.

But then right after it we immediately memorized that function and reassign it back to the variable

Philbrick here.

And the reason this is important is that when we do this right here and make sure that when we actually

execute the original function and attempt to call it recursively these fit calls right here are not

a reference directly to this function anymore.

It's now a reference to the men advised version of that function.

And so we kind of avoided that discussion by changing the name of this thing to slow fib.

I just wanted you to be aware that you know that.

Technically what's going on here.

You do have to make sure that when you recursively call the function you are calling the memorized version

and not the original non memorized version.

Let me give you just a quick example of that if we had been calling slow fib from inside this thing

fed contains a reference to the memorized version.

Slow food is always the slow version.

And so even though we memorize this thing when we call it recursively it would be calling the slow version

of fit which would entirely defeat the purpose of what we were trying to do.

We would be calling the wrong version of the function.

All right.

So hopefully that wasn't too bad.

Let's continue in the next section.

And we're going to move on to our next big problem.
---------------------------------------------------------------------------------------------------------------------
=====================================================================================================================

Раздел 17:The Queue

57. What's a Data Structure?

Now that we've spoken about runtime complexity and we've seen a good example of it with the Fibonacci

function we're going to move on to the next big chunk of content in this course which is data structures

data structures are all about runtime complexity and so all those discussions we had about identifying

runtime complexity and all that kind of good stuff is now going to get super relevant in the next set

of exercises.

Now when we start thinking about data structures in general especially in the context of an interview

there's two big important things I want you to remember.

So here's what they are.

First a data structure is some way of organizing information or data in your program with some optimal

runtime complexity for adding editing or removing records.

So in other words these different data structures that we're going to look at all have very well optimized

ways of accessing or editing data.

And so in the context of an interview usually a lot of these data structure questions are really themed

around runtime complexity.

If someone says to you.

Hey write some function that does X Y Z.

One of the first things that I want to get you to think of is what data structure can I use to solve

this problem that has some optimal runtime complexity for what we're trying to solve and we're going

to see many examples of this as soon as we start getting some background on these different data structures

and seeing what each of them are good for.

Now the second thing I want you to understand and this is something that's very confusing when you start

working with some classic data structures in javascript.

Right so this is something that will be a little weird javascript natively implements several very important

very core data structures.

Even so you're going to be asked about what I call your kind of inferior data structures.

That's not the best term in the world.

Let's look at a diagram that's going to help kind of illustrate what I mean by this.

So here's diagram kind of like I don't know not quite a pie chart but the big blue circle is kind of

demonstrating what a javascript array has the capability to do.

So the javascript array has a capability to do a tremendous number of different things.

Now down here in this tiny little white circle you know I'll make it like as small as I can possibly

make it basically this tiny little circle of functionality right here is what a cue does.

And so what I mean by this diagram right here is to say a javascript array does everything that a classic

Q data structure does.

Nonetheless you will still have interviewers who ask you to put together a queue from scratch.

That's what I'm trying to get at here.

So there are portions of javascript that take care of these really fancy data structures for you automatically.

However you will still have interviewers ask you to build these tiny little basic things from scratch.

Now in some cases especially in the QCA case of a Q or an array we're going to use a javascript array

to represent a queue and that's the part that is kind of confusing when you start doing this interview

stuff you're thinking like wait why am I making a queue when I could just use an array.

But wait.

I'm going to make a queue out of an array like that doesn't make any sense.

So this is just one thing I want to kind of introduce you towards and get you thinking about as soon

as we start working on queues and stacks in particular.

Speaking of which the very first data structure that we're going to look at in the next section is a

queue.

So let's take a quick break.

We're going to continue in the next video.

We're going to start to discuss exactly what a Q is and how it works.
-----------------------------------------------------------------------------------------------------------


58. The Queue Data Structure

The first data structure that we're going to take a look at because also one of the more straightforward

ones.

So we're going to get a nice gentle introduction to data structures here in this video.

We're going to start to discuss Qs.

So let's take a look at what a cue is a cue can be thought of as like a container of sorts where records

or pieces of data enter on one end of this container and then exit on the other.

You can really think of a cue as being very much like waiting in line to buy tickets from some ticketing

counter like for a train or for tickets from the movie theater.

In this example you can imagine that the line of people waiting to get to the ticket counter is very

much like a queue because a person will enter into the line at the very end.

Then they have to wait in the line until it's their turn to emerge from it and approach that ticket

counter in a queue.

There's no idea of skipping or cutting in line.

So the order in which you get into this queue also dictates the order in which you come out.

The process of adding a record into a queue is referred to as in queueing or adding a record and then

taking something out from the other end is thought of as deep queuing or removing a record.

You'll see these terms used interchangeably.

Now I want to expand on what we spoke about just a second ago with maintaining order in a.

So AQ follows what we refer to as a first in first out principle were abreviated F-I F.O..

If you feel like it I don't know.

So let's imagine the step by step.

Let's start off.

Out start out up here with nothing in the queue.

So we've got two records right here outside the queue.

And we want to add record eight into the queue.

So here we just added a is now sitting in the cube by itself.

And then in this next step we can insert B or add B into the queue.

Now when we attempt to remove a record the first thing that is always going to come out will be record.

So the first record that goes into the queue is also going to be the first one that comes out.

And that's why we call it first in first out.

Now here's the interesting part about QS that's very closely related to what we spoke about just a moment

ago with Howard javascript natively implements a lot of these data structures.

So in an interview setting if a interviewer says to you.

Hey implement a Q for me.

Or if you start working on an algorithm and you realize oh it would be really helpful this year remember

that when we are working with javascript we really don't have such a thing as a rudimentary cue.

We have javascript arrays which are super hyper functional in nature.

They've got a ton of different methods attached to them.

A ton of different ways of interacting with them whereas a queue has just this tiny little API attached

to it.

We really just have the ability to add records in and pull records out.

On the other side.

So again this is the part where in the last video I said that this gets a little bit weird in javascript

when we want to implement a queue.

Usually what we end up doing is taking an array and then restricting the methods that can be used to

enter in to interact with that array.

So if you really think about it a javascript array adding an item to the very front of an array it with

javascript is done by using the unshipped method and then removing something from the end of an array

is done by using the pop method.

So a very common way of implementing a queue would be to do something like this right here.

We might make a queue class like an E.S. 2015 class inside of that class.

We will initialize an empty array.

Now this array has all these different methods associated with it.

It has all the capabilities in the world but to make sure that its really clear that we are producing

a Q and so its something that should be interacting with only as a queue should be we will usually only

expose the unshipped and pop methods outside of the class.

So in other words whenever we make a cue with javascript we usually make an array but we do our best

to hide access to all these methods that belong to the array.

So your immediate question here might be Stephen why in the world would we do that.

Why would we take an array and purposefully kind of handicap it here and remove some of the methods.

Well there's two answers to that.

On the one hand in an interview setting it's kind of obvious if your interviewer says make a cue.

Well we're going to make a Q and we're going to do whatever they say.

The other reason for kind of hiding the functionality of an array in more of a practical setting are

like on a real project maybe imagine for a second you are working on some complicated problem and you

want to make you want to solve the problem with an algorithm using a queue and you realize that if you

use a queue it will be a fantastic algorithm like the best one in the world possible for solving this

problem.

But if you interact with that queue as though it were an array then all some of the performance of that

goes downhill.

So one possible reason to use a queue and try to obfuscate all the other methods that an array has would

be to make sure that if some other engineer came and started looking at your algorithms sometime in

the future they wouldn't go like oh this is an array I could just treat it like an array and reorder

the elements inside of it or remove the first element out of it or whatever it might be.

So in the real world if we want to create a new class.

Yeah we will still use an array behind the scenes and limit access to the methods on it.

And the idea there is that if we make an I.Q. It's because we very specifically want to use a cue and

don't want to treat it like an array.

So there's just one possible example.

OK.

So here's the idea behind the queue.

We are going to make a key from scratch.

We're going to make a cue and we should be able to you create a new one by calling something like this

right here.

We should be able to add a record to the cue by calling some Add method associated to it and then we

should be able to remove records or dequeue records from it by calling some method called Q Don't remove.

So I wanna make sure that in the next video when we start this exercise we'll you know we'll put this

documentation into the actual document that we're going to be working on.

But just to be clear this is essentially what we're going to try to create by making a cue.

OK.

So quick break and we will continue in the next video.
-----------------------------------------------------------------------------------------------------------

59. Implementing a Queue

In the last section we got an introduction to cues.

We're now going to continue by implementing a cue from scratch with javascript.

After we do this we'll then take a look at some different questions that are related to cues.

So let's get started inside of my q directory and my code editor.

I'm going to open up the index database file and I'm going to make sure that I start up my tests as

well.

So over at the command line will do just Q test.

J.S. watch like so and then we're going to have about four tests.

So make sure you have four running.

All right.

So let's take a look at the index dot J.S. fight the description at the top pretty much mirrors everything

we were just saying about cutes.

It is a data structure that has some methods named add and remove if we add a record to the queue.

The queue should store it until that element eventually gets removed.

Now notice that we want to implement a Q as an E.S. 2015 class.

So we should be able to run some code like this right here to actually interact with it.

For example we need to call new queue to produce a queue.

We should be able to call a queue.

Add And then you don't remove.

To get back the element that we just added.

So for this first data structure that we're going to work on we're going to do this one together just

to give you an idea of what a typical implementation in javascript of a very basic data structure like

this would look like on future ones.

Definitely to let you do it on your own but for this first one just to make sure we're on the same page

we'll do it together.

OK.

So inside the queue class right here I mean give myself a little bit of space.

Now the first thing that we need here is something to actually hold data inside of our queue like something

to actually hold these records in order.

And so this is what I was saying before about how and why we need to use an array from javascript.

So here is our Q class.

What we're making right now.

We're going to create an array inside the class and the array is going to be the thing that actually

does the storage of data and all that kind of good stuff.

It's just up to us to implement these add and remove methods.

And he said essentially we're really just going to make sure that they map up to that arrays and shift

and pop methods.

So if this seems like kind of cheating or something like that if it seems like why are we making a queue

when we're really just working with an array here.

Again this is just what we do.

You know sometimes you want to have specifically something with a q API.

And so this is really not totally outside the realm of possibility.

This question really makes a lot more sense if you're working with some more low level languages where

implementing a queue is kind of a necessity.

Anyways let's get to this.

So back inside my code editor we're going to first make sure that whenever we create a queue from scratch

it's like use the new key word on it.

We are going to initialize an array and assign it to the instance of the queue that is created.

And so the only location inside of a class that we have to run some initialization code is in the constructor

method.

If you haven't worked with E.S. 2015 classes before all you really need to know is that whenever we

create a new instance of a class if we define a function called a constructor inside of it that constructor

will automatically be called when we create a new instance.

So inside this constructor we're going to create a new array and assign it as a property to our queue

instance.

So I will say this dot data equals empty array like so now I'm totally making up the name data right

here like this can be anything we want.

It really doesn't matter.

I'm just saying to store actual data.

We will assign our raid to this data property.

Next we're going to add our add method.

So underneath our constructor method will add another method called ADD.

Let's zoom in just a little bit by the way this add method will be called with some record or some piece

of data that needs to be stored inside of our array so we can refer to that simply as no record.

That's really fine.

And then we are going to insert this new record into the underlying array that we are pretending is

our actual queue.

Remember the goal here is to make sure that we add this new piece of data in to the front the front

of this data structure or this array right here.

And so to add something into the start of an array in javascript we can make use of the unshipped method.

So I'll say this dot data dot on shift will pass in the record like so as a very quick aside just to

make sure you're on the same page here with on shift.

If I have an array right here and I call on shift on it's on shift it adds that record to the very start

of the array.

So if I put in here like two three four.

Notice how when I shift something it gets added into the start.

And that's exactly the behavior that we want to have with the queue.

All right so back over here the last thing we do now is implement the Remove method so remember remove

should take whatever is on the opposite side.

So the end of our queue and return it.

So we'll implement remove to get the last record out of an array.

We can use the pop method.

So we'll say this data pop.

And then as usual we will be really sure that we add in the return keyword because remove is supposed

to not only remove that record from the end of the queue but you know obviously we probably want to

return it as well so we can work with that record that we just removed.

All right.

So let's see how our tests are doing.

And that's pretty much it for trespassing.

So does it feel easy to work with javascript.

Yes it does.

You know to be honest here we are relying upon an array for the actual data structure.

And that's really the array that is doing all the heavy lifting.

If we were using a much lower level language making a cue like this would be obviously a little bit

more challenging but with javascript it's pretty darn straightforward.

OK so that's pretty much it for you.

Again the biggest uses of a Q is always going to be in an interview setting.

When your interviewer specifically says to you use a Q to do X Y Z.

So let's look at a question or two that might involve a Q So I'll catch you in the next section.
--------------------------------------------------------------------------------------------------------------
==============================================================================================================

Раздел 18:Underwater Queue Weaving

60. What's a Weave?

Now that we've got a better idea of how to use work let's try a little practice exercise with them.

So inside of my We've directory I'm going to open up both the index file and the queued up G-S file.

So this time around two separate files are then flip on over to my terminal and make sure I'm running

my tests for this exercise.

So we'll run just we've test on J s dash dash watch you know we've got about four tests going.

All right let's see what's going on here.

So this is the first exercise where we are going to be doing two separate things or working between

two separate files.

So the directions at the top of index start us tell you to first flip on over to that.

Q Jay Yes file and follow the directions in there.

So let's go look at that first.

All right here's the key.

Yes file.

And here's the directions that it's telling us to do.

So we're supposed to implement a peak method on this q class Q is supposed to return the last element.

In other words the next one that is about to be removed from the cue without actually removing it.

So that's the key here.

It's like remove but we're not actually removing it.

Peak is supposed to do is exactly what it says.

It allows us to kind of peek at the next element that is about to come out of the cue.

So that's the goal here.

You will take care of this little task first and note that there are a test or two over here that has

to do with peak.

So if we go over here yes.

So here's some tests around peak.

So you can verify and make sure that it's working correctly.

It goes flip back over to the index start geas file now.

So that was Task 1.

Now move on to task to the goal of test 2 is to implement a weave function.

Weave is going to be called with two separate cues as arguments.

And the purpose of the function is to combine them both into one brand new third cue and return it.

This third Q should contain the contents alternating from the first two Qs.

So we've as very aptly named We're going to take you to cues and weave their contents or alternate their

contents together.

Note that those two source cues might be of different lengths.

So you need to make sure that you're not accidentally inserting undefined into that brand new cue that

you are going to make.

So you need to look at the elements that are coming out.

Or maybe peek at the next element that's going to come out and make sure that actually exists before

trying to insert it into that new cue.

Now the last thing here do not try to abuse the fact that the q class is just wrapping an array so do

not access the array directly that is sitting inside of these queue classes only interact with them

using the Add Remove and peek functions.

So if you scroll down a little bit there's a good example right here and then a little bit lower is

the wave function.

So we will be called with these two Qs right here so.

Source one in source.

And you have a require statement in here already for the q class so you can use this to create your

own new Q..

The third one and then combine source 1 in source 2 into the new Q..

That you will create.

Now one thing to be to keep in mind here.

When you create a new queue or the third one that you're going to return from this function.

Make sure you create the queue inside the function itself like so don't create create the queue outside

of the function you want to make sure you create it inside it.

Now just in case the directions are not entirely clear I'll give you a quick diagram here.

So in this diagram we have source Q One and source Q to do.

Keep in mind how Q's work.

They usually flow diagrams from left to right.

So the next element that's about to be ejected from source Q One right here would be you.

So we would take this element stick it into result and then the other source Q to over here.

Stick that in.

Then we alternate back to one two three four.

You get the idea and then just be really clear.

Remember those two Qs might have different lengths assigned to them so if they do have different lengths

we want to make sure that we don't accidentally try to remove elements from an empty queue and stick

it into this new one.

If we try to remove an empty element from this key right here we will end up with undefined inside of

the third Q that we create and we definitely don't want that.

So make sure you are not overpumping or over removing so to speak from one of these Qs.

OK that's pretty much it.

Go ahead and give it a shot.

I'll catch you in the next section where we will go over the solution to his problem.
-----------------------------------------------------------------------------------------------------------------

61. How to Weave

Hopefully you had some success in implementing both the weave and peak functions and this video we're

going to go over the solution to both.

We're going to first start off inside of our Q Jay s file and implement that peak function before we

do.

One quick thing I want to clarify.

You'll notice this note down here while where I said do not access the array inside the queue that was

specifically talking about Part 2 of this task for part 1.

You definitely are able to and can and absolutely should access the array sitting inside the queue.

So for the peek function we are going to work directly with that array.

I do apologize if that was a little bit unclear.

All right.

So inside my weed directory I'm going to find the queue.

Yes file.

So inside of here where you have our class queue I want to add another method called Peke to this thing

that is going to return the last element or essentially the next one that is supposed to be returned.

All right.

So down at the bottom I'll add a new method called peek.

Now first we need to get access to the last element or the next element that is going to be returned

from calling remove on this queue.

So that's essentially the last element inside of our data array to get access to that last element.

We can reference this data at this dot data length minus one like so and then we will return that from

this method.

All right let's check our test over in the terminal and see if we have our tests around peak working

now.

So rerun my tests and it looks like yup the two tests that were written around peak appear to be passing

correctly.

So I think that we're in a good spot.

So now we can move on to the weave function back inside my code editor I'll change back to the index

J.S. file and then I'm going to scroll down to the function.

So I think that the first step here is pretty clear I think that we need to create a new queue that

can store the combined result of source 1 and source 2.

So say Konst Q is new.

Q Next we need to make sure that we somehow iterate through all the different elements inside of source

1 and source 2 without accessing the arrays inside them.

And so that's where the peak function that we just defined on a queue is going to come into play.

I think that we can probably somehow figure out how to iterate or how to run some chunk of code as long

as either source one or source too has an element that is being returned from peak.

Remember if there are no elements left inside of our data array in the queue then the peak function

will probably return undefined.

And so that's a key point that we need to keep in mind.

So I think that to iterate through all the elements in both these queues right here we can probably

use a while loop.

So if we use a while loop we can say that as long as either source one or source two returns a undef

a not undefined value.

That's kind of unclear but a value that is not undefined from their peak methods then we should continue

iterating with this while loop.

So in practice essentially what we want to say is source one peak or source to dot peak like so.

So as long as either one of these is returning a method then we're good to go.

Next inside the while loop itself we're going to add some logic to first take an element out of source

1 and add it to our queue and then take an element out of source to add it to our queue.

The thing to keep in mind here is that we're not quite out of the weeds with making sure that we are

not pushing undefined values into this third queue just yet.

So remember we are saying or here in looking at whether or not we should continue our while loop.

So it's entirely possible that source one could run out of elements but source 2 could still have elements

inside of it and based on the conditions of our while loop right now we don't really have any idea which

one still has elements inside of it that we want to continue to pull out.

So in short we have to check that peak function again on both of these queues and make sure that they

both still have elements inside them before we attempt to take something out and insert it into the

third queue.

So we're going to say if source 1 Don't peek.

So if there's still an element inside there we'll say q add source 1 dot remove like so and then we're

going to repeat the same process for source 2 as well.

So if sourced to speak to dot add source to remove all rights that's looking pretty good.

And don't forget I can't say it enough and all these questions you always want to make sure that you

have some defined return value.

So at the bottom of the function after doing all this combination we will finally return.

Q Let's check our tests and see how we're doing.

And we have for trespassing.

Fantastic.

So this is looking pretty good.

I think we've got a great solution here.

Let's continue in the next video where we're going to move on to our next data structure that is very

closely related to Qs.

So quick break and I'll see you in just a minute.
----------------------------------------------------------------------------------------------------------
==========================================================================================================

Раздел 19:Stack 'Em Up With Stacks

62. Stack Data Structure

We're now going to move on to our next big data structure the next big data structure that we're going

to discuss our stacks.

So in this section we're going to take a look at some diagrams around stacks.

Understand what they are and then we'll get started on a written implementation of a stack.

In general you can think of the stack as being extraordinarily similar to a queue.

There's just a couple items here and there that are slightly different.

So with the stack we are still dealing with an ordered list of records and you can imagine that those

records are living inside of some container which is the actual stack.

Adding a record to an existing stack is referred to as pushing.

So we might say that we are pushing a new record onto a stack when it's time to remove a record or take

it out of the stack.

We would refer to that as popping or popping a record from the stack.

And the big difference between the stack and the queue are the order in which items are added and removed.

So with the queue we had that acronym foe or first in first out with the stack we deal with Thilo or

first in last out.

So look at this diagram format you can imagine here the big white box is our stack.

So if we first push in record a to our stack so the zero here is saying we are going to push record

eight into our stack.

We would then have records inside the stack.

If we then pushed in B B would be conceptually sitting on top of record.

So then the first time that we popped the record or removed a record out of the stack it would always

be B because the first in item is the last one out record day.

Here was the first one in.

And so it's going to be the last one out.

Another way of thinking about it then might make a little bit more sense is to say the last record in

the first record out so deal was the last one.

And so it's the last one to come out.

On the other side again you should really think of a stock as being very similar to A.

We're just making a small change here as far as the ordering of records are being removed from this

data structure.

So in implementation this ends up being very much similar like the code we're going to write to implement

a stack will look very very much the same.

Before we flip on over to our code editor and start on our implementation I want to focus on the three

methods that we're going to implement to create a stack.

So just like we discussed adding a new record to the stack is referring to is referred to by saying

that we are pushing a record.

So we would make a push method on our data structure that would take a record and add it to our stack

to pop method or seeming to pop a record.

We would create a pop method and the idea there is that we are moving an item from the top of the stack.

Now nuda said I put in here quotes for top because in code there really is no top or bottom to the stack.

These are more kinds of conceptual items that we keep in mind.

Finally we can actually implement a peak method which would return just the top record without actually

removing it or popping it off the stack.

So these are the three big methods that we want to think about.

So without further ado because this data structure is so similar to queue I think that will kick off

the implementation in this section no need to split out to a separate section in my code editor.

I'm going to find the stack directory and open up the index js file and then of course I will also start

my tests by running the command.

Just stack slash test dot J us dash dash watch

and we should see about four test passing here.

Very good.

OK.

So the directions here pretty straightforward.

We're going to write methods push pop and peek.

Now keep in mind that we also need to have some type of record keeping structure inside this class.

The stack class to actually hold on to in order our records.

So remember in the javascript world whenever we implement some of these Bayda basic data structures

we sometimes use an array to actually implement the underlying data structure that can contains our

data.

So I kind of expect that you're also going to end up implementing a constructor method on this class

as well.

And initializing an array and assigning it to something like this dot data.

In general I really recommend you go back and look at the code from our CU example because it's going

to be very very similar to that Q class.

There will just be one or two little terms that end up changing.

OK.

So go ahead take a shot.

I'll catch you in the next section and we'll start to look at some solutions.
--------------------------------------------------------------------------------------------------------------

63. Implementing a Stack

Hopefully you had some success implementing the stack data structure in this section we're going to

go through some javascript implementation of a stack.

Now the thing to keep in mind here is that we're still going to be making use of an array to hold the

actual data.

And so we are essentially really just writing some accessor methods to kind of hook this stack class

up to the underlying array.

So with that in mind let's get to it.

I need to get myself a little bit of space here.

And then the first thing I'm going to do is to declare my constructor function because I need to initialize

an array when class stack is instantiated.

I will then use that internal array to manage all the data that gets added and removed from our stack.

So I create my constructor and then inside of your I will initialize an array and assign it to this

dot data like so.

Remember there is absolutely nothing special about assigning this ray to this dot data.

It could be this dot underlying container or this dot my stack or this dot my array whatever you want

it to be.

I'm just arbitrarily calling this thing this dot data.

So that will give us the underlying array that holds our actual data.

Next we're going to put together our push method so that we can push the record onto our stack.

So I will create a new method called Push.

It will accept a record as an argument and then we want to take this record and stick it into our array.

Now of course the arrays have an underlying method or have a method on them called Push that does the

exact same thing that we want to do.

So the push method adds a record to the very last index of an array.

So we'll simply say this data push like so now to make sure that we always get back the last record

or the most recently inserted record whenever we pop from our stack.

We can call the exact same named method on this array as well for our pop method.

So we'll add pop in for this one simply say return this dot data pop.

So if you're familiar with the push and pop methods on an array and I am really assuming that you are

here.

Yeah that's pretty much exactly what haystack is doing for us.

Not a lot of complexity here when it comes to the javascript implementation.

Nonetheless I do want you to kind of have an idea of how these things are put together in the javascript

world and the very last method we have to implement is the peak method.

So we'll add Teec.

And our goal with peak is to return the last record inside of our array without actually removing it.

So we can simply access this data at the last index.

So this data length minus one.

And then we want to make sure that we return that record.

All right.

So really not that bad just four methods four lines of code inside them total.

Let's check our test out to see how they're doing.

And yep we got for trespassing here.

So again whenever we think of a cue in a stack essentially identical except for the order in which we

are adding and removing records and heck I shouldn't even really say adding adding is the same.

The only real difference here is the order in which they get removed when we take them out of our data

structure.

So the two of them are very similar.

And to be honest there are not a tremendous number of interview questions that you might see around

QS or stocks directly.

Usually a lot of questions around user stacks are to say hey do X Y Z operation but you have to use

a queue or do X Y Z operation and you have to use a stack.

And so we'll see a very classic example of the type of interview question you will see with queues and

stacks and the next section.

So let's take a break and tackle that question.

See you in just a minute.
----------------------------------------------------------------------------------------------------------
==========================================================================================================